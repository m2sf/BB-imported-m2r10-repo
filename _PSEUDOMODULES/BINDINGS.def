(* (C) 2009, 2010 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* DOCUMENTATION *) MODULE BINDINGS;

(* Pseudo Module to Document Procedure Signatures for Binding Procedures *)


(* ADT means the abstract data type for which bindings are to be defined. *)


(* Bindings to TMIN and TMAX *)

CONST [TMIN] minValue = <value>;
(* Signature for a constant definition that binds a value to pervasive
   function TMIN when called with type ADT as an argument. *)

CONST [TMAX] maxValue = <value>;
(* Signature for a constant definition that binds a value to pervasive
   function TMAX when called with type ADT as an argument. *)


(* Bindings to assignment operations *)

(* Binding to the assign operator depends on the type of literal specified
   by the semantic type that the ADT has been defined to conform to. *)

PROCEDURE [:=] assign ( VAR v : <ADT>; CONST literal : ARRAY OF CHAR );
(* Signature for a procedure that binds to the assign operator for type <ADT>
   when ADT uses whole number, real number or string literals. *)

PROCEDURE [:=] assign ( VAR v : <ADT>; CONST elements : VARIADIC OF <T> );
(* Signature for a procedure that binds to the assign operator for type <ADT>
   when ADT uses structured literals. <elements> represent value components.*)



(* Bindings to conversion operations *)

(* One pair of bindings to the conversion operator per target type. *)

PROCEDURE [::] to ( x : <ADT> ) : <TargetType>;
(* Signature for a procedure that binds to the conversion operator
   for conversions from type <ADT> to type <TargetType>. *)

PROCEDURE [::] from ( x : <TargetType> ) : <ADT>;
(* Signature for a procedure that binds to the conversion operator
   for conversions from type <TargetType> to type <ADT>. *)


(* Bindings to scalar conversion primitives *)

PROCEDURE [SXF] toSXF ( x : <ADT>; VAR s : ARRAY OF CHAR );
(* Signature for a procedure that binds to pervasive procedure SXF
   to convert values of type <ADT> to scalar exchange format. *)

PROCEDURE [VAL] fromSXF ( CONST s : ARRAY OF CHAR; VAR x : <ADT> );
(* Signature for a procedure that binds to pervasive procedure VAL
   to convert scalar exchange format to values of type <ADT>. *)


(* Bindings to monadic operations *)

PROCEDURE [ABS] abs ( x : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to pervasive function ABS
   for arguments of type <ADT>. *)

PROCEDURE [NEG] neg ( x : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to pervasive function NEG
   for arguments of type <ADT>. *)

PROCEDURE [ODD] odd ( x : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to pervasive function NEG
   for arguments of type <ADT>. *)


(* Bindings to dyadic operations *)

PROCEDURE [+] plus ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the + operator
   for operands of type <ADT>. *)

PROCEDURE [-] minus ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the - operator
   for operands of type <ADT>. *)

PROCEDURE [*] asterisk ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the * operator
   for operands of type <ADT>. *)

PROCEDURE [/] slash ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the / operator
   for operands of type <ADT>. *)

PROCEDURE [DIV] div ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the DIV operator
   for operands of type <ADT>. *)

(* The operation for the ++ statement operator is synthesized as follows:
   for ADTs that use whole number literals:  x++  is replaced by  x := x + 1
   for ADTs that use real number literals :  x++  is replaced by  x := x + 1.0
   for ADTs that do not use numeric literals the ++ operation is undefined. *)

(* The operation for the -- statement operator is synthesized as follows:
   for ADTs that use whole number literals:  x--  is replaced by  x := x - 1
   for ADTs that use real number literals :  x--  is replaced by  x := x - 1.0
   for ADTs that do not use numeric literals the -- operation is undefined. *)


(* Bindings to relational operations *)

PROCEDURE [=] isEqual ( x1, x2 : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to the = operator
   for operands of type <ADT>. *)

(* The operation for the # operator is synthesized as NOT (x1 = x2) *)

PROCEDURE [<] isLess ( x1, x2 : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to the < operator
   for operands of type <ADT>. *)

(* The operation for the <= operator is synthesized as NOT (x1 > x2) *)

PROCEDURE [>] isGreater ( x1, x2 : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to the > operator
   for operands of type <ADT>. *)

(* The operation for the >= operator is synthesized as NOT (x1 < x2) *)


(* Storage mutator binding to [ ] operator *)

PROCEDURE [!] storeValue ( x           : <ADT>;
                           indexOrKey  : <IndexOrKeyType>;
                           CONST value : <ValueType> );
(* Signature for a storage mutator procedure that binds to the [ ] operator.
   Any assignment of the form  x[indexOrKey] := value  where <x> is of type
   <ADT> is replaced by a procedure call storeValue(x, indexOrKey, value) un-
   less the semantic type <ADT> conforms to is associative and value is NIL.*)


(* Removal mutator binding to [ ] operator *)

PROCEDURE [~] removeKeyValuePair ( x : <ADT>; key : <KeyType> );
(* Signature for a removal mutator procedure that binds to the [ ] operator
   when the semantic type that <ADT> conforms to is associative.
   Any assignment of the form  x[key] := NIL  where <x> is of type <ADT>
   will be replaced by a procedure call  removeKeyValuePair(x, key) .*)


(* Retrieval accessor binding to [ ] operator *)

PROCEDURE [?] valueAtIndex ( x     : <ADT>;
                             index : <IndexType> ) : <ValueType>;
(* Signature for an accessor function that binds to the [ ] operator
   when the semantic type that <ADT> conforms to is not associative.
   Any expression or sub-expression of the form  x[index]  where x is of type
   <ADT> will be replaced by a function call  valueAtIndex(x, index) .*)

PROCEDURE [?] valueForKey ( x              : <ADT>;
                            key            : <KeyType>;
                            VAR keyIsValid : BOOLEAN ) : <ValueType>;
(* Signature for an accessor function that binds to the [ ] operator
   when the semantic type that <ADT> conforms to is associative.
   Any expression or sub-expression of the form  x[key]  where x is of type
   <ADT> will be replaced by a function call  valueForKey(x, key, isValid). *)


(* Bindings to COUNT and LENGTH functions *)

PROCEDURE [COUNT] count ( x : <ADT> ) : LONGCARD;
(* Signature for a procedure that binds to pervasive function COUNT
   for arguments of type <ADT>. *)

PROCEDURE [LENGTH] length ( x : <ADT> ) : LONGCARD;
(* Signature for a procedure that binds to pervasive function LENGTH
   for arguments of type <ADT>. *)


(* Binding to FOR .. IN iterator *)

PROCEDURE [FOR] nextKeyValuePair ( x       : <ADT>;
                                   VAR key : <KeyType>;
                                   VAR val : <ValueType> );
(* Signature for a procedure that binds to the FOR .. IN .. iterator
   for iterations of the form  FOR key IN x DO  where x is of type <ADT>. *)


(* Bindings to NEW and DISPOSE procedures *)

PROCEDURE [NEW] new ( VAR x : <ADT> );
(* Signature for a procedure that binds to pervasive procedure NEW
   for arguments of type <ADT>. *)

PROCEDURE [DISPOSE] dispose ( VAR x : <ADT> );
(* Signature for a procedure that binds to pervasive procedure DISPOSE
   for arguments of type <ADT>. *)


END BINDINGS.