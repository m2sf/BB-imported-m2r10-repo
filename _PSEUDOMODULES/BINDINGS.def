(* (C) 2009, 2010 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* DOCUMENTATION *) MODULE BINDINGS;

(* Pseudo Module to Document Procedure Signatures for Binding Procedures *)


(* ADT means the abstract data type for which bindings are to be defined. *)


(* Bindings to TMIN and TMAX *)

CONST [TMIN] minValue = <value>;
(* Signature for a constant definition that binds a value to pervasive
   function TMIN when called with type ADT as an argument. *)

CONST [TMAX] maxValue = <value>;
(* Signature for a constant definition that binds a value to pervasive
   function TMAX when called with type ADT as an argument. *)


(* Bindings to assignment operations *)

(* Binding to the assign operator depends on the type of literal specified
   by the semantic type that the ADT has been defined to conform to. *)

PROCEDURE [:=] assign ( VAR v : <ADT>; CONST literal : ARRAY OF CHAR );
(* Signature for a procedure that binds to the assign operator for type <ADT>
   when ADT uses whole number, real number or string literals. *)

PROCEDURE [:=] assign ( VAR v : <ADT>; CONST elements : VARIADIC OF <T> );
(* Signature for a procedure that binds to the assign operator for type <ADT>
   when ADT uses structured literals. <elements> represent value components.*)



(* Bindings to conversion operations *)

(* One pair of bindings to the conversion operator per target type. *)

PROCEDURE [::] to ( x : <ADT> ) : <TargetType>;
(* Signature for a procedure that binds to the conversion operator
   for conversions from type <ADT> to type <TargetType>. *)

PROCEDURE [::] from ( x : <TargetType> ) : <ADT>;
(* Signature for a procedure that binds to the conversion operator
   for conversions from type <TargetType> to type <ADT>. *)


(* Bindings to monadic operations *)

PROCEDURE [ABS] abs ( x : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to pervasive function ABS
   for arguments of type <ADT>. *)

PROCEDURE [NEG] neg ( x : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to pervasive function NEG
   for arguments of type <ADT>. *)

PROCEDURE [ODD] odd ( x : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to pervasive function NEG
   for arguments of type <ADT>. *)


(* Bindings to dyadic operations *)

PROCEDURE [+] plus ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the + operator
   for operands of type <ADT>. *)

PROCEDURE [-] minus ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the - operator
   for operands of type <ADT>. *)

PROCEDURE [*] asterisk ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the * operator
   for operands of type <ADT>. *)

PROCEDURE [/] slash ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the / operator
   for operands of type <ADT>. *)

PROCEDURE [DIV] div ( x1, x2 : <ADT> ) : <ADT>;
(* Signature for a procedure that binds to the DIV operator
   for operands of type <ADT>. *)

(* The operation for the ++ statement operator is synthesized as follows:
   for ADTs that use whole number literals:  x++  is replaced by  x := x + 1
   for ADTs that use real number literals :  x++  is replaced by  x := x + 1.0
   for ADTs that do not use numeric literals the ++ operation is undefined. *)

(* The operation for the -- statement operator is synthesized as follows:
   for ADTs that use whole number literals:  x--  is replaced by  x := x - 1
   for ADTs that use real number literals :  x--  is replaced by  x := x - 1.0
   for ADTs that do not use numeric literals the -- operation is undefined. *)


(* Bindings to relational operations *)

PROCEDURE [=] isEqual ( x1, x2 : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to the = operator
   for operands of type <ADT>. *)

(* The operation for the # operator is synthesized as NOT (x1 = x2) *)

PROCEDURE [<] isLess ( x1, x2 : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to the < operator
   for operands of type <ADT>. *)

(* The operation for the <= operator is synthesized as NOT (x1 > x2) *)

PROCEDURE [>] isGreater ( x1, x2 : <ADT> ) : BOOLEAN;
(* Signature for a procedure that binds to the > operator
   for operands of type <ADT>. *)

(* The operation for the >= operator is synthesized as NOT (x1 < x2) *)


(* Bindings to scalar conversion primitives *)

PROCEDURE [TO] toSXF ( x : <ADT>; VAR s : ARRAY OF CHAR );
(* Signature for a procedure that binds to the internal scalar conversion
   primitive toSXF to convert values of type ADT to scalar exchange format. *)

PROCEDURE [FROM] fromSXF ( VAR x : <ADT>; CONST s : ARRAY OF CHAR );
(* Signature for a procedure that binds to the internal scalar conversion
   primitive fromSXF to convert scalar exchange format to type <ADT>. *)


(* Binding to the [ ] operator depends on the type of literal specified
   by the semantic type that the ADT has been defined to conform to. *)

(* Binding for accessor to [ ] operator *)

PROCEDURE [?] valueAtIndex ( x     : <ADT>;
                             index : <IndexType> ) : <ValueType>;
(* Signature for an accessor function that binds to the [ ] operator when the
   the semantic type that <ADT> conforms to does not specify NIL assignment.
   Any expression or sub-expression of the form  x[index]  where x is of type
   <ADT> will be replaced by a function call  valueAtIndex(x, index) .*)

PROCEDURE [?] retrieveValueForKey ( x         : <ADT>;
                                    key       : <KeyType>;
                                    VAR value : <ValueType>;
                                    VAR found : BOOLEAN );
(* Signature for an accessor procedure that binds to the [ ] operator
   when the semantic type that <ADT> conforms to specifies NIL assignment.
   Any expression or sub-expression of the form  x[key]  where <x> is of type
   <ADT> will be replaced by the value passed back in <value> in a preceding
   procedure call  retrieveValueForKey(x, key, value, found)  if TRUE is
   passed back in <found>, otherwise a runtime error will be raised. *)


(* Binding for mutator to [ ] operator *)

PROCEDURE [!] storeAtIndex ( x           : <ADT>;
                             index       : <IndexType>;
                             CONST value : <ValueType> );
(* Signature for a mutator procedure that binds to the [ ] operator when
   the semantic type that <ADT> conforms to does not specify NIL assignment.
   Any assignment of the form  x[index] := value  where x is of type <ADT>
   will be replaced by a procedure call storeAtIndex(x, index, value) .*)

PROCEDURE [!] storeValueForKey ( x           : <ADT>;
                                 key         : <KeyType>;
                                 CONST value : <ValueType>;
                                 remove      : BOOLEAN );
(* Signature for a mutator procedure that binds to the [ ] operator
   when the semantic type that <ADT> conforms to specifies NIL assignment.
   Any assignment of the form  x[key] := value  where <x> is of type <ADT>
   will be replaced by a mutator procedure call as follows:
   - if value is NIL      =>  storeValueForKey(x, key, dummyValue, TRUE)
   - if value is not NIL  =>  storeValueForKey(x, key, value, FALSE) .*)
   
(* The dummy value is synthesised automatically as follows:
   CONST dummyValue = SYSTEM.CAST(<ValueType>, {0 BY TSIZE(<ValueType>)}); *)


(* Bindings to COUNT and LENGTH functions *)

PROCEDURE [COUNT] count ( x : <ADT> ) : LONGCARD;
(* Signature for a procedure that binds to pervasive function COUNT
   for arguments of type <ADT>. *)

PROCEDURE [LENGTH] length ( x : <ADT> ) : LONGCARD;
(* Signature for a procedure that binds to pervasive function LENGTH
   for arguments of type <ADT>. *)


(* Binding to FOR .. IN iterator *)

PROCEDURE [FOR] next ( x : <ADT>;
                       VAR key : <KeyType>; VAR val : <ValueType> );
(* Signature for a procedure that binds to the FOR .. IN .. iterator
   for iterations of the form  FOR key IN x DO  where x is of tyoe <ADT>. *)


(* Bindings to NEW and DISPOSE procedures *)

PROCEDURE [NEW] new ( VAR x : <ADT> );
(* Signature for a procedure that binds to pervasive procedure NEW
   for arguments of type <ADT>. *)

PROCEDURE [DISPOSE] dispose ( VAR x : <ADT> );
(* Signature for a procedure that binds to pervasive procedure DISPOSE
   for arguments of type <ADT>. *)


END BINDINGS.