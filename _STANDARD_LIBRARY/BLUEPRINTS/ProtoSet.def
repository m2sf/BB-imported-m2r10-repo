(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Dynamically Allocatable Set ADTs *)

BLUEPRINT ProtoSet [ProtoCollection];

REFERENTIAL ElementType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE := { ARGLIST OF ElementType };
(* Dynamic Set ADTs must be opaque,
   structured literals with a list of elements are compatible *)


(* Required Constants *)


(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT is mutable.
   Its value may be TRUE or FALSE. *)


(* Orderedness *)

(* Use of FOR DESCENDING syntax with the ADT is only permitted
   when a constant is bound to DESCENDING and its value is TRUE. *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* Required constant to define whether the ADT is ordered.
   Its value may be TRUE or FALSE. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether the ADT is reference counted.
   Its value may be TRUE or FALSE. *)


(* Semantics of NIL Assignment *)

CONST [NIL] nilRemovesValue : BOOLEAN;
(* Required constant to define the semantics of assigning NIL to a value.
   NIL assignment is treated as a call to REMOVE when this value is TRUE. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the element limit of the ADT. *)

(* An expression of the form TLIMIT(SetADT))
   is synthesised as SetADT.capacityLimit(). *)


(* Binding to Predefined Function COUNT *)

PROCEDURE [COUNT] count ( set : ProtoSet ) : LONGCARD;
(* Required function to return the element count of a set. *)

(* An expression of the form COUNT(set)
   is synthesised as SetADT.count(set). *)


PROCEDURE capacity ( set : ProtoSet ) : LONGCARD;
(* Required function to return the allocated capacity of a set. *)

PROCEDURE entryLimit ( set : ProtoSet ) : LONGCARD;
(* Required function to return the value limit of a set. *)

PROCEDURE isResizable ( set : ProtoSet ) : BOOLEAN;
(* Required function to return the resizable property of a set. *)


(* Memory Management *)

(* Binding to Predefined Procedure NEW *)

PROCEDURE [NEW] new
  ( VAR set : ProtoSet; initWith : ARGLIST OF ElementType );
(* Required procedure to allocate a new set and initialise it
   with zero or more given elements. *)

(* A statement of the form NEW(set)
   is synthesised as SetADT.new(set).
   
   A statement of the form NEW(set, elem1, elem2, elem3, ...)
   is synthesised as SetADT.new(set, elem1, elem2, elem3, ...). *)


isMutable ->
PROCEDURE newWithCapacity
  ( VAR set : ProtoSet; capacity : LONGCARD );
(* Procedure to allocate a new set with a given initial capacity.
   The procedure is required when the ADT is mutable. *)


(* Binding to Predefined Procedure RETAIN *)

isRefCounted ->
PROCEDURE [RETAIN] retain ( VAR set : ProtoSet );
(* Procedure to retain a set and prevent its deallocation.
   The procedure is required when the ADT is reference counted. *)

(* A statement of the form RETAIN(set)
   is synthesised as SetADT.retain(set). *)


(* Binding to Predefined Procedure RELEASE *)

PROCEDURE [RELEASE] release ( VAR set : ProtoSet );
(* Required procedure to cancel an outstanding retain
   or deallocate a set if no retains are outstanding. *)

(* A statement of the form RELEASE(set)
   is synthesised as SetADT.release(set). *)


(* Literal Assignment *)

(* Binding to the := Operator *)

isMutable ->
PROCEDURE [:=] assignLiteral
  ( set : ProtoSet; literal : ARGLIST OF ElementType );
(* Procedure to destructively copy the contents of a set literal to an
   array. The procedure is required when the ADT is mutable. *)

(* A statement of the form
     set := { elem1, elem2, elem3, ... };
   is synthesised as
     SetADT.assignLiteral(set, elem1, elem2, elem3, ...). *)


(* Copying *)

(* Binding to Predefined Function DUP *)

PROCEDURE [DUP] newWithCopy ( source : ProtoSet ) : ProtoSet;
(* Required function to return a newly allocated copy of a set. *)

(* An expression of the form DUP(set)
   is synthesised as SetADT.newWithCopy(set). *)


(* Binding to Predefined Procedure COPY *)

isMutable ->
PROCEDURE [COPY] copy ( source : ProtoSet; VAR target : ProtoSet );
(* Procedure to destructively copy the contents of one set to another.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form COPY(set1, set2)
   is synthesised as SetADT.copy(set1, set2). *)


(* Value Storage *)

(* Binding to Predefined Procedure STORE *)

isMutable ->
PROCEDURE [STORE] storeElement
 ( VAR set : ProtoSet; element : ElementType; membership : BOOLEAN );
(* Procedure to store a membership value for an element in a set.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form set[element] := TRUE
   is equivalent to STORE(set, element, TRUE) and
   is synthesised as SetADT.storeElement(set, element, TRUE). *)


(* Value Retrieval *)

(* Binding to Predefined Function RETRIEVE *)

PROCEDURE [RETRIEVE] isElement
  ( set : ProtoSet; element : ElementType ) : BOOLEAN;
(* Required function to return the membership value for an element in a set. *)

(* An expression of the form set[element]
   is equivalent to RETRIEVE(set, element) and
   is synthesised as SetADT.isElement(set, element). *)


(* Value Insertion *)

(* Binding to Predefined Procedure INSERT *)

isMutable ->
PROCEDURE [INSERT] insertElements
  ( targetSet : ProtoSet;
    elements : ARGLIST OF ElementType );
(* Procedure to insert a list of elements into a target set.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     INSERT(set, elem1, elem2, elem3, ...)
   is synthesised as
     SetADT.insertElements(set, elem1, elem2, elem3, ...). *)


isMutable ->
PROCEDURE insertSet ( targetSet, sourceSet : ProtoSet );
(* Procedure to insert the elements of a source set into a target set.
   The procedure is required when the ADT is mutable. *)


(* Value Removal *)

(* Binding to Predefined Procedure REMOVE *)

isMutable ->
PROCEDURE [REMOVE] removeElements
  ( set : ProtoSet; elements : ARGLIST OF ElementType );
(* Procedure to remove one or more elements from a set.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     REMOVE(set, elem1, elem2, elem3, ...);
   is synthesised as
     SetADT.removeElements(set, elem1, elem2, elem3, ...).
   
   A statement of the form
     set[element] := NIL
   is treated equivalent to
     REMOVE(set, element)
   if a constant of value TRUE is bound to NIL. *)


(* TO DO:
   How do we express that IN and RETRIEVE share the same function? *)


(* Membership Test *)

(* Binding to the IN Operator *)

PROCEDURE [IN] ... ;
(* Required function to test whether a value is stored in a set. *)

(* An expression of the form elem IN set
   is synthesised as SetADT.isElement(set, elem). *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoSet, CONST ElementType );
(* Required procedure type to synthesise the body of a for loop. *)

PROCEDURE [FOR] forIterator
  ( VAR set : ProtoSet; doStatements : LoopBodyType; ascending : BOOLEAN );

(* Required procedure to iterate over all index/value pairs of an array
   in a given order and execute the passed in doStatements for each pair. *)
   
(* A statement of the form
     FOR element IN set DO statementSeq END
   is synthesised in two steps.
   
   The loop header is synthesised as
     SetADT.forIterator( set, forLoopBody, TRUE );
   
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR set : SetADT; CONST element : ElementType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   
   The loop header of a FOR DESCENDING statement is sythesised with
   FALSE passed for parameter ascending in the call to forIterator. *)


(* Set Operations *) 

(* Binding to the + Operator *)

isRefCounted ->
PROCEDURE [+] union ( set1, set2 : ProtoSet ) : ProtoSet;
(* Function to return the union of two sets.
   The function is required when the ADT is reference counted. *)

(* An expression of the form set1 + set2
   is synthesised as SetADT.union(set1, set2). *)


(* Binding to the - Operator *)

isRefCounted ->
PROCEDURE [-] difference ( set1, set2 : ProtoSet ) : ProtoSet;
(* Function to return the set difference of two sets.
   The function is required when the ADT is reference counted. *)

(* An expression of the form set1 - set2
   is synthesised as SetADT.difference(set1, set2). *)


(* Binding to the * Operator *)

isRefCounted ->
PROCEDURE [*] intersection ( set1, set2 : ProtoSet ) : ProtoSet;
(* Function to return the intersection of two sets.
   The function is required when the ADT is reference counted. *)

(* An expression of the form set1 * set2
   is synthesised as SetADT.intersection(set1, set2). *)


(* Binding to the / Operator *)

isRefCounted ->
PROCEDURE [/] symmetricDiff ( set1, set2 : ProtoSet ) : ProtoSet;
(* Functon to return the symmetric difference of two sets.
   The function is required when the ADT is reference counted. *)

(* An expression of the form set1 / set2
   is synthesised as SetADT.symmetricDiff(set1, set2). *)


(* Relational Operations *)

(* Binding to the = and # Operators *)

PROCEDURE [=] isEqual ( set1, set2 : ProtoSet ) : BOOLEAN;
(* Required unction to test the equality of two sets. *)

(* An expression of the form set1 = set2
   is synthesised as SetADT.isEqual(set1, set2).
   
   An expression of the form set1 # set2
   is synthesised as NOT SetADT.isEqual(set1, set2). *)


(* Binding to Predefined Function SUBSET *)

PROCEDURE [SUBSET] isSubset ( set1, set2 : ProtoSet ) : BOOLEAN;
(* Required function to test whether one set is a subset of another. *)

(* An expression of the form set1 > set2
   is synthesised as SetADT.isSubset(set2, set1).
   
   An expression of the form set1 >= set2 is synthesised as
   (COUNT(set1) > COUNT(set2)) AND SetADT.isSubset(set2, set1). *)
   
   An expression of the form set1 < set2
   is synthesised as SetADT.isSubset(set1, set2).
   
   An expression of the form set1 <= set2 is synthesised as
   (COUNT(set1) < COUNT(set2)) AND SetADT.isSubset(set1, set2). *)


END ProtoSet.