(* (C) 2009-2013 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Dynamically Allocatable Set ADTs *)

BLUEPRINT ProtoSet [ProtoCollection];

REFERENTIAL ElementType, ProcType, File;

(* Dynamic Set ADTs must be opaque,
   structured literals with a list of elements are compatible *)

TYPE ProtoSet = OPAQUE := { VARIADIC OF ElementType };


(* Bindings required for dynamic set ADTs *)


(* Required Constants *)

CONST [:=] isMutable : BOOLEAN;
(* whether the set ADT is mutable *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* whether the set ADT is ordered *)


(* Capacity limit *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the allocation capacity limit of a set ADT. *)

(* An expression of the form TLIMIT(ADT)) is transformed at compile
   time to ADT.capacityLimit() when the operand is the ADT type. *)


(* Memory Management *)

PROCEDURE [NEW] new ( VAR set : ProtoSet; capacity : LONGCARD );
(* Procedure to allocate and initialise a new set. *)

(* An invocation of NEW(set, n) is transformed at compile time to
   ADT.new(set, n) for first operands of the ADT type. *)


PROCEDURE [RETAIN] retain ( set : ProtoSet );
(* Procedure to retain a set. *)

(* An invocation of RETAIN(set) is transformed at compile time to
   ADT.retain(set) for operands of the ADT type. *)


PROCEDURE [RELEASE] release ( VAR set : ProtoSet );
(* Procedure to release and eventually deallocate a set. *)

(* An invocation of RELEASE(set) is transformed at compile time to
   ADT.release(set) for operands of the ADT type. *)


(* Copying *)

PROCEDURE [COPY] copy ( sourceSet : ProtoSet; VAR target : ProtoSet );
(* Procedure to copy the contents of one set to another. *)

(* An invocation of COPY(set1, set2) is transformed at compile time to
   ADT.copy(set1, set2) for operands of the ADT type. *)


(* Storage, Removal, Retrieval and Inspection of Contents *)

PROCEDURE [STORE] storeElements
  ( VAR set : ProtoSet; valueList : VARIADIC OF ElementType );
(* Procedure to store zero or more elements in a set. *)

(* An invocation of STORE(set, elem1, elem2, elem3 ...) is transformed
   at compile time to ADT.storeElements(set, elem1, elem2, elem3 ...)
   for first operands of the ADT type. *)


PROCEDURE [REMOVE] removeElements
  ( VAR set : ProtoSet; valueList : VARIADIC OF ElementType );
(* Procedure to remove one or more elements from a set. *)

(* An invocation of REMOVE(set, elem1, elem2, elem3 ...) is transformed
   at compile time to ADT.removeElements(set, elem1, elem2, elem3 ...)
   for first operands of the ADT type. *)


PROCEDURE [RETRIEVE] membershipForElement
  ( set : ProtoSet; value : ElementType ) : BOOLEAN;
(* Function to retrieve a value from a set. *)

(* An incocation of RETRIEVE(set, elem) is transformed at compile time to
   ADT.membershipForElement(set, elem) for first operands of the ADT type. *)


PROCEDURE [IN] isElement
  ( set : ProtoSet; value : CHAR ) : BOOLEAN;
(* Function to test whether a value is stored in a set. *)

(* An expression of the form elem IN set is transformed at compile time to
   ADT.isElement(set, elem) for first operands of the ADT type. *)


PROCEDURE [COUNT] count ( set : ProtoSet ) : LONGCARD;
(* Procedure to return the element count of a set. *)

(* An expression of the form COUNT(set) is transformed at compile time to
   ADT.count(set) for operands of the ADT type. *)


(* Iteration *)

TYPE ProcType = PROCEDURE ( ElementType );

PROCEDURE [FOR] forIterator
  ( set : ProtoSet; forLoopBody : ProcType; ascending : BOOLEAN );
(* Procedure to iterate over all elements of a set and invoke procedure
   forLoopBody for each element with the given iteration order. *)
   
(* A statement of the form
     FOR elem IN set DO statementSeq END
   is transformed at compile time in two steps.
   The loop header is transformed to
     ADT.forIterator( set, forLoopBody, TRUE );
   The loop body is transformed to a procedure definition
     <* INLINE *> PROCEDURE forLoopBody ( element : ElementType );
     BEGIN statementSeq END forLoopBody;
   inserted before the current scope's BEGIN-END block.
   
   A loop header of the form
     FOR DESCENDING elem IN set
   is transformed at compile time to
     ADT.forIterator(set, forLoopBody, FALSE)
   To allow this, an ADT must bind a constant of value TRUE to DESCENDING. *)   


(* Set Operations *) 

PROCEDURE [+] union
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Procedure to return the union of two sets. *)

(* An expression of the form set1 + set2 is transformed at compile time to
   ADT.union(set1, set2) for operands of the ADT type. *)


PROCEDURE [-] difference
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Procedure to return the set difference of two sets. *)

(* An expression of the form set1 - set2 is transformed at compile time to
   ADT.difference(set1, set2) for operands of the ADT type. *)


PROCEDURE [*] intersection
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Procedure to return the intersection of two sets. *)

(* An expression of the form set1 * set2 is transformed at compile time to
   ADT.intersection(set1, set2) for operands of the set ADT type. *)


PROCEDURE [/] symmetricDiff
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Procedure to return the symmetric difference of two sets. *)

(* An expression of the form set1 / set2 is transformed at compile time to
   ADT.symmetricDiff(set1, set2) for operands of the set ADT type. *)


(* Relational operations *)

PROCEDURE [=] isEqual ( set1, set2 : ProtoSet ) : BOOLEAN;
(* Procedure to test the equality of two sets. *)

(* An expression of the form set1 = set2 is transformed at compile time to
   ADT.isEqual(set1, set2) for operands of the set ADT type.
   
   An expression of the form set1 # set2 is transformed at compile time to
   NOT ADT.isEqual(set1, set2) for operands of the set ADT type. *)


PROCEDURE [SUBSET] isSubset ( set1, set2 : ProtoSet ) : BOOLEAN;
(* Procedure to test whether one set is a subset of another. *)

(* An expression of the form set1 > set2 is transformed at compile time to
   ADT.isSubset(set2, set1) for operands of the set ADT type.
   
   An expression of the form set1 >= set2 is transformed at compile time
   to (COUNT(set1) > COUNT(set2)) AND ADT.isSubset(set2, set1) for
   operands of the set ADT type.
   
   An expression of the form set1 < set2 is transformed at compile time to
   ADT.isSubset(set1, set2) for operands of the set ADT type.
   
   An expression of the form set1 <= set2 is transformed at compile time
   to (COUNT(set1) < COUNT(set2)) AND ADT.isSubset(set1, set2) for
   operands of the set ADT type. *)
   

(* IO operations *)

PROCEDURE [READ] Read ( infile : File; VAR set : ProtoSet );
(* Procedure to read a value from a file into a set. *)

(* A statement of the form READ(file, set) is transformed at compile time
   to ADT.Read(file, set) for second operands of the ADT type. *)


PROCEDURE [READ] Write ( outfile : File; set : ProtoSet );
(* Procedure to write a set ADT value to a file. *)

(* A statement of the form WRITE(file, set) is transformed at compile time
   to ADT.Write(file, set) for second operands of the ADT type. *)


PROCEDURE [WRITEF] WriteF
  ( outfile      : File;
    CONST fmtStr : ARRAY OF CHAR;
    items        : VARIADIC OF ProtoSet );
(* Procedure to write one or more sets formatted into a file. *)

(* A statement of the form WRITEF(file, fmt, set1, set2, set3, ...) is trans-
   formed at compile time to ADT.WriteF(file, fmt, set1, set2, set3, ...) for
   third operands and any following operands of the ADT type. *)


(* Introspection *)

PROCEDURE capacity ( set : ProtoSet ) : LONGCARD;
(* Function to return the allocated capacity of a set. *)


PROCEDURE entryLimit ( set : ProtoSet ) : LONGCARD;
(* Function to return the value limit of a set. *)


PROCEDURE isResizable ( set : ProtoSet ) : BOOLEAN;
(* Function to return the resizable property of a set. *)


END ProtoSet.