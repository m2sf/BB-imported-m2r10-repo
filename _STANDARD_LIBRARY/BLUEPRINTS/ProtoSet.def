(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Dynamically Allocatable Set ADTs *)

BLUEPRINT ProtoSet [ProtoCollection];

REFERENTIAL ElementType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE := { ARGLIST OF ElementType };
(* Dynamic Set ADTs must be opaque,
   structured literals with a list of elements are compatible *)


(* Required Constants *)


(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT is mutable.
   Its value may be TRUE or FALSE. *)


(* Orderedness *)

(* Use of FOR DESCENDING syntax with the ADT is only permitted
   when a constant is bound to DESCENDING and its value is TRUE. *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* Required constant to define whether the ADT is ordered.
   Its value may be TRUE or FALSE. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether the ADT is reference counted.
   Its value may be TRUE or FALSE. *)


(* Semantics of NIL Assignment *)

CONST [NIL] nilRemovesValue : BOOLEAN;
(* Required constant to define the semantics of assigning NIL to a value.
   NIL assignment is treated as a call to REMOVE when this value is TRUE. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the element limit of the ADT. *)

(* An expression of the form TLIMIT(SetADT))
   is synthesised as SetADT.capacityLimit(). *)


(* Binding to Predefined Function COUNT *)

PROCEDURE [COUNT] count ( set : ProtoSet ) : LONGCARD;
(* Required function to return the element count of a set. *)

(* An expression of the form COUNT(set)
   is synthesised as SetADT.count(set). *)


(* Memory Management *)

(* Binding to Predefined Procedure NEW *)

PROCEDURE [NEW] new
  ( VAR set : ProtoSet; initWith : ARGLIST OF ElementType );
(* Required procedure to allocate a new set and initialise it
   with zero or more given elements. *)

(* A statement of the form NEW(set)
   is synthesised as SetADT.new(set).
   
   A statement of the form NEW(set, elem1, elem2, elem3, ...)
   is synthesised as SetADT.new(set, elem1, elem2, elem3, ...). *)


isMutable ->
PROCEDURE newWithCapacity
  ( VAR set : ProtoSet; capacity : LONGCARD );
(* Procedure to allocate a new set with a given initial capacity.
   The procedure is required when the ADT is mutable. *)


(* Binding to Predefined Procedure RETAIN *)

isRefCounted ->
PROCEDURE [RETAIN] retain ( VAR set : ProtoSet );
(* Procedure to retain a set and prevent its deallocation.
   The procedure is required when the ADT is reference counted. *)

(* A statement of the form RETAIN(set)
   is synthesised as SetADT.retain(set). *)


(* Binding to Predefined Procedure RELEASE *)

PROCEDURE [RELEASE] release ( VAR set : ProtoSet );
(* Required procedure to cancel an outstanding retain
   or deallocate a set if no retains are outstanding. *)

(* A statement of the form RELEASE(set)
   is synthesised as SetADT.release(set). *)


(* Literal Assignment *)

(* Binding to the := Operator *)

isMutable ->
PROCEDURE [:=] assignLiteral
  ( set : ProtoSet; literal : ARGLIST OF ElementType );
(* Procedure to destructively copy the contents of a set literal to an
   array. The procedure is required when the ADT is mutable. *)

(* A statement of the form
     set := { elem1, elem2, elem3, ... };
   is synthesised as
     SetADT.assignLiteral(set, elem1, elem2, elem3, ...). *)


(* Copying *)

(* Binding to Predefined Function DUP *)

PROCEDURE [DUP] newWithCopy ( source : ProtoSet ) : ProtoSet;
(* Required function to return a newly allocated copy of a set. *)

(* An expression of the form DUP(set)
   is synthesised as SetADT.newWithCopy(set). *)


(* Binding to Predefined Procedure COPY *)

isMutable ->
PROCEDURE [COPY] copy ( source : ProtoSet; VAR target : ProtoSet );
(* Procedure to destructively copy the contents of one set to another.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form COPY(set1, set2)
   is synthesised as SetADT.copy(set1, set2). *)


(* Value Storage *)

(* Binding to Predefined Procedure STORE *)

isMutable ->
PROCEDURE [STORE] storeElement
 ( VAR set : ProtoSet; element : ElementType; membership : BOOLEAN );
(* Procedure to store a membership value for an element in a set.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form set[element] := TRUE
   is equivalent to STORE(set, element, TRUE) and
   is synthesised as SetADT.storeElement(set, element, TRUE). *)


(* Value Retrieval *)

(* Binding to Predefined Function RETRIEVE *)

PROCEDURE [RETRIEVE] isElement
  ( set : ProtoSet; element : ElementType ) : BOOLEAN;
(* Required function to return the membership value for an element in a set. *)

(* An expression of the form set[element]
   is equivalent to RETRIEVE(set, element) and
   is synthesised as SetADT.isElement(set, element). *)


(* Value Insertion *)

(* Binding to Predefined Procedure INSERT *)

isMutable ->
PROCEDURE [INSERT] insertElements
  ( targetSet : ProtoSet;
    elements : ARGLIST OF ElementType );
(* Procedure to insert a list of elements into a target set.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     INSERT(set, elem1, elem2, elem3, ...)
   is synthesised as
     SetADT.insertElements(set, elem1, elem2, elem3, ...). *)


isMutable ->
PROCEDURE insertSet ( targetSet, sourceSet : ProtoSet );
(* Procedure to insert the elements of a source set into a target set.
   The procedure is required when the ADT is mutable. *)


(* Value Removal *)

(* Binding to Predefined Procedure REMOVE *)

isMutable ->
PROCEDURE [REMOVE] removeElements
  ( set : ProtoSet; elements : ARGLIST OF ElementType );
(* Procedure to remove one or more elements from a set.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     REMOVE(set, elem1, elem2, elem3, ...);
   is synthesised as
     SetADT.removeElements(set, elem1, elem2, elem3, ...).
   
   A statement of the form
     set[element] := NIL
   is treated equivalent to
     REMOVE(set, element)
   if a constant of value TRUE is bound to NIL. *)


PROCEDURE [IN]
(* How do we express that IN and RETRIEVE share the same function? *);
(* Function to test whether a value is stored in a set. *)

(* An expression of the form elem IN set is transformed at compile time to
   ADT.isElement(set, elem) for first operands of the ADT type. *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoSet, CONST ElementType );
(* Required procedure type to synthesise the body of a for loop. *)

PROCEDURE [FOR] forIterator
  ( VAR set : ProtoSet; doStatements : LoopBodyType; ascending : BOOLEAN );

(* Required procedure to iterate over all index/value pairs of an array
   in a given order and execute the passed in doStatements for each pair. *)
   
(* A statement of the form
     FOR element IN set DO statementSeq END
   is synthesised in two steps.
   
   The loop header is synthesised as
     SetADT.forIterator( set, forLoopBody, TRUE );
   
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR set : SetADT; CONST element : ElementType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   
   The loop header of a FOR DESCENDING statement is sythesised with
   FALSE passed for parameter ascending in the call to forIterator. *)


(* TO DO : review from this point forward *)


(* Set Operations *) 

isRefCounted ->
PROCEDURE [+] union
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Function to return the union of two sets. *)

(* An expression of the form set1 + set2 is transformed at compile time to
   ADT.union(set1, set2) for operands of the ADT type. *)


isRefCounted ->
PROCEDURE [-] difference
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Function to return the set difference of two sets. *)

(* An expression of the form set1 - set2 is transformed at compile time to
   ADT.difference(set1, set2) for operands of the ADT type. *)


isRefCounted ->
PROCEDURE [*] intersection
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Function to return the intersection of two sets. *)

(* An expression of the form set1 * set2 is transformed at compile time to
   ADT.intersection(set1, set2) for operands of the set ADT type. *)


isRefCounted ->
PROCEDURE [/] symmetricDiff
  ( set1, set2 : ProtoSet ) : ProtoSet;
(* Functon to return the symmetric difference of two sets. *)

(* An expression of the form set1 / set2 is transformed at compile time to
   ADT.symmetricDiff(set1, set2) for operands of the set ADT type. *)


(* Relational Operations *)

PROCEDURE [=] isEqual ( set1, set2 : ProtoSet ) : BOOLEAN;
(* Function to test the equality of two sets. *)

(* An expression of the form set1 = set2 is transformed at compile time to
   ADT.isEqual(set1, set2) for operands of the set ADT type.
   
   An expression of the form set1 # set2 is transformed at compile time to
   NOT ADT.isEqual(set1, set2) for operands of the set ADT type. *)


PROCEDURE [SUBSET] isSubset ( set1, set2 : ProtoSet ) : BOOLEAN;
(* Function to test whether one set is a subset of another. *)

(* An expression of the form set1 > set2 is transformed at compile time to
   ADT.isSubset(set2, set1) for operands of the set ADT type.
   
   An expression of the form set1 >= set2 is transformed at compile time
   to (COUNT(set1) > COUNT(set2)) AND ADT.isSubset(set2, set1) for
   operands of the set ADT type.
   
   An expression of the form set1 < set2 is transformed at compile time to
   ADT.isSubset(set1, set2) for operands of the set ADT type.
   
   An expression of the form set1 <= set2 is transformed at compile time
   to (COUNT(set1) < COUNT(set2)) AND ADT.isSubset(set1, set2) for
   operands of the set ADT type. *)
   

(* IO operations *)

PROCEDURE [READ] Read ( infile : File; VAR set : ProtoSet );
(* Procedure to read a value from a file into a set. *)

(* A statement of the form READ(file, set) is transformed at compile time
   to ADT.Read(file, set) for second operands of the ADT type. *)


PROCEDURE [WRITE] Write ( outfile : File; set : ProtoSet );
(* Procedure to write a set ADT value to a file. *)

(* A statement of the form WRITE(file, set) is transformed at compile time
   to ADT.Write(file, set) for second operands of the ADT type. *)


PROCEDURE [WRITEF] WriteF
  ( outfile      : File;
    CONST fmtStr : ARRAY OF CHAR;
    items        : ARGLIST OF ProtoSet );
(* Procedure to write one or more sets formatted into a file. *)

(* A statement of the form WRITEF(file, fmt, set1, set2, set3, ...) is trans-
   formed at compile time to ADT.WriteF(file, fmt, set1, set2, set3, ...) for
   third operands and any following operands of the ADT type. *)


(* Introspection *)

PROCEDURE capacity ( set : ProtoSet ) : LONGCARD;
(* Function to return the allocated capacity of a set. *)


PROCEDURE entryLimit ( set : ProtoSet ) : LONGCARD;
(* Function to return the value limit of a set. *)


PROCEDURE isResizable ( set : ProtoSet ) : BOOLEAN;
(* Function to return the resizable property of a set. *)


END ProtoSet.