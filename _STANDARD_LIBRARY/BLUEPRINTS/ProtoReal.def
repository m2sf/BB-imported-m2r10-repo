(* (C) 2012-2015 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Real Number ADTs *)

BLUEPRINT ProtoReal [ProtoScalar]; (* conforms to ProtoScalar *)


(* Required Module Type *)

MODULE TYPE = RECORD;
(* Real ADTs must be records to be statically allocatable. *)

LITERAL = REAL;
(* Real number literals are compatible. *)


(* Required Constants *)

CONST [TSIGNED] isSigned = TRUE;
(* Real ADTs are always signed. *)

CONST [TBASE] base : CARDINAL;
(* Radix in which the ADT's values are encoded, 2 or 10. *)

CONST [TPRECISION] precision : CARDINAL;
(* Maximum number of digits the ADT can encode, 1 to 4000. *)

CONST [TMINEXP] eMin : INTEGER;
(* Value of the ADT's smallest exponent. *)

CONST [TMAXEXP] eMax : INTEGER;
(* Value of the ADT's largest exponent. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TMIN *)

PROCEDURE [TMIN] minValue : ProtoReal;
(* Required function to return the minimal value the ADT can encode. *)

(* An expression of the form TMIN(RealADT)
   is synthesised as RealADT.minValue(). *)


(* Binding to Predefined Function TMAX *)

PROCEDURE [TMAX] maxValue : ProtoReal;
(* Required function to return the maximal value the ADT can encode. *)

(* An expression of the form TMAX(RealADT)
   is synthesised as RealADT.maxValue(). *)


(* Numeric Conversion *)

(* Binding to scalar conversion primitives SXF and VAL *)

PROCEDURE [SXF] toSXF ( value : ProtoReal; VAR sxf : ARRAY OF OCTET );
(* Required procedure to convert a real value to scalar exchange format. *)

PROCEDURE [VAL] fromSXF ( sxf : ARRAY OF OCTET; VAR value : ProtoReal );
(* Required procedure to convert from scalar exchange format to the ADT. *)

(* Conversion between any two scalar ADTs can be synthesised utilising the
   ADTs' conversion procedures bound to SXF and VAL.
   
   A conversion expression of the form
     intValue :: CardinalADT
   is synthesised as
     IntegerADT.toSXF(intValue, temp);
     CardinalADT.fromSXF(temp, result);
   when no direct conversion is implemented. *)


(* Literal Assignment *)

(* Numeric literals are converted to scalar exchange format at compile time.
   Assignments of numeric literals to numeric ADTs are then synthesised
   utilising an ADT's conversion procedure bound to VAL.
   
   An assignment of the form
     r := 1.23;
   is synthesised as
     RealADT.fromSXF(sxfCompiletimeValue, r); *)


(* Arithmetic Operations *)

(* Binding to Predefined Function ABS *)

PROCEDURE [ABS] abs ( r : ProtoReal ) : ProtoReal;
(* Required function to return the sign removed value of a real number. *)

(* An expression of the form ABS(r)
   is synthesised as RealADT.abs(r). *)


(* Binding to Unary Minus *)

PROCEDURE [+/-] neg ( r : ProtoReal ) : BOOLEAN;
(* Required function to return the sign reversed value of a real number. *)

(* An expression of the form -r
   is synthesised as RealADT.neg(r). *)


(* Binding to the + Operator *)

PROCEDURE [+] add ( r1, r2 : ProtoReal ) : ProtoReal;
(* Required function to return the sum of two real numbers. *)

(* An expression of the form r1 + r2
   is synthesised as RealADT.add(r1, r2). *)


(* Binding to the - Operator *)

PROCEDURE [-] subtract ( r1, r2 : ProtoReal ) : ProtoReal;
(* Required function to return the difference of two real numbers. *)

(* An expression of the form r1 - r2
   is synthesised as RealADT.subtract(i, j). *)


(* Binding to the * Operator *)

PROCEDURE [*] multiply ( r1, r2 : ProtoReal ) : ProtoReal;
(* Required function to return the product of two real numbers. *)

(* An expression of the form r1 * r2
   is synthesised as RealADT.multiply(r1, r2). *)


(* Binding to the / Operator *)

PROCEDURE [/] divide ( r1, r2 : ProtoReal ) : ProtoReal;
(* Required function to return the quotient of two real numbers, using
   real number division. *)

(* An expression of the form r1 / r2
   is synthesised as RealADT.divide(r1, r2). *)


(* Relational Operations *)

(* Binding to Operators = and # *)

PROCEDURE [=] isEqual ( r1, r2 : ProtoReal ) : BOOLEAN;
(* Required function to test the equivalence of two real numbers. *)

(* An expression of the form r1 = r2
   is synthesised as RealADT.isEqual(r1, r2).
   
   An expression of the form r1 # r2
   is synthesised as (NOT RealADT.isEqual(r1, r2)). *)


(* Binding to Operators < and >= *)

PROCEDURE [<] isLess ( r1, r2 : ProtoReal ) : BOOLEAN;
(* Required function to test if one real number is less than another. *)

(* An expression of the form r1 < r2
   is synthesised as RealADT.isLess(r1, r2).
   
   An expression of the form r1 >= r2
   is synthesised as (NOT RealADT.isLess(r1, r2)). *)


(* Binding to Operators > and <= *)

PROCEDURE [>] isGreater ( r1, r2 : ProtoReal ) : BOOLEAN;
(* Required function to test if one real number is greater than another. *)

(* An expression of the form r1 > r2
   is synthesised as RealADT.isGreater(r1, r2).
   
   An expression of the form r1 <= r2
   is synthesised as (NOT RealADT.isGreater(r1, r2)). *)


END ProtoReal.