(* M2 R10 Project, (c) 2014 B.Kowarsch & R.Sutcliffe, all rights reserved. *)

(* Array Algebra *)

(* Exploration of possible use cases for array algebra,
   required bindings and resulting compile time transformations. *)

(* Status: Dec 12, 2014 *)


(* =======================
 *    U s e   C a s e s
 * ======================= *)


(* Sign Operations *)

(* Sign Removal *)

array1 := ABS(array2);


(* Sign Reversal *)

array1 := -array2;


(* Array-Array Operations *)

(* Addition *)

array1 := array2 + array3;


(* Subtraction *)

array1 := array2 - array3;


(* Multiplication *)

array1 := array2 * array3;


(* Division *)

array1 := array2 / array3;


(* Scalar-Array Operations *)

(* Addition *)

(* option #1 : overload + operator *)

array1 := scalar + array2;

array1 := array2 + scalar;


(* option #2 : special symbol operator *)

array1 := scalar +: array2;

array1 := array2 :+ scalar;


(* option #3 : extension library function *)

array1 := Array.addScalar(array2, scalar);


(* Subtraction *)

(* option #1 : overload - operator *)

array1 := scalar - array2;

array1 := array2 - scalar;


(* option #2 : special symbol operator *)

array1 := scalar -: array2;

array1 := array2 :- scalar;


(* option #3 : extension library functions *)

array1 := Array.subFromScalar(scalar, array2);

array1 := Array.subScalar(array2, scalar);


(* Multiplication *)

(* option #1 : overload + operator *)

array1 := scalar * array2;

array1 := array2 * scalar;


(* option #2 : special symbol operator *)

array1 := scalar *: array2;

array1 := array2 :* scalar;


(* option #3 : extension library function *)

array1 := Array.mulScalar(array2, scalar);


(* Division *)

(* option #1 : overload / operator *)

array1 := scalar / array2;

array1 := array2 / scalar;


(* option #2 : special symbol operator *)

array1 := scalar /: array2;

array1 := array2 :/ scalar;


(* option #3 : extension library functions *)

array1 := Array.divScalar(scalar, array2);

array1 := Array.divByScalar(array2, scalar);


(* Rotation and Shift Operations *)

(* Left Rotation *)

Array.newByRotatingLeft(array1, array2, n);

Array.rotateLeft(array, n);


(* Right Rotation *)

Array.newByRotatingRight(array1, array2, n);

Array.rotateRight(array, n);


(* Left Shift *)

Array.newByShiftingLeft(array1, array2, n, fillValue);

Array.shiftLeft(array, n, fillValue);


(* Right Shift *)

Array.newByShiftingRight(array1, array2, n, fillValue);

Array.shiftRight(array, n, fillValue);


(* =====================
 *    B i n d i n g s
 * ===================== *)


(* Sign Operations *)

(* Sign Removal *)

PROCEDURE [ABS] abs ( NEW result : Array; operand : Array );


(* Sign Reversal *)

PROCEDURE [NEG] neg ( NEW result : Array; operand : Array );


(* Array-Array Operations *)

(* Addition *)

PROCEDURE [+] newWithSums ( NEW result : Array; left, right : Array );

PROCEDURE [+] add ( VAR result : Array; left, right : Array );


(* Subtraction *)

PROCEDURE [-] newWithDifferences ( NEW result : Array; left, right : Array );

PROCEDURE [-] sub ( VAR result : Array; left, right : Array );


(* Multiplication *)

PROCEDURE [*] newWithProducts ( NEW result : Array; left, right : Array );

PROCEDURE [*] mul ( VAR result : Array; left, right : Array );


(* Division *)

PROCEDURE [/] newWithQuotients ( NEW result : Array; left, right : Array );

PROCEDURE [/] div ( VAR result : Array; left, right : Array );


(* Scalar-Array Operations *)

(* no bindings *)

(* transformations could be synthesised automatically *)


(* ===================================
 *    T r a n s f o r m a t i o n s
 * =================================== *)


(* Sign Operations *)

(* Sign Removal *)

array1 := ABS(array2);

=> VAR temp : Array;
   Array.newByRemovingSign(temp, array2);
   array1 := temp;

NEW array1 := ABS(array2);

=> IF array1 # NIL THEN RaiseRuntimeFault(formalNewParamNotNil) END;
   Array.newByRemovingSign(array1, array2);

COPY array1 := ABS(array2);

=> Array.abs(array1, array2);


(* Sign Reversal *)

array1 := -array2;

=> VAR temp : Array;
   Array.newByReversingSign(temp, array2);
   array1 := temp;

NEW array1 := -array2;

=> IF array1 # NIL THEN RaiseRuntimeFault(formalNewParamNotNil) END;
   Array.newByReversingSign(array1, array2);

COPY array1 := -array2;

=> Array.neg(array1, array2);


(* Array-Array Operations *)

(* Addition *)

array1 := array2 + array3;

=> VAR temp : Array;
   Array.newWithSums(temp, array2, array3);
   array1 := temp;

NEW array1 := array2 + array3;

=> IF array1 # NIL THEN RaiseRuntimeFault(formalNewParamNotNil) END;
   Array.newWithSums(array1, array2, array3);

COPY array1 := array2 + array3;

=> Array.add(array1, array2, array3);


(* Subtraction *)

array1 := array2 - array3;

=> VAR temp : Array;
   Array.newWithDifferences(temp, array2, array3);
   array1 := temp;

NEW array1 := array2 - array3;

=> IF array1 # NIL THEN RaiseRuntimeFault(formalNewParamNotNil) END;
   Array.newWithDifferences(array1, array2, array3);

COPY array1 := array2 - array3;

=> Array.sub(array1, array2, array3);


(* Multiplication *)

array1 := array2 * array3;

=> VAR temp : Array;
   Array.newWithProducts(temp, array2, array3);
   array1 := temp;

NEW array1 := array2 * array3;

=> IF array1 # NIL THEN RaiseRuntimeFault(formalNewParamNotNil) END;
   Array.newWithProducts(array1, array2, array3);

COPY array1 := array2 * array3;

=> Array.mul(array1, array2, array3);


(* Division *)

array1 := array2 / array3;

=> VAR temp : Array;
   Array.newWithQuotients(temp, array2, array3);
   array1 := temp;

NEW array1 := array2 / array3;

=> IF array1 # NIL THEN RaiseRuntimeFault(formalNewParamNotNil) END;
   Array.newWithQuotients(array1, array2, array3);

COPY array1 := array2 / array3;

=> Array.div(array1, array2, array3);


(* Scalar-Array Operations *)

(* Addition *)

array1 := scalar + array2;

array1 := scalar +: array2;

array1 := array2 :+ scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar + array2[index]
END;


(* Subtraction *)

(* scalar minuend *)

array1 := scalar - array2;

array1 := scalar -: array2;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar - array2[index]
END;

(* scalar subtrahend *)

array1 := array2 - scalar;

array1 := array2 :- scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := array2[index] - scalar
END;


(* Multiplication *)

array1 := scalar * array2;

array1 := scalar *: array2;

array1 := array2 :* scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar * array2[index]
END;


(* Division *)

(* scalar dividend *)

array1 := scalar / array2;

array1 := scalar /: array2;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar / array2[index]
END;

(* scalar divisor *)

array1 := array2 / scalar;

array1 := array2 :/ scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := array2[index] / scalar
END;


(* Semantics *)

(* Sample Implementations *)

(* Array-Array Operations *)

(* Addition *)

(* non-destructive *)

PROCEDURE [+] newWithSums ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    NEW result := right

  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    NEW result := left

  (* otherwise, add operands component-wise *)
  ELSE
    NEW result;
    add(result, left, right)
  END;
  
  RETURN
END newWithSums;

(* destructive *)

PROCEDURE [+] add ( VAR result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    COPY result := right
  
  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    COPY result := left
  
  (* otherwise, add operands component-wise *)
  ELSE
  
    (* determine largest and largest common index *)
    IF COUNT(left) < COUNT(right) THEN
      largerArray := right;
      maxIndex := COUNT(right)-1;
      largestCommonIndex := COUNT(left)-1
    ELSE
      largerArray := left;
      maxIndex := COUNT(left)-1;
      largestCommonIndex := COUNT(right)-1
    END;
    
    (* add items within common index range *)
    FOR index IN [0..largestCommonIndex] OF CARDINAL DO
      result[index] := left[index] + right[index]
    END;
    
    (* copy any remaining items from larger array *)
    IF largestCommonIndex < maxIndex THEN
      FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
        result[index] := largerArray[index]
      END
    END
  END;

  RETURN
END add;


(* Subtraction *)

(* non-destructive *)

PROCEDURE [-] newWithDifferences ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    NEW result := right

  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    NEW result := left

  (* otherwise, subtract second operand from first operand component-wise *)
  ELSE
    NEW result;
    sub(result, left, right)
  END;
  
  RETURN
END newWithDifferences;

(* destructive *)

PROCEDURE [-] sub ( VAR result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    COPY result := right
  
  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    COPY result := left
  
  (* otherwise, subtract second operand from first operand component-wise *)
  ELSE
  
    (* determine largest and largest common index *)
    IF COUNT(left) < COUNT(right) THEN
      largerArray := right;
      maxIndex := COUNT(right)-1;
      largestCommonIndex := COUNT(left)-1
    ELSE
      largerArray := left;
      maxIndex := COUNT(left)-1;
      largestCommonIndex := COUNT(right)-1
    END;
    
    (* subtract items within common index range *)
    FOR index IN [0..largestCommonIndex] OF CARDINAL DO
      result[index] := left[index] - right[index]
    END;
    
    (* copy any remaining items from larger array *)
    IF largestCommonIndex < maxIndex THEN
      FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
        result[index] := largerArray[index]
      END
    END
  END;

  RETURN
END sub;


(* Multiplication *)

(* non-destructive *)

PROCEDURE [*] newWithProducts ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    NEW result := right

  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    NEW result := left

  (* otherwise, multiply operands component-wise *)
  ELSE
    NEW result;
    mul(result, left, right)
  END;
  
  RETURN
END newWithProducts;

(* destructive *)

PROCEDURE [*] mul ( VAR result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    COPY result := right
  
  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    COPY result := left
  
  (* otherwise, multiply operands component-wise *)
  ELSE
  
    (* determine largest and largest common index *)
    IF COUNT(left) < COUNT(right) THEN
      largerArray := right;
      maxIndex := COUNT(right)-1;
      largestCommonIndex := COUNT(left)-1
    ELSE
      largerArray := left;
      maxIndex := COUNT(left)-1;
      largestCommonIndex := COUNT(right)-1
    END;
    
    (* multiply items within common index range *)
    FOR index IN [0..largestCommonIndex] OF CARDINAL DO
      result[index] := left[index] * right[index]
    END;
    
    (* copy any remaining items from larger array *)
    IF largestCommonIndex < maxIndex THEN
      FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
        result[index] := largerArray[index]
      END
    END
  END;

  RETURN
END mul;


(* Division *)

(* non-destructive *)

PROCEDURE [-] newWithQuotients ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    NEW result := right

  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    NEW result := left

  (* otherwise, divide first operand by second operand component-wise *)
  ELSE
    NEW result;
    div(result, left, right)
  END;
  
  RETURN
END newWithQuotients;

(* destructive *)

PROCEDURE [/] div ( VAR result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if left operand is empty, result is right operand *)
  IF COUNT(left) = 0 THEN
    COPY result := right
  
  (* if right operand is empty, result is left operand *)
  ELSIF COUNT(right) = 0 THEN
    COPY result := left
  
  (* otherwise, divide first operand by second operand component-wise *)
  ELSE
  
    (* determine largest and largest common index *)
    IF COUNT(left) < COUNT(right) THEN
      largerArray := right;
      maxIndex := COUNT(right)-1;
      largestCommonIndex := COUNT(left)-1
    ELSE
      largerArray := left;
      maxIndex := COUNT(left)-1;
      largestCommonIndex := COUNT(right)-1
    END;
    
    (* divide items within common index range *)
    FOR index IN [0..largestCommonIndex] OF CARDINAL DO
      result[index] := left[index] / right[index]
    END;
    
    (* copy any remaining items from larger array *)
    IF largestCommonIndex < maxIndex THEN
      FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
        result[index] := largerArray[index]
      END
    END
  END;

  RETURN
END div;


(* END OF FILE *)