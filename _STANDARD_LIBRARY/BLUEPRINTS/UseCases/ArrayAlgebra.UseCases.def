(* M2 R10 Project, (c) 2014 B.Kowarsch & R.Sutcliffe, all rights reserved. *)

(* Array Algebra *)

(* Exploration of possible use cases for array algebra,
   required bindings and resulting compile time transformations. *)

(* Status: Dec 11, 2014 *)


(* =======================
 *    U s e   C a s e s
 * ======================= *)


(* Sign Operations *)

(* Sign Removal *)

array1 := ABS(array2);


(* Sign Reversal *)

array1 := -array2;


(* Array-Array Operations *)

(* Addition *)

array1 := array2 + array3;


(* Subtraction *)

array1 := array2 - array3;


(* Multiplication *)

array1 := array2 * array3;


(* Division *)

array1 := array2 / array3;


(* Scalar-Array Operations *)

(* Addition *)

(* option #1 : overload + operator *)

array1 := scalar + array2;

array1 := array2 + scalar;


(* option #2 : special symbol operator *)

array1 := scalar +: array2;

array1 := array2 :+ scalar;


(* option #3 : extension library function *)

array1 := Array.addScalar(array2, scalar);


(* Subtraction *)

(* option #1 : overload - operator *)

array1 := scalar - array2;

array1 := array2 - scalar;


(* option #2 : special symbol operator *)

array1 := scalar -: array2;

array1 := array2 :- scalar;


(* option #3 : extension library functions *)

array1 := Array.subFromScalar(scalar, array2);

array1 := Array.subScalar(array2, scalar);


(* Multiplication *)

(* option #1 : overload + operator *)

array1 := scalar * array2;

array1 := array2 * scalar;


(* option #2 : special symbol operator *)

array1 := scalar *: array2;

array1 := array2 :* scalar;


(* option #3 : extension library function *)

array1 := Array.mulScalar(array2, scalar);


(* Division *)

(* option #1 : overload / operator *)

array1 := scalar / array2;

array1 := array2 / scalar;


(* option #2 : special symbol operator *)

array1 := scalar /: array2;

array1 := array2 :/ scalar;


(* option #3 : extension library functions *)

array1 := Array.divScalar(scalar, array2);

array1 := Array.divByScalar(array2, scalar);


(* Rotation and Shift Operations *)

(* Left Rotation *)

Array.newByRotatingLeft(array1, array2, n);

Array.rotateLeft(array, n);


(* Right Rotation *)

Array.newByRotatingRight(array1, array2, n);

Array.rotateRight(array, n);


(* Left Shift *)

Array.newByShiftingLeft(array1, array2, n, fillValue);

Array.shiftLeft(array, n, fillValue);


(* Right Shift *)

Array.newByShiftingRight(array1, array2, n, fillValue);

Array.shiftRight(array, n, fillValue);


(* =====================
 *    B i n d i n g s
 * ===================== *)


(* Sign Operations *)

(* Sign Removal *)

PROCEDURE [ABS] abs ( NEW result : Array; operand : Array );


(* Sign Reversal *)

PROCEDURE [NEG] neg ( NEW result : Array; operand : Array );


(* Array-Array Operations *)

(* Addition *)

PROCEDURE [+] newWithSums ( NEW result : Array; left, right : Array );

PROCEDURE [+] add ( VAR result : Array; left, right : Array );


(* Subtraction *)

PROCEDURE [-] newWithDifferences ( NEW result : Array; left, right : Array );

PROCEDURE [-] sub ( VAR result : Array; left, right : Array );


(* Multiplication *)

PROCEDURE [*] newWithProducts ( NEW result : Array; left, right : Array );

PROCEDURE [*] mul ( VAR result : Array; left, right : Array );


(* Division *)

PROCEDURE [/] newWithQuotients ( NEW result : Array; left, right : Array );

PROCEDURE [/] div ( VAR result : Array; left, right : Array );


(* Scalar-Array Operations *)

(* no bindings *)

(* transformations could be synthesised automatically *)


(* ===================================
 *    T r a n s f o r m a t i o n s
 * =================================== *)


(* Sign Operations *)

(* Sign Removal *)

array1 := ABS(array2);

=> Array.abs(array1, array2);


(* Sign Reversal *)

array1 := -array2;

=> Array.neg(array1, array2);


(* Array-Array Operations *)

(* Addition *)

array1 := array2 + array3;

=> Array.add(array1, array2, array3);


(* Subtraction *)

array1 := array2 - array3;

=> Array.sub(array1, array2, array3);


(* Multiplication *)

array1 := array2 * array3;

=> Array.mul(array1, array2, array3);


(* Division *)

array1 := array2 / array3;

=> Array.div(array1, array2, array3);


(* Scalar-Array Operations *)

(* Addition *)

array1 := scalar + array2;

array1 := scalar +: array2;

array1 := array2 :+ scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar + array2[index]
END;


(* Subtraction *)

(* scalar minuend *)

array1 := scalar - array2;

array1 := scalar -: array2;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar - array2[index]
END;

(* scalar subtrahend *)

array1 := array2 - scalar;

array1 := array2 :- scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := array2[index] - scalar
END;


(* Multiplication *)

array1 := scalar * array2;

array1 := scalar *: array2;

array1 := array2 :* scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar * array2[index]
END;


(* Division *)

(* scalar dividend *)

array1 := scalar / array2;

array1 := scalar /: array2;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := scalar / array2[index]
END;

(* scalar divisor *)

array1 := array2 / scalar;

array1 := array2 :/ scalar;

(* synthesised as *)

FOR index IN [0..COUNT(array2)] OF CARDINAL DO
  array1[index] := array2[index] / scalar
END;


(* Semantics *)

(* Sample Implementations *)

(* Array-Array Operations *)

(* Addition *)

PROCEDURE [+] newWithSums ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if any of the operands is empty, return the other as result *)
  IF COUNT(left) = 0 THEN
    NEW result := right;
    RETURN
  ELSIF COUNT(right) = 0 THEN
    NEW result := left;
    RETURN
  ELSE
    NEW result
  END;

  (* determine largest and largest common index *)
  IF COUNT(left) < COUNT(right) THEN
    largerArray := right;
    maxIndex := COUNT(right)-1;
    largestCommonIndex := COUNT(left)-1
  ELSE
    largerArray := left;
    maxIndex := COUNT(left)-1;
    largestCommonIndex := COUNT(right)-1
  END;

  (* component-wise add items within common index range *)
  FOR index IN [0..largestCommonIndex] OF CARDINAL DO
    result[index] := left[index] + right[index]
  END;

  (* copy any remaining items from larger array *)
  IF largestCommonIndex < maxIndex THEN
    FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
      result[index] := largerArray[index]
    END
  END;
  
  (* done *)
  RETURN
END newWithSums;


(* Subtraction *)

PROCEDURE [-] newWithDifferences ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if any of the operands is empty, return the other as result *)
  IF COUNT(left) = 0 THEN
    NEW result := right;
    RETURN
  ELSIF COUNT(right) = 0 THEN
    NEW result := left;
    RETURN
  ELSE
    NEW result
  END;

  (* determine largest and largest common index *)
  IF COUNT(left) < COUNT(right) THEN
    largerArray := right;
    maxIndex := COUNT(right)-1;
    largestCommonIndex := COUNT(left)-1
  ELSE
    largerArray := left;
    maxIndex := COUNT(left)-1;
    largestCommonIndex := COUNT(right)-1
  END;

  (* component-wise add items within common index range *)
  FOR index IN [0..largestCommonIndex] OF CARDINAL DO
    result[index] := left[index] - right[index]
  END;

  (* copy any remaining items from larger array *)
  IF largestCommonIndex < maxIndex THEN
    FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
      result[index] := largerArray[index]
    END
  END;
  
  (* done *)
  RETURN
END newWithDifferences;


(* Multiplication *)

PROCEDURE [+] newWithProducts ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if any of the operands is empty, return the other as result *)
  IF COUNT(left) = 0 THEN
    NEW result := right;
    RETURN
  ELSIF COUNT(right) = 0 THEN
    NEW result := left;
    RETURN
  ELSE
    NEW result
  END;

  (* determine largest and largest common index *)
  IF COUNT(left) < COUNT(right) THEN
    largerArray := right;
    maxIndex := COUNT(right)-1;
    largestCommonIndex := COUNT(left)-1
  ELSE
    largerArray := left;
    maxIndex := COUNT(left)-1;
    largestCommonIndex := COUNT(right)-1
  END;

  (* component-wise multiply items within common index range *)
  FOR index IN [0..largestCommonIndex] OF CARDINAL DO
    result[index] := left[index] * right[index]
  END;

  (* copy any remaining items from larger array *)
  IF largestCommonIndex < maxIndex THEN
    FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
      result[index] := largerArray[index]
    END
  END;
  
  (* done *)
  RETURN
END newWithProducts;


(* Division *)

PROCEDURE [+] newWithQuotients ( NEW result : Array; left, right : Array );
VAR
  largerArray : Array;
  maxIndex, largestCommonIndex : CARDINAL;
BEGIN

  (* if any of the operands is empty, return the other as result *)
  IF COUNT(left) = 0 THEN
    NEW result := right;
    RETURN
  ELSIF COUNT(right) = 0 THEN
    NEW result := left;
    RETURN
  ELSE
    NEW result
  END;

  (* determine largest and largest common index *)
  IF COUNT(left) < COUNT(right) THEN
    largerArray := right;
    maxIndex := COUNT(right)-1;
    largestCommonIndex := COUNT(left)-1
  ELSE
    largerArray := left;
    maxIndex := COUNT(left)-1;
    largestCommonIndex := COUNT(right)-1
  END;

  (* component-wise multiply items within common index range *)
  FOR index IN [0..largestCommonIndex] OF CARDINAL DO
    result[index] := left[index] / right[index]
  END;

  (* copy any remaining items from larger array *)
  IF largestCommonIndex < maxIndex THEN
    FOR index IN [largestCommonIndex+1 .. maxIndex] OF CARDINAL DO
      result[index] := largerArray[index]
    END
  END;
  
  (* done *)
  RETURN
END newWithQuotients;


(* END OF FILE *)