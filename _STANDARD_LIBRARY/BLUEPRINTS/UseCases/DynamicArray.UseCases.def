(* M2 R10 Project, (c) 2014 B.Kowarsch & R.Sutcliffe, all rights reserved. *)

(* Dynamic Array ADTs *)

(* Use cases for conversion of built-in arrays to dynamic array ADTs,
   allocation, copying, slicing, insertion and concatenation of dynamic
   array ADTs, required bindings and resulting compile time transformations. *)

(* Status: Dec 1, 2014 *)


(* =======================
 *    U s e   C a s e s
 * ======================= *)


(* Assignment *)

(* assign NIL *)

array := NIL;
 
(* assign variable *)

array := source;


(* Conversion of Built-in Arrays *)

(* allocate and initialise from built-in array *)

NEW array := builtinArray;

(* destructively update with contents of built-in array *)

COPY target := builtinArray;

(* allocate and initialise from slice of built-in array *)

NEW array := builtinArray[n..m];

(* destructively update with slice of built-in array *)

COPY target := builtinArray[n..m];

(* where *)

VAR builtinArray : <ARRAY any OF ValueType>;


(* Allocation / Non-destructive Copying *)

(* without initialisation *)

NEW array;

(* allocate and initialise with values *)

NEW array := { val1, val2, val3, ... };
 
(* allocate and initialise with copy of variable *)

NEW array := source;
 
(* allocate and initialise with concatenation of variables *)

NEW array := source1 -> source2 -> ... ;
 
(* allocate and initialise with slice *)

NEW array := source[n..m];
 
(* allocate and initialise with concatenation of variables and slices *)

NEW array := source1[n..m] -> source2 -> ... ;


(* Destructive Copying *)

(* copy values *)

COPY target := { val1, val2, val3, ... };
 
(* copy contents of variable *)

COPY target := source;

(* concatenation of variables *)

COPY target := source1 -> source2 -> ... ;

(* copy slice *)

COPY target := source[n..m];
 
(* copy concatenation of variables and slices *)

COPY target := source1[n..m] -> source2 -> ... ;


(* Insertion *)

(* insert values *)

COPY target[n..] := { val1, val2, val3, ... };

(* insert contents of variable *)

COPY target[n..] := source;

(* insert concatenation of variables *)

COPY target[n..] := source1 -> source2 -> ... ;

(* insert slice *)

COPY target[n..] := source[n..m];

(* insert concatenation of variables and slices *)

COPY target[n..] := source1[m..p] -> source2 -> ... ;


(* L-Value Slicing *)

(* copy values into slice *)

COPY target[n..m] := { val1, val2, val3, ... };

(* copy contents of variable into slice *)

COPY target[n..m] := source;

(* copy concatenation of variables into slice *)

COPY target[n..m] := source1 -> source2 -> ... ;

(* copy L-value slice into R-value slice *)

COPY target[n..m] := source[p..q];

(* copy concatenation of R-value slices into L-value slice *)

COPY target[n..m] := source1[p..q] -> source2 -> ... ;


(* Argument Passing *)

(* assign function call result *)

array := function(arrayExpression);

(* allocate and initialise with function call result *)

NEW array := function(arrayExpression);

(* destructively copy function call result *)

COPY target := function(arrayExpression);

(* insert function call result *)

COPY target[n..] := function(arrayExpression);

(* copy function call result into slice *)

COPY target[n..m] := function(arrayExpression);


(* Using a Built-in Array within an Array Expression *)

NEW array := source -> builtinArray -> ... ;

COPY target := source -> builtinArray -> ... ;

COPY target[n..] := source -> builtinArray -> ... ;

COPY target[n..m] := source -> builtinArray -> ... ;

(* where *)

VAR builtinArray : <ARRAY any OF ValueType>;


(* Using a Built-in Array Slice within an Array Expression *)

NEW array := source -> builtinArray[n..m] -> ... ;

COPY target := source -> builtinArray[n..m] -> ... ;

COPY target[n..] := source -> builtinArray[m..p] -> ... ;

COPY target[n..m] := source -> builtinArray[p..q] -> ... ;

(* where *)

VAR builtinArray : <ARRAY any OF ValueType>;


(* =====================
 *    B i n d i n g s
 * ===================== *)


(* Assignment *)

(* no bindings required *)

(* supported use cases *)

array := NIL;

array := source;


(* Conversion of Built-in Arrays *)

(* binding (a) : if slicing is not implemented ... *)

PROCEDURE [ARRAY] convertBuiltinArray
  ( VAR array : ADT; CONST fromArray : ARRAY OF ValueType );
(* If array is NIL upon entry, a newly allocated instance will
   be passed back. Otherwise, it will be destructively updated. *)

(* supported use cases *)

NEW array := builtinArray;

COPY target := builtinArray;


(* binding (b) : if slicing is implemented ... *)

PROCEDURE [ARRAY] convertBuiltinArrayOrSlice
  ( VAR array : ADT;
    CONST fromArray : ARRAY OF ValueType; start, end : INTEGER );
(* If array is NIL upon entry, a newly allocated instance will
   be passed back. Otherwise, it will be destructively updated. *)

(* supported use cases *)

NEW array := builtinArray;

NEW array := builtinArray[n..m];

COPY target := builtinArray;

COPY target := builtinArray[n..m];


(* Allocation *)

(* binding #1 *)

PROCEDURE [NEW] new ( VAR array : ADT; values : ARGLIST OF ValueType );

(* supported use cases *)

NEW array;

NEW array := { val1, val2, val3, ... };


(* binding #2 (a) : if neither slicing nor concatenation is implemented ... *)

PROCEDURE [NEW*] newFromArray ( VAR new : ADT; source : ADT );

(* supported use case *)

NEW array := source;


(* binding #2 (b) : if slicing is implemented ... *)

PROCEDURE [NEW*] newFromArrayOrSlice
  ( VAR array : ADT; source : ADT; start, end : INTEGER );

(* supported use cases *)

NEW array := source;

NEW array := source[n..m];


(* binding #2 (c) : if concatenation is implemented ... *)

PROCEDURE [NEW*] newFromArrays ( VAR new : ADT; source : ARGLIST OF ADT );

(* supported use cases *)

NEW array := source;

NEW array := source1 -> source2 -> ... ;


(* binding #2 (d) : if both slicing and concatenation are implemented ... *)

PROCEDURE [NEW*] newFromArraysOrSlices
  ( VAR new : ADT; source : ARGLIST OF { array : ADT; start, end : INTEGER} );

(* supported use cases *)

NEW array := source;

NEW array := source[n..m];

NEW array := source1 -> source2 -> ... ;

NEW array := source[n..m] -> source2 ... ;


(* Copying *)

(* binding #1 *)

PROCEDURE [COPY] copyValues ( VAR tgt : ADT; values : ARGLIST OF ValueType );

(* supported use case *)

COPY target := { val1, val2, val3, ... };


(* binding #2 (a) : if neither slicing nor concatenation is implemented ... *)

PROCEDURE [COPY*] copyArray ( VAR tgt : ADT; source : ADT );

(* supported use case *)

COPY target := source;


(* binding #2 (b) : if slicing is implemented ... *)

PROCEDURE [COPY*] copyArrayOrSlice
  ( VAR tgt : ADT; source : ADT; start, end : INTEGER );

(* supported use cases *)

COPY target := source;

COPY target := source[n..m];


(* binding #2 (c) : if concatenation is implemented ... *)

PROCEDURE [COPY*] copyArrays ( VAR tgt : ADT; source : ARGLIST OF ADT );

(* supported use cases *)

COPY target := source;

COPY target := source1 -> source2 -> ... ;


(* binding #2 (d) : if both slicing and concatenation are implemented ... *)

PROCEDURE [COPY*] copyArraysOrSlices
  ( VAR tgt : ADT; source : ARGLIST OF { array : ADT; start, end : INTEGER } );

(* supported use cases *)

COPY target := source;

COPY target := source[n..m];

COPY target := source1 -> source2 -> ... ;

COPY target := source1[n..m] -> source2 -> ... ;


(* Insertion *)

(* binding #1 *)

PROCEDURE [INSERT] insertValues
  ( VAR target : ADT; atIndex : INTEGER; source : ARGLIST OF ValueType );

(* supported use case *)

COPY target[n..] := { val1, val2, val3, ... };


(* binding #2 (a) : if neither slicing nor concatenation is implemented ... *)

PROCEDURE [INSERT*] insertArray
  ( VAR target : ADT; atIndex : INTEGER; source : ADT );

(* supported use case *)

COPY target[n..] := source;


(* binding #2 (b) : if slicing is implemented ... *)

PROCEDURE [INSERT*] insertArrayOrSlice
  ( VAR target : ADT; atIndex : INTEGER;
    source : ADT; srcStart, srcEnd : INTEGER );

(* supported use cases *)

COPY target[n..] := source;

COPY target[n..] := source[m..p];


(* binding #2 (c) : if concatenation is implemented ... *)

PROCEDURE [INSERT*] insertArrays
  ( VAR target : ADT; atIndex : INTEGER; source : ARGLIST OF ADT );

(* supported use cases *)

COPY target[n..] := source;

COPY target[n..] := source1 -> source2 -> ... ;


(* binding #2 (d) : if both slicing and concatenation are implemented ... *)

PROCEDURE [INSERT*] insertArraysOrSlices
  ( VAR target : ADT; atIndex : INTEGER;
    source : ARGLIST OF { array : ADT; srcStart, srcEnd : INTEGER } );

(* supported use cases *)

COPY target[n..] := source;

COPY target[n..] := source[m..p];

COPY target[n..] := source1 -> source2 -> ... ;

COPY target[n..] := source[m..p] -> source2 -> ... ;


(* L-Value Slicing *)

(* binding #1 *)

PROCEDURE [..] updateSliceWithValues
  ( VAR tgt : ADT; tgtStart, tgtEnd : INTEGER;
    values : ARGLIST OF ValueType );

(* supported use case *)

COPY target[n..m] := { val1, val2, val3, ... };


(* binding #2 (a) : if concatenation is not implemented ... *)

PROCEDURE [..*] updateSliceWithArrayOrSlice
  ( VAR tgt : ADT; tgtStart, tgtEnd : INTEGER;
    source : ADT; srcStart, srcEnd : INTEGER );

(* supported use cases *)

COPY target[n..m] := source;

COPY target[n..m] := source[p..q];


(* binding #2 (b) : if concatenation is implemented ... *)

PROCEDURE [..*] updateSliceWithArraysOrSlices
  ( VAR tgt : ADT; tgtStart, tgtEnd : INTEGER;
    source : ARGLIST OF { array : ADT; srcStart, srcEnd : INTEGER } );

(* supported use cases *)

COPY target[n..m] := source;

COPY target[n..m] := source[p..q];

COPY target[n..m] := source1 -> source2 -> ... ;

COPY target[n..m] := source[p..q] -> source2 -> ... ;


(* Argument Passing *)

(* required binding *)

PROCEDURE [RETAIN] retain ( VAR array : ADT );

(* supported use cases *)

target := function(anyArrayExpression);

NEW target := function(anyArrayExpression);

COPY target := function(anyArrayExpression);


(* Using a Built-in Array within an Array Expression *)

(* required binding *)

PROCEDURE [RETAIN] retain ( VAR array : ADT );

(* supported use cases *)

NEW array := source -> builtinArray -> ... ;

COPY target := source -> builtinArray -> ... ;

COPY target[n..] := source -> builtinArray -> ... ;

COPY target[n..m] := source -> builtinArray -> ... ;


(* Using a Built-in Array Slice within an Array Expression *)

(* required binding *)

PROCEDURE [RETAIN] retain ( VAR array : ADT );

(* supported use cases *)

NEW array := source -> builtinArray[n..m] -> ... ;

COPY target := source -> builtinArray[n..m] -> ... ;

COPY target[n..] := source -> builtinArray[m..p] -> ... ;

COPY target[n..m] := source -> builtinArray[p..q] -> ... ;


(* ===================================
 *    T r a n s f o r m a t i o n s
 * =================================== *)


(* Assignment *)

(* assign NIL *)

array := NIL;

=> array := NIL;
 

(* assign variable *)

array := source;

=> array := source;


(* Conversion of Built-in Arrays *)

(* allocate and initialise from built-in array *)

NEW array := builtinArray;

(* if slicing is not implemented ... *)

=> IF array # NIL THEN RaiseRuntimeFault(allocTargetNotNil) END;
   ADT.convertBuiltinArray(array, builtinArray);

(* if slicing is implemented ... *)

=> IF array # NIL THEN RaiseRuntimeFault(allocTargetNotNil) END;
   ADT.convertBuiltinArrayOrSlice(array, builtinArray, 0, -1);


(* destructively update with contents of built-in array *)

COPY target := builtinArray;

(* if slicing is not implemented ... *)

=> IF target = NIL THEN RaiseRuntimeFault(attemptToDerefNIL) END;
   ADT.convertBuiltinArray(array, builtinArray);

(* if slicing is implemented ... *)

=> IF target = NIL THEN RaiseRuntimeFault(attemptToDerefNIL) END;
   ADT.convertBuiltinArrayOrSlice(array, builtinArray, 0, -1);


(* allocate and initialise from slice of built-in array *)

NEW array := builtinArray[n..m];

=> IF array # NIL THEN RaiseRuntimeFault(allocTargetNotNil) END;
   ADT.convertBuiltinArrayOrSlice(array, builtinArray, n, m);


(* destructively update with slice of built-in array *)

COPY target := builtinArray[n..m];

=> IF target = NIL THEN RaiseRuntimeFault(attemptToDerefNIL) END;
   ADT.convertBuiltinArrayOrSlice(array, builtinArray, n, m);


(* Allocation / Non-destructive Copying *)

(* without initialisation *)

NEW array;

=> ADT.new(array);


(* allocate and initialise with values *)

NEW array := { val1, val2, val3, ... };
 
=> ADT.new(array, val1, val2, val3, ...);


(* allocate and initialise with copy of variable *)

NEW array := source;

(* if neither slicing nor concatenation is implemented *)

=> ADT.newFromArray(array, source);

(* if slicing is implemented ... *)

=> ADT.newFromArrayOrSlice(array, source, 0, -1);

(* if concatenation is implemented ... *)

=> ADT.newFromArrays(array, source);

(* if both slicing and concatenation are implemented ... *)

=> ADT.newFromArraysOrSlices(array, source, 0, -1);


(* allocate and initialise with concatenation of variables *)

NEW array := source1 -> source2 -> ... ;

(* if slicing is not implemented ... *)

=> ADT.newFromArrays(array, source1, source2, ...);

(* if slicing is implemented ... *)

=> ADT.newFromArraysOrSlices(array, source1, 0, -1, source2, 0, -1, ...);

 
(* allocate and initialise with slice *)

NEW array := source[n..m];

(* if concatenation is not implemented ... *)

=> ADT.newFromArrayOrSlice(array, source, n, m);

(* if concatenation is implemented ... *)

=> ADT.newFromArraysOrSlices(array, source1, n, m);


(* allocate and initialise with concatenation of variables and slices *)

NEW array := source1[n..m] -> source2 -> ... ;

=> ADT.newFromArraysOrSlices(array, source1, n, m, source2, 0, -1, ...);


(* Destructive Copying *)

(* copy values *)

COPY target := { val1, val2, val3, ... };

=> ADT.copyValues(target, val1, val2, val3, ...);

 
(* copy contents of variable *)

COPY target := source;

(* if neither slicing nor concatenation is implemented *)

=> ADT.copyArray(target, source);

(* if slicing is implemented ... *)

=> ADT.copyArrayOrSlice(target, source, 0, -1);

(* if concatenation is implemented ... *)

=> ADT.copyArrays(target, source);

(* if both slicing and concatenation are implemented ... *)

=> ADT.copyArraysOrSlices(target, source, 0, -1);


(* copy concatenation of variables *)

COPY target := source1 -> source2 -> ... ;

(* if slicing is not implemented ... *)

=> ADT.copyArrays(target, source1, source2, ...);

(* if slicing is implemented ... *)

=> ADT.copyArraysOrSlices(target, source1, 0, -1, source2, 0, -1, ...);


(* copy slice *)

COPY target := source[n..m];

(* if concatenation is not implemented ... *)

=> ADT.copyArrayOrSlice(target, source, n, m);

(* if concatenation is implemented ... *)

=> ADT.copyArraysOrSlices(target, source1, n, m);

 
(* copy concatenation of variables and slices *)

COPY target := source1[n..m] -> source2 -> ... ;

=> ADT.copyArraysOrSlices(target, source1, n, m, source2, 0, -1, ...);


(* Insertion *)

(* insert values *)

COPY target[n..] := { val1, val2, val3, ... };

=> ADT.insertValues(target, n, val1, val2, val3, ...);


(* insert contents of variable *)

COPY target[n..] := source;

(* if neither slicing nor concatenation is implemented *)

=> ADT.insertArray(target, n, source);

(* if slicing is implemented ... *)

=> ADT.insertArrayOrSlice(target, n, source, 0, -1);

(* if concatenation is implemented ... *)

=> ADT.insertArrays(target, n, source);

(* if both slicing and concatenation are implemented ... *)

=> ADT.insertArraysOrSlices(target, n, source, 0, -1);


(* insert concatenation of variables *)

COPY target[n..] := source1 -> source2 -> ... ;

(* if slicing is not implemented ... *)

=> ADT.insertArrays(target, n, source1, source2, ...);

(* if slicing is implemented ... *)

=> ADT.insertArraysOrSlices(target, n, source1, 0, -1, source2, 0, -1, ...);


(* insert slice *)

COPY target[n..] := source[m..p];

(* if concatenation is not implemented ... *)

=> ADT.insertArrayOrSlice(target, n, source, m, p);

(* if concatenation is implemented ... *)

=> ADT.insertArraysOrSlices(target, n, source1, m, p);


(* insert concatenation of variables and slices *)

COPY target[n..] := source1[m..p] -> source2 -> ... ;

=> ADT.insertArraysOrSlices(target, n, source1, m, p, source2, 0, -1, ...);


(* L-Value Slicing *)

(* copy values into slice *)

COPY target[n..m] := { val1, val2, val3, ... };

=> ADT.updateSliceWithValues(target, n, m, val1, val2, val3, ...);


(* copy contents of variable into slice *)

COPY target[n..m] := source;

(* if neither slicing nor concatenation is implemented *)

=> ADT.updateSliceWithArray(target, n, m, source);

(* if slicing is implemented ... *)

=> ADT.updateSliceWithArrayOrSlice(target, n, m, source, 0, -1);

(* if concatenation is implemented ... *)

=> ADT.updateSliceWithArrays(target, n, m, source);

(* if both slicing and concatenation are implemented ... *)

=> ADT.updateSliceWithArraysOrSlices(target, n, m, source, 0, -1);


(* copy concatenation of variables into slice *)

COPY target[n..m] := source1 -> source2 -> ... ;

(* if slicing is not implemented ... *)

=> ADT.updateSliceWithArrays(
    (* L-value *) target, n, m,
    (* R-value *) source1, source2, ...);

(* if slicing is implemented ... *)

=> ADT.updateSliceWithArraysOrSlices(
    (* L-value *) target, n, m,
    (* R-value *) source1, 0, -1, source2, 0, -1, ...);


(* copy L-value slice into R-value slice *)

COPY target[n..m] := source[p..q];

(* if concatenation is not implemented ... *)

=> ADT.updateSliceWithArrayOrSlice(
    (* L-value *) target, n, m,
    (* R-value *) source, p, q);

(* if concatenation is implemented ... *)

=> ADT.updateSliceWithArraysOrSlices(
    (* L-value *) target, n, m,
    (* R-value *) source, p, q);


(* copy concatenation of R-value slices into L-value slice *)

COPY target[n..m] := source1[p..q] -> source2 -> ... ;

=> ADT.updateSliceWithArraysOrSlices(
    (* L-value *) target, n, m,
    (* R-value *) source1, p, q, source2, 0, -1, ...);


(* Argument Passing *)

(* assign function call result *)

array := function(arrayExpression);

=> VAR temp : ADT;
   temp := arrayExpression;
   array := function(temp); ADT.release(temp);


(* allocate and initialise with function call result *)

NEW array := function(arrayExpression);

=> VAR temp : ADT;
   temp := arrayExpression;
   ADT.newFromArray(array, function(temp)); ADT.release(temp);


(* destructively copy function call result *)

COPY target := function(arrayExpression);

=> VAR tempArg, tempResult : ADT;
   tempArg := arrayExpression;
   tempResult := function(tempArg); ADT.release(tempArg);
   ADT.copyArray(target, tempResult); ADT.release(tempResult);


(* insert function call result *)

COPY target[n..] := function(arrayExpression);

=> VAR tempArg, tempResult : ADT;
   tempArg := arrayExpression;
   tempResult := function(tempArg); ADT.release(tempArg);
   ADT.insertArray(target, n, tempResult); ADT.release(tempResult);


(* copy function call result into slice *)

COPY target[n..m] := function(arrayExpression);

=> VAR tempArg, tempResult : ADT;
   tempArg := arrayExpression;
   tempResult := function(tempArg); ADT.release(tempArg);
   ADT.updateSliceWithArray(target, n, m, tempResult); ADT.release(tempResult);


(* Using a Built-in Array within an Array Expression *)

NEW array := source -> builtinArray -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray; (* see conversion *)
   NEW array := source -> temp -> ... ; RELEASE temp;

COPY target := source -> builtinArray -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray; (* see conversion *)
   COPY target := source -> temp -> ... ; RELEASE temp;

COPY target[n..] := source -> builtinArray -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray; (* see conversion *)
   COPY target[n..] := source -> temp -> ... ; RELEASE temp;

COPY target[n..m] := source -> builtinArray -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray; (* see conversion *)
   COPY target[n..m] := source -> temp -> ... ; RELEASE temp;


(* Using a Built-in Array Slice within an Array Expression *)

NEW array := source -> builtinArray[n..m] -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray[n..m]; (* see conversion *)
   NEW array := source -> temp -> ... ; RELEASE temp;

COPY target := source -> builtinArray[n..m] -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray[n..m]; (* see conversion *)
   COPY target := source -> temp -> ... ; RELEASE temp;

COPY target[n..] := source -> builtinArray[m..p] -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray[m..p]; (* see conversion *)
   COPY target[n..] := source -> temp -> ... ; RELEASE temp;

COPY target[n..m] := source -> builtinArray[p..q] -> ... ;

=> VAR temp : ADT;
   NEW temp := builtinArray[p..q]; (* see conversion *)
   COPY target[n..m] := source -> temp -> ... ; RELEASE temp;

(* END OF FILE *)