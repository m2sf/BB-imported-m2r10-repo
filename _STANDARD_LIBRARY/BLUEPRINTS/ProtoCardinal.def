(* (C) 2012-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Cardinal Number ADTs *)

BLUEPRINT ProtoCardinal [ProtoScalar]; (* conforms to ProtoScalar *)


(* Required Module Type *)

MODULE TYPE = RECORD := INTEGER;
(* Cardinal ADTs must be records to be statically allocatable,
   integer literals are compatible. *)


(* Required Constants *)


CONST [TSIGNED] isSigned = FALSE;
(* Cardinal ADTs are always unsigned *)

CONST [TBASE] base : CARDINAL;
(* Radix in which cardinal values are encoded, 2 or 10 *)

CONST [TPRECISION] precision : [1..4000] OF CARDINAL;
(* Maximum number of digits the ADT can encode *)

CONST [TMINEXP] eMin = 0;
(* Cardinal ADTs always have an exponent of zero *)

CONST [TMAXEXP] eMax = 0;
(* Cardinal ADTs always have an exponent of zero *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TMIN *)

PROCEDURE [TMIN] minValue : ProtoCardinal;
(* Required function to return the minimal value of a cardinal number. *)

(* An expression of the form TMIN(CardinalADT)
   is synthesised as CardinalADT.minValue(). *)


(* Binding to Predefined Function TMAX *)

PROCEDURE [TMAX] maxValue : ProtoCardinal;
(* Required function to return the maximal value of a cardinal number. *)

(* An expression of the form TMAX(CardinalADT)
   is synthesised as CardinalADT.maxValue(). *)


(* Numeric Conversion *)

(* Binding to scalar conversion primitives SXF and VAL *)

PROCEDURE [SXF] toSXF ( value : ProtoCardinal; VAR sxf : ARRAY OF OCTET );
(* Required procedure to convert a cardinal value to scalar exchange format. *)

PROCEDURE [VAL] fromSXF ( sxf : ARRAY OF OCTET; VAR value : ProtoCardinal );
(* Required procedure to convert from scalar exchange format to the ADT. *)

(* Conversion between any two scalar ADTs can be synthesised utilising the
   ADTs' conversion procedures bound to SXF and VAL.
   
   A conversion expression of the form
     intValue :: CardinalADT
   is synthesised as
     IntegerADT.toSXF(intValue, temp);
     CardinalADT.fromSXF(temp, result);
   when no direct conversion is implemented. *)


(* Literal Assignment *)

(* Numeric literals are converted to scalar exchange format at compile time.
   Assignments of numeric literals to numeric ADTs are then synthesised
   utilising an ADT's conversion procedure bound to VAL.
   
   An assignment of the form
     n := 123;
   is synthesised as
     CardinalADT.fromSXF(sxfCompiletimeValue, n); *)


(* Arithmetic Operations *)

(* Binding to Predefined Function ABS *)

PROCEDURE [ABS] abs ( n : ProtoCardinal ) : ProtoCardinal;
(* Required function to return the absolute value of a cardinal. *)

(* An expression of the form ABS(n)
   is synthesised as CardinalADT.abs(n). *)


(* Binding to Predefined Function ODD *)

PROCEDURE [ODD] odd ( n : ProtoCardinal ) : BOOLEAN;
(* Required function to test whether a cardinal is even or odd. *)

(* An expression of the form ODD(n)
   is synthesised as CardinalADT.odd(n). *)


(* Binding to the + Operator *)

PROCEDURE [+] add ( n, m : ProtoCardinal ) : ProtoCardinal;
(* Required function to return the result of n + m. *)

(* An expression of the form n + m
   is synthesised as CardinalADT.add(n, m).
   
   A statement of the form n++
   is synthesised as CardinalADT.add(n, 1). *)


(* Binding to the - Operator *)

PROCEDURE [-] subtract ( n, m : ProtoCardinal ) : ProtoCardinal;
(* Required function to return the result of n - m. *)

(* An expression of the form n - m
   is synthesised as CardinalADT.subtract(n, m).
   
   A statement of the form n--
   is synthesised as CardinalADT.subtract(n, 1). *)


(* Binding to the * Operator *)

PROCEDURE [*] multiply ( n, m : ProtoCardinal ) : ProtoCardinal;
(* Required function to return the result of n * m. *)

(* An expression of the form n * m
   is synthesised as CardinalADT.multiply(n, m). *)


(* Binding to the DIV Operator *)

PROCEDURE [DIV] divide ( n, m : ProtoCardinal ) : ProtoCardinal;
(* Required function to return the result of n DIV m. *)

(* An expression of the form n DIV m
   is synthesised as CardinalADT.divide(n, m). *)


(* Binding to the MOD Operator *)

PROCEDURE [MOD] modulus ( n, m : ProtoCardinal ) : ProtoCardinal;
(* Required function to return the result of n MOD m. *)

(* An expression of the form n MOD m
   is synthesised as CardinalADT.modulus(n, m). *)


(* Relational Operations *)

(* Binding to Operators = and # *)

PROCEDURE [=] isEqual ( n, m : ProtoCardinal ) : BOOLEAN;
(* Required function to test the equivalence of two cardinals. *)

(* An expression of the form n = m
   is synthesised as CardinalADT.isEqual(n, m).
   
   An expression of the form n # m
   is synthesised as (NOT CardinalADT.isEqual(n, m)). *)


(* Binding to Operators < and >= *)

PROCEDURE [<] isLess ( n, m : ProtoCardinal ) : BOOLEAN;
(* Required function to test if one cardinal is less than another. *)

(* An expression of the form n < m
   is synthesised as CardinalADT.isLess(n, m).
   
   An expression of the form n >= m
   is synthesised as (NOT CardinalADT.isLess(n, m)). *)


(* Binding to Operators > and <= *)

PROCEDURE [>] isGreater ( n, m : ProtoCardinal ) : BOOLEAN;
(* Required function to test if one cardinal is greater than another. *)

(* An expression of the form n > m
   is synthesised as CardinalADT.isGreater(n, m).
   
   An expression of the form n <= m
   is synthesised as (NOT CardinalADT.isGreater(n, m)). *)


END ProtoCardinal.