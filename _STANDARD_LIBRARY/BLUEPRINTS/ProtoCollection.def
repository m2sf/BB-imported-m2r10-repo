(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* General Blueprint for Dynamically Allocatable Collection ADTs *)

BLUEPRINT ProtoCollection [ProtoRoot];

REFERENTIAL AccessorType, ValueType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE :=
  CHAR | UNICHAR |
  { ARGLIST OF AccessorType } |
  { ARGLIST OF { AccessorType, ValueType } };
(* Dynamic Collection ADTs must be opaque,
   quoted literals or structured literals are compatible. *)


(* Required Constants *)

(* NIL Storage *)

CONST [NIL] allowsNilStorage : BOOLEAN;
(* Required constant to define whether NIL should be a storable value.
   Its value may be TRUE or FALSE. *)


(* Orderedness *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* Required constant to define whether conforming ADTs should be ordered.
   Its value may be TRUE or FALSE. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether conforming ADTs should be reference
   counted. Its value may be TRUE or FALSE. *)


(* Support for Invalid Accessor Retrieval Intercept *)

CONST * invAccessorRetrievalIntercept : BOOLEAN;
(* Required constant to define whether invalid accessor retrieval errors may
   be intercepted by user defined handlers. Its value may be TRUE or FALSE. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT];
(* Specialised blueprints must always require binding to TLIMIT. *)


(* Binding to Predefined Function COUNT or LENGTH *)

(* When TLIMIT is required, either COUNT or LENGTH is required.
   Specialised blueprints must require one of the two accordingly. *)


(* Memory Management *)

PROCEDURE [NEW];
(* Specialised blueprints must always require binding to NEW. *)

PROCEDURE [NEWCOPY];
(* Specialised blueprints must always require binding to NEWCOPY. *)

isRefCounted -> PROCEDURE [RETAIN];
(* Specialised blueprints must require binding to RETAIN when the
   ADT is reference counted. *)

PROCEDURE [RELEASE];
(* Specialised blueprints must always require binding to RELEASE. *)


(* Literal Assignment *)

(* Binding to the := Operator *)

PROCEDURE [:=];
(* Specialised blueprints must always require binding to the := operator. *)


(* Copying *)

(* Binding to Predefined Procedure COPY *)

PROCEDURE [COPY];
(* Specialised blueprints must always require binding to COPY. *)


(* Value Storage *)

(* Binding to Predefined Procedure STORE *)

PROCEDURE [STORE];
(* Specialised blueprints must always require binding to STORE. *)


(* Value Retrieval *)

(* Binding to Predefined Function RETRIEVE *)

PROCEDURE [RETRIEVE];
(* Specialised blueprints must always require binding to RETRIEVE. *)


(* Invalid Accessor Retrieval Error Handling *)

(* A user defined invalid-accessor handler function may be used to change
   the default behaviour when RETRIEVE is called with an invalid accessor. *)

(* Handler Type *)

invAccessorRetrievalIntercept ->
TYPE HandlerType = PROCEDURE ( VAR ValueType ) : BOOLEAN;
(* Specialised blueprints must require procedure type for user defined
   invalid-accessor handlers when invAccessorRetrievalIntercept is TRUE. *)


(* Handler Installation *)

invAccessorRetrievalIntercept ->
PROCEDURE installHandler ( handler : HandlerType );
(* Specialised blueprints must require procedure to install user defined
   invalid-accessor handlers when invAccessorRetrievalIntercept is TRUE. *)


(* Value Insertion *)

(* Binding to Predefined Procedure INSERT *)

PROCEDURE [INSERT];
(* Specialised blueprints must always require binding to INSERT. *)


(* Value Removal *)

(* Binding to Predefined Procedure REMOVE *)

PROCEDURE [REMOVE];
(* Specialised blueprints must always require binding to REMOVE. *)


(* Membership Test *)

(* Binding to IN syntax *)

(* The operation IN is not common to all collection ADTs,
   its binding may be required by more specialised blueprints. *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoCollection, CONST AccessorType );
(* Specialised blueprints must require procedure type for synthesised
   FOR loop bodies. *)

PROCEDURE [FOR];
(* Specialised blueprints must always require binding to FOR. *)


(* Concatenation *)

(* Binding to Predefined Procedure CONCAT *)

(* The operation CONCAT is not common to all collection ADTs,
   its binding may be required by more specialised blueprints. *)


(* Slicing *)

(* Binding to the .. Operator *)

(* The operation .. is not common to all collection ADTs,
   its binding may be required by more specialised blueprints. *)


(* Relational Operations *)

(* Binding to the = and # Operators *)

PROCEDURE [=];
(* Specialised blueprints must always require binding to = operator. *)

(* The operation for the # operator is automatically synthesised. *)


(* Binding to < and > Operators *)

(* The operations less-than, less-or-equal, greater-than and
   greater-than-equal are not common to all collection ADTs,
   their binding may be required by specialised blueprints. *)


(* Set Operations *)

(* Binding to Predefined Function SUBSET *)

(* The operation SUBSET is not common to all collection ADTs,
   its binding may be required by specialised blueprints. *)


(* Conditionally Inhibited Bindings *)

(* Conforming blueprints may not require bindings to RETAIN and CONCAT,
   nor to any set operations if the ADT is not reference counted. *)

NOT isRefCounted -> PROCEDURE [RETAIN] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [CONCAT] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [+] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [-] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [*] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [/] : NIL; (* inhibited *)


(* Unconditionally Inhibited Bindings *)

(* Numeric Properties *)

(* Numeric properties are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these properties. *)

CONST [TSIGNED] : NIL; (* inhibited *)

CONST [TBASE] : NIL; (* inhibited *)

CONST [TPRECISION] : NIL; (* inhibited *)

CONST [TMINEXP] : NIL; (* inhibited *)

CONST [TMAXEXP] : NIL; (* inhibited *)


(* Introspection *)

(* Operations TMIN and TMAX are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [TMIN] : NIL; (* inhibited *)

PROCEDURE [TMAX] : NIL; (* inhibited *)


(* Arithmetic Operations *)

(* Operations ABS, NEG, DIV and MOD are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [ABS] : NIL; (* inhibited *)

PROCEDURE [NEG] : NIL; (* inhibited *)

PROCEDURE [DIV] : NIL; (* inhibited *)

PROCEDURE [MOD] : NIL; (* inhibited *)


(* Arithmetic Conversion *)

(* Arithmetic conversions are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [SXF] : NIL; (* inhibited *)

PROCEDURE [VAL] : NIL; (* inhibited *)


END ProtoCollection.