(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* General Blueprint for Collection ADTs *)

BLUEPRINT ProtoCollection [ProtoRoot];

REFERENTIAL AccessorType, ValueType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = * :=
  CHAR | UNICHAR |
  { ARGLIST OF AccessorType } |
  { ARGLIST OF { AccessorType, ValueType } };
(* Collection ADTs may be opaque pointers or record types,
   quoted literals or structured literals are compatible. *)


(* Bindings required for collection ADTs *)


(* Required Constants *)


(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT is mutable.
   Its value may be TRUE or FALSE. *)


(* Orderedness *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* Required constant to define whether conforming ADTs shall be ordered.
   Its value may be TRUE or FALSE. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether conforming ADTs shall be reference
   counted. Its value may be TRUE or FALSE. *)


(* NIL Storage *)

CONST [NIL] allowsNilStorage : BOOLEAN;
(* Required constant to define whether NIL is a storable value.
   Its value may be TRUE or FALSE. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT];
(* Specialised blueprints must always require binding to TLIMIT. *)


(* Binding to Predefined Function COUNT or LENGTH *)

(* When TLIMIT is required, either COUNT or LENGTH is required.
   Specialised blueprints must require one of the two accordingly. *)


(* Memory Management *)

(* The operations NEW, RETAIN and RELEASE are not common to all collection
   ADTs, their bindings may be required by more specialised blueprints. *)


(* Literal Assignment *)

(* Binding to the := Operator *)

isMutable -> PROCEDURE [:=];
(* Specialised blueprints must require binding to := when mutable. *)


(* Copying *)

(* Binding to Predefined Function DUP *)

PROCEDURE [DUP];
(* Specialised blueprints must always require binding to DUP. *)


(* Binding to Predefined Procedure COPY *)

isMutable -> PROCEDURE [COPY];
(* Specialised blueprints must require binding to COPY when mutable. *)


(* Value Storage *)

(* Binding to Predefined Procedure STORE *)

isMutable -> PROCEDURE [STORE];
(* Specialised blueprints must require binding to STORE when mutable. *)


(* Value Retrieval *)

(* Binding to Predefined Function RETRIEVE *)

PROCEDURE [RETRIEVE];
(* Specialised blueprints must always require binding to RETRIEVE. *)


(* Invalid Accessor Retrieval Error Handling *)

(* A user defined invalid-accessor handler function may be used to change
   the default behaviour when RETRIEVE is called with an invalid accessor. *)

(* Handler Type *)

TYPE HandlerType = PROCEDURE ( VAR ValueType ) : BOOLEAN;
(* Specialised blueprints must require procedure type for user defined
   invalid-accessor handlers. *)


(* Handler Installation *)

PROCEDURE installHandler ( handler : HandlerType );
(* Specialised blueprints must require procedure to install user defined
   invalid-accessor handlers. *)


(* Value Insertion and Removal *)

(* Binding to Predefined Procedures INSERT and REMOVE *)

(* The operations INSERT and REMOVE are not common to all collection
   ADTs, their bindings may be required by more specialised blueprints. *)


(* Accessor or Value Test *)

(* Binding to IN syntax *)

(* The operation IN is not common to all collection ADTs,
   its binding may be required by more specialised blueprints. *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoCollection, CONST AccessorType );
(* Specialised blueprints must require procedure type for synthesised
   FOR loop bodies. *)

PROCEDURE [FOR];
(* Specialised blueprints must always require binding to FOR. *)


(* Relational Operations *)

(* Binding to the = and # Operators *)

PROCEDURE [=];
(* Specialised blueprints must always require binding to = operator. *)

(* The operation for the # operator is automatically synthesised. *)


(* Conditionally Inhibited Bindings *)

(* Conforming blueprints may not require bindings to any of
   :=, COPY, STORE, INSERT and REMOVE if the ADT is immutable. *)

NOT isMutable -> PROCEDURE [:=] : NIL; (* inhibited *)

NOT isMutable -> PROCEDURE [COPY] : NIL; (* inhibited *)

NOT isMutable -> PROCEDURE [STORE] : NIL; (* inhibited *)

NOT isMutable -> PROCEDURE [INSERT] : NIL; (* inhibited *)

NOT isMutable -> PROCEDURE [REMOVE] : NIL; (* inhibited *)


(* Conforming blueprints may not require bindings to RETAIN and CONCAT,
   nor to any set operations if the ADT is not reference counted. *)

NOT isRefCounted -> PROCEDURE [RETAIN] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [CONCAT] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [+] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [-] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [*] : NIL; (* inhibited *)

NOT isRefCounted  -> PROCEDURE [/] : NIL; (* inhibited *)


(* Unconditionally Inhibited Bindings *)

(* Numeric Properties *)

(* Numeric properties are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these properties. *)

CONST [TSIGNED] : NIL; (* inhibited *)

CONST [TBASE] : NIL; (* inhibited *)

CONST [TPRECISION] : NIL; (* inhibited *)

CONST [TMINEXP] : NIL; (* inhibited *)

CONST [TMAXEXP] : NIL; (* inhibited *)


(* Introspection *)

(* Operations TMIN and TMAX are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [TMIN] : NIL; (* inhibited *)

PROCEDURE [TMAX] : NIL; (* inhibited *)


(* Arithmetic Operations *)

(* Operations ABS, NEG, DIV and MOD are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [ABS] : NIL; (* inhibited *)

PROCEDURE [NEG] : NIL; (* inhibited *)

PROCEDURE [DIV] : NIL; (* inhibited *)

PROCEDURE [MOD] : NIL; (* inhibited *)


(* Arithmetic Conversion *)

(* Arithmetic conversions are not meaningful for collection ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [SXF] : NIL; (* inhibited *)

PROCEDURE [VAL] : NIL; (* inhibited *)


END ProtoCollection.