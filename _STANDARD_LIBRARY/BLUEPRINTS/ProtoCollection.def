(* (C) 2009-2013 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* General Blueprint for Collection ADTs *)

BLUEPRINT ProtoCollection; (* root of collection hierarchy *)

IMPORT OR DEFINE AccessorType, ValueType, ProcType;

(* Collection ADTs must be records,
   literal compatibility may be specified by more specialised blueprints *)

TYPE ProtoCollection = OPAQUE |
                       OPAQUE RECORD := { VARIADIC OF AccessorType } |
                       { VARIADIC OF { AccessorType, ValueType } };


(* Bindings recommended for collection ADTs *)

(* CONST [ORD] isOrdered = <booleanValue>; *)

(* A collection ADT may declare itself ordered by binding a constant of value
   TRUE to ORD.  Ordered collections  may  use  FOR DESCENDING  syntax  while
   unordered collections may not.  Any use of FOR DESCENDING syntax by an un-
   ordered collection will cause a compile time error. *)


(* Bindings required for collection ADTs *)

(* Capacity limit *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the allocation capacity limit of the ADT type. *)

(* An invocation of TLIMIT(ADT)) is transformed at compile time to
   ADT.capacityLimit() when the operand is the ADT type. *)


(* Memory Management *)

(* The operations NEW, RETAIN and RELEASE are not common to all collection
   ADTs, their bindings may be required by more specialised blueprints. *)


(* Copying *)

PROCEDURE [COPY] copy ( source, target : ProtoCollection );
(* Procedure to copy the contents of one collection to another. *)

(* An invocation of COPY(c1, c2) is transformed at compile time to
   ADT.copy(c1, c2) for operands of the ADT type. *)


(* Storage, Retrieval and Inspection of Contents *)

(* The operations STORE and REMOVE are dependent on the kind of collection
   ADT and their signatures may differ. Their bindings may be required by
   more specialised blueprints. *)


PROCEDURE [RETRIEVE] valueForAccessor
  ( c : ProtoDictionary; accessor : AccessorType ) : ValueType;
(* Function to retrieve and return a value from a collection. *)

(* An invocation of RETRIEVE(c, accessor) is transformed at compile time
   to ADT.valueForAccessor(c, accessor) for first operands of the ADT
   type. *)


(* The membership test operation is not common to all collection ADTs.
   Its binding may be required by more specialised blueprints. *)

(* The operations COUNT and LENGTH are dependent on the kind of collection
   ADT and are mutually exclusive. Their bindings may be required by more
   specialised blueprints. *)


(* Iteration *)

TYPE ProcType = PROCEDURE ( AccessorType );

PROCEDURE [FOR] forIterator
  ( c : ProtoCollection; forLoopBody : ProcType; ascending : BOOLEAN );
(* Procedure to iterate over all entries of a collection and invoke
   procedure forLoopBody for each entry with the given iteration order. *)
   
(* A statement of the form
     FOR accessor IN c DO statementSeq END
   is transformed at compile time in two steps.
   The loop header is transformed to
     ADT.forIterator(c, forLoopBody, TRUE);
   The loop body is transformed to a procedure definition
     <* INLINE *> PROCEDURE forLoopBody ( accessor : AccessorType );
     BEGIN statementSeq END forLoopBody;
   inserted before the current scope's BEGIN-END block.
   
   If a constant with value TRUE has been bound to ORD, a loop
   header of the form
     FOR DESCENDING accessor IN c
   is transformed at compile time to
     ADT.forIterator(c, forLoopBody, FALSE)
   otherwise the use of FOR DESCENDING will cause a compile time error. *)   


(* Relational operations *)

PROCEDURE [=] isEqual ( c1, c2 : ProtoCollection ) : BOOLEAN;
(* Procedure to test the equality of two collections. *)

(* An expression of the form c1 = c2 is transformed at compile time to
   ADT.isEqual(c1, c2) for operands of the ADT type.
   
   An expression of the form c1 # c2 is transformed at compile time to
   NOT ADT.isEqual(c1, c2) for operands of the ADT type. *)


(* Subset and superset operations are not common to all collection ADTs.
   Their bindings may be required by more specialised blueprints. *)
   

(* IO operations *)

PROCEDURE [READ] Read ( infile : File; VAR c : ProtoCollection );
(* Procedure to read a value from a file into a collection. *)

(* An invocation of READ(file, c) is transformed at compile time
   to ADT.Read(file, c) for second operands of the ADT type. *)


PROCEDURE [WRITE] Write ( outfile : File; c : ProtoCollection );
(* Procedure to write a collection to a file. *)

(* An invocation of WRITE(file, c) is transformed at compile time
   to ADT.Write(file, c) for second operands of the ADT type. *)


PROCEDURE [WRITEF] WriteF
  ( outfile      : File;
    CONST fmtStr : ARRAY OF CHAR;
    items        : VARIADIC OF ProtoCollection );
(* Procedure to write one or more collections formatted into a file. *)

(* An invocation of WRITEF(file, fmt, c1, c2, c3, ...) is transformed
   at compile time to ADT.WriteF(file, fmt, c1, c2, c3, ...) for
   third operands and any following operands of the ADT type. *)


(* Introspection *)

(* Introspection operations are not common to all collection ADTs. Their
   bindings may be required by more specialised blueprints. *)


END ProtoCollection.