(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* General Blueprint for Collection ADTs *)

BLUEPRINT ProtoCollection [ProtoRoot];

REFERENTIAL AccessorType, ValueType, ProcType;

(* Collection ADTs must be opaque,
   literal compatibility may be specified by more specialised blueprints *)

TYPE ProtoCollection = OPAQUE | OPAQUE RECORD (* uses structured literals *)
  := { AccessorType BY * } | { { AccessorType, ValueType } BY * };


(* Bindings required for collection ADTs *)


(* Required Constants *)

CONST [:=] isMutable : BOOLEAN;
(* whether the Array ADT is mutable *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* whether the collection ADT is ordered *)


(* Required Procedures *)

(* Capacity limit *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the allocation capacity limit of the ADT type. *)

(* An invocation of TLIMIT(ADT)) is transformed at compile time to
   ADT.capacityLimit() when the operand is the ADT type. *)


(* Memory Management *)

(* The operations NEW, RETAIN and RELEASE are not common to all collection
   ADTs, their bindings may be required by more specialised blueprints. *)


(* Assignment and Copying *)

(* The assignment, COPY and DUP operations are not common to all collection
   ADTs, their bindings may be required by more specialised blueprints. *)


(* Storage, Retrieval and Inspection of Contents *)

(* The operations STORE and REMOVE are dependent on the kind of collection
   ADT and their signatures may differ. Their bindings may be required by
   more specialised blueprints. *)


PROCEDURE [RETRIEVE] valueForAccessor
  ( c : ProtoCollection; accessor : AccessorType ) : ValueType;
(* Function to retrieve and return a value from a collection. *)

(* An invocation of RETRIEVE(c, accessor) is transformed at compile time
   to ADT.valueForAccessor(c, accessor) for first operands of the ADT
   type. *)


(* The membership test operation is not common to all collection ADTs.
   Its binding may be required by more specialised blueprints. *)

(* The operations COUNT and LENGTH are dependent on the kind of collection
   ADT and are mutually exclusive. Their bindings may be required by more
   specialised blueprints. *)


(* Iteration *)

TYPE ProcType = PROCEDURE ( AccessorType );

PROCEDURE [FOR] forIterator
  ( c : ProtoCollection; forLoopBody : ProcType; ascending : BOOLEAN );
(* Procedure to iterate over all entries of a collection and invoke
   procedure forLoopBody for each entry with the given iteration order. *)
   
(* A statement of the form
     FOR accessor IN c DO statementSeq END
   is transformed at compile time in two steps.
   The loop header is transformed to
     ADT.forIterator(c, forLoopBody, TRUE);
   The loop body is transformed to a procedure definition
     <* INLINE *> PROCEDURE forLoopBody ( accessor : AccessorType );
     BEGIN statementSeq END forLoopBody;
   inserted before the current scope's BEGIN-END block.
   
   If the ADT is declared ordered, a loop header of the form
     FOR DESCENDING accessor IN c
   is transformed at compile time to
     ADT.forIterator(c, forLoopBody, FALSE)
   otherwise the use of FOR DESCENDING will cause a compile time error. *)   


(* Relational operations *)

PROCEDURE [=] isEqual ( c1, c2 : ProtoCollection ) : BOOLEAN;
(* Procedure to test the equality of two collections. *)

(* An expression of the form c1 = c2 is transformed at compile time to
   ADT.isEqual(c1, c2) for operands of the ADT type.
   
   An expression of the form c1 # c2 is transformed at compile time to
   NOT ADT.isEqual(c1, c2) for operands of the ADT type. *)


(* Subset and superset operations are not common to all collection ADTs.
   Their bindings may be required by more specialised blueprints. *)


(* Introspection *)

(* Introspection operations are not common to all collection ADTs. Their
   bindings may be required by more specialised blueprints. *)


END ProtoCollection.