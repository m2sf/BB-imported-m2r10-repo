(* (C) 2012-2015 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

BLUEPRINT ProtoScalar [ProtoNumeric];

(* General Blueprint for Scalar ADTs *)


(* Required Module Type *)

MODULE TYPE = RECORD;
(* Scalar ADTs must be statically allocatable. *)

LITERAL = INTEGER | REAL;
(* Integer or real number literals may be used. *)


(* Required Constants *)

(* Classification *)

CONST [TCOMP] isComputational = TRUE;
(* Scalar ADTs are always computational. *)

CONST [TNUM] isNumeric = TRUE;
(* Scalar ADTs are always numeric. *)

CONST isScalar = TRUE;
(* Sclalar ADTs are always scalar. *)

CONST isOrdinal : BOOLEAN;
(* Scalar ADTs must define whether they are ordinal or not. *)


(* Scalar Properties *)

CONST [TSIGNED] isSigned : BOOLEAN;
(* Scalar ADTs must define whether they are signed or unsigned. *)

CONST [TBASE] base : CARDINAL;
(* Radix in which the ADT's values are encoded, 2 or 10. *)

CONST [TPRECISION] precision : CARDINAL;
(* Maximum number of digits the ADT can encode, 1 to 4000. *)

isOrdinal ->
CONST [TMINEXP] eMin = 0;
(* Ordinal Scalar ADTs must define eMin with a value of zero. *)

NOT isOrdinal ->
CONST [TMINEXP] eMin : INTEGER;
(* Value of non-ordinal scalar ADT's smallest exponent. *)

isOrdinal ->
CONST [TMAXEXP] eMax = 0;
(* Ordinal Scalar ADTs must define eMax with a value of zero. *)

NOT isOrdinal ->
CONST [TMAXEXP] eMin : INTEGER;
(* Value of non-ordinal scalar ADT's largest exponent. *)


(* Memory Management *)

CONST [TDYN] isDynamic = FALSE;
(* Scalar ADTs are always statically allocated. *)


(* Required Procedures *)

(* Introspection *)

PROCEDURE [TMIN];
(* All scalar ADTs must provide a binding to TMIN. *)

PROCEDURE [TMAX];
(* All scalar ADTs must provide a binding to TMAX. *)


(* Numeric Conversion *)

PROCEDURE [SXF];
(* All scalar ADTs must provide a binding to SXF. *)

PROCEDURE [VAL];
(* All scalar ADTs must provide a binding to VAL. *)


(* Sign Removal *)

PROCEDURE [ABS];
(* All scalar ADTs must provide a binding to ABS. *)


(* Sign Reversal *)

isSigned -> PROCEDURE [+/-];
(* Signed scalar ADTs must provide a binding to unary minus. *)


(* Odd/Even Test *)

isOrdinal -> PROCEDURE [ODD];
(* Ordinal scalar ADTs must provide a binding to ODD. *)


(* Arithmetic Operations *)

PROCEDURE [+];
(* All scalar ADTs must provide a binding for addition. *)

PROCEDURE [-];
(* All scalar ADTs must provide a binding for subtraction. *)

PROCEDURE [*];
(* All scalar ADTs must provide a binding for multiplication. *)

NOT isOrdinal -> PROCEDURE [/];
(* Non-Ordinal scalar ADTs must provide a binding for division. *)

isOrdinal -> PROCEDURE [DIV];
(* Ordinal scalar ADTs must provide a binding for integer division. *)

isOrdinal -> PROCEDURE [MOD];
(* Ordinal scalar ADTs must provide a binding to the modulus operation. *)


(* Relational Operations *)

PROCEDURE [=];
(* All scalar ADTs must provide a binding for the equality test. *)

(* The # operation is synthesised from this binding. *)


PROCEDURE [<];
(* All scalar ADTs must provide a binding for the less-than test. *)

(* The >= operation is synthesised from this binding. *)


PROCEDURE [>];
(* All scalar ADTs must provide a binding for the greater-than test. *)

(* The <= operation is synthesised from this binding. *)


(* Inhibited Bindings *)

NOT isSigned -> PROCEDURE [+/-] = NONE; (* inhibited *)
(* Unsigned scalar ADTs may not be required to bind to unary minus. *)

NOT isOrdinal -> PROCEDURE [ODD] = NONE; (* inhibited *)
(* Non-Ordinal scalar ADTs may not be required to bind to DIV. *)

isOrdinal -> PROCEDURE [/] = NONE; (* inhibited *)
(* Ordinal scalar ADTs may not be required to bind to division. *)

NOT isOrdinal -> PROCEDURE [DIV] = NONE; (* inhibited *)
(* Non-Ordinal scalar ADTs may not be required to bind to DIV. *)

NOT isOrdinal -> PROCEDURE [MOD] = NONE; (* inhibited *)
(* Non-Ordinal scalar ADTs may not be required to bind to MOD. *)


END ProtoScalar.