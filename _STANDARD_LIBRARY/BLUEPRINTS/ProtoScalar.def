(* (C) 2012-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* General Blueprint for Scalar ADTs *)

BLUEPRINT ProtoScalar [ProtoNumeric]; (* conforms to ProtoNumeric *)


(* Required Module Type *)

MODULE TYPE = RECORD := INTEGER | REAL;
(* Scalar ADTs must be records to be statically allocatable,
   integer and real number literals are compatible. *)


(* Required Constants *)


CONST [TSIGNED] isSigned : BOOLEAN;
(* Required constant to define whether the ADT is signed. *)

CONST [TBASE] base : CARDINAL;
(* Radix in which the ADT's values are encoded, 2 or 10. *)

CONST [TPRECISION] precision : [1..4000] OF CARDINAL;
(* Maximum number of digits the ADT can encode. *)

CONST [TMINEXP] eMin : INTEGER;
(* Value of the ADT's smallest exponent. *)

CONST [TMAXEXP] eMax : INTEGER;
(* Value of the ADT's largest exponent. *)

CONST * isWholeNumberADT = (eMin=0 AND eMax=0);
(* Internal flag to test whether the ADT represents whole numbers. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TMIN *)

PROCEDURE [TMIN];
(* Specialised blueprints must always require binding to TMIN. *)


(* Binding to Predefined Function TMAX *)

PROCEDURE [TMAX];
(* Specialised blueprints must always require binding to TMAX. *)


(* Numeric Conversion *)

(* Binding to scalar conversion primitives SXF and VAL *)

PROCEDURE [SXF];
(* Specialised blueprints must always require binding to SXF. *)

PROCEDURE [VAL];
(* Specialised blueprints must always require binding to VAL. *)

(* Conversion between any two scalar ADTs can be synthesised utilising the
   ADTs' conversion procedures bound to SXF and VAL.
   
   A conversion expression of the form
     intValue :: CardinalADT
   is synthesised as
     IntegerADT.toSXF(intValue, temp);
     CardinalADT.fromSXF(temp, result);
   when no direct conversion is implemented. *)


(* Literal Assignment *)

(* Numeric literals are converted to scalar exchange format at compile time.
   Assignments of numeric literals to numeric ADTs are then synthesised
   utilising an ADT's conversion procedure bound to VAL.
   
   An assignment of the form
     scalar := 123;
   is synthesised as
     ScalarADT.fromSXF(sxfCompiletimeValue, scalar); *)


(* Iteration *)

(* Binding to FOR IN iterator *)

(* Scalar ADTs may not bind any procedure to FOR.
   
   Instead, iteration over scalar ADTs and subranges of Scalar ADTs is auto-
   matically supported if and only if all of the following conditions are met:
   
   (1) the ADT binds a constant value of zero to both TMINEXP and TMAXEXP,
   (2) the ADT provides bindings for TMIN and TMAX,
   (3) the ADT provides bindings for + and -,
   (4) the ADT provides bindings for < and >.
   
   A statement of the form
     FOR s IN ScalarADT DO ...
   is equivalent to
     FOR s IN [lower .. upper] OF ScalarADT DO ...
   where lower = TMIN(ScalarADT) and upper = TMAX(ScalarADT).
     
   A statement of the form
     FOR s IN [lower .. upper] OF ScalarADT DO statementSeq END
   is synthesised as
     VAR s : ScalarADT;
     s := lower;
     LOOP
       statementSeq;
       IF s < upper THEN n++ ELSE EXIT END
     END;
   
   A statement of the form
     FOR DESCENDING s IN ScalarADT DO ...
   is equivalent to
     FOR DESCENDING s IN [lower .. upper] OF ScalarADT DO ...
   where lower = TMIN(ScalarADT) and upper = TMAX(ScalarADT).

   A statement of the form
     FOR DESCENDING s IN [lower .. upper] OF ScalarADT DO statementSeq END
   is synthesised as
     VAR s : ScalarADT;
     s := upper;
     LOOP
       statementSeq;
       IF s > lower THEN s-- ELSE EXIT END
     END; *)


(* Arithmetic Operations *)

(* Binding to Predefined Function ABS *)

PROCEDURE [ABS];
(* Specialised blueprints must always require binding to TMAX. *)


(* Binding to Predefined Function ODD *)

isWholeNumberADT ->
PROCEDURE [ODD];
(* Specialised blueprints must require binding to ODD
   when the ADT represents whole numbers. *)


(* Binding to Predefined Function NEG *)

isSigned ->
PROCEDURE [NEG];
(* Specialised blueprints must require binding to NEG
   when the ADT is signed. *)


(* Binding to the + Operator *)

PROCEDURE [+];
(* Specialised blueprints must always require binding to the + operator. *)


(* Binding to the - Operator *)

PROCEDURE [-];
(* Specialised blueprints must always require binding to the - operator. *)


(* Binding to the * Operator *)

PROCEDURE [*];
(* Specialised blueprints must always require binding to the * operator. *)


(* Binding to the / Operator *)

NOT isWholeNumberADT ->
PROCEDURE [/];
(* Specialised blueprints must require binding to the / operator
   when the ADT does not represent whole numbers. *)


(* Binding to the DIV Operator *)

isWholeNumberADT ->
PROCEDURE [DIV];
(* Specialised blueprints must require binding to the DIV operator
   when the ADT represents whole numbers. *)


(* Binding to the MOD Operator *)

isWholeNumberADT ->
PROCEDURE [MOD];
(* Specialised blueprints must require binding to the MOD operator
   when the ADT represents whole numbers. *)


(* Relational Operations *)

(* Binding to Operators = and # *)

PROCEDURE [=];
(* Specialised blueprints must always require binding to the = operator. *)

(* The # operation is synthesised as (NOT s1 = s2). *)


(* Binding to Operators < and >= *)

PROCEDURE [<];
(* Specialised blueprints must always require binding to the = operator. *)

(* The >= operation is synthesised as (NOT s1 < s2). *)


(* Binding to Operators > and <= *)

PROCEDURE [>];
(* Specialised blueprints must always require binding to the = operator. *)

(* The <= operation is synthesised as (NOT s1 > s2). *)


(* Conditional Inhibited Bindings *)

(* Conforming blueprints may not require bindings to any of
   ODD, DIV and MOD if the ADT does not represent whole numbers. *)

NOT isWholeNumberADT -> PROCEDURE [ODD] : NIL; (* inhibited *)

NOT isWholeNumberADT -> PROCEDURE [DIV] : NIL; (* inhibited *)

NOT isWholeNumberADT -> PROCEDURE [MOD] : NIL; (* inhibited *)

(* Conforming blueprints may not require binding to NEG
   if the ADT is unsigned. *)

NOT isSigned -> PROCEDURE [NEG] : NIL; (* inhibited *)


(* Conforming blueprints may not require binding to the / operator
   if the ADT represents whole numbers. *)

isWholeNumberADT -> PROCEDURE [/] : NIL; (* inhibited *)


END ProtoScalar.