(* (C) 2012-2015 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* General Blueprint for Scalar ADTs *)

BLUEPRINT ProtoScalar [ProtoNumeric]; (* conforms to ProtoNumeric *)


(* Required Module Type *)

MODULE TYPE = RECORD;
(* Scalar ADTs must be records to be statically allocatable. *)

LITERAL := INTEGER | REAL;
(* Integer or real number literals may be used. *)


(* Required Constants *)

CONST [TSIGNED] isSigned : BOOLEAN;
(* Required constant to define whether the ADT is signed. *)

CONST [TBASE] base : CARDINAL;
(* Radix in which the ADT's values are encoded, 2 or 10. *)

CONST [TPRECISION] precision : CARDINAL;
(* Maximum number of digits the ADT can encode, 1 to 4000. *)

CONST [TMINEXP] eMin : INTEGER;
(* Value of the ADT's smallest exponent, zero for whole number ADTs. *)

CONST [TMAXEXP] eMax : INTEGER;
(* Value of the ADT's largest exponent, zero for whole number ADTs. *)


(* Required Procedures *)

(* Introspection *)

(* Binding to Predefined Function TMIN *)

PROCEDURE [TMIN];
(* Specialised blueprints must always require binding to TMIN. *)


(* Binding to Predefined Function TMAX *)

PROCEDURE [TMAX];
(* Specialised blueprints must always require binding to TMAX. *)


(* Numeric Conversion *)

(* Binding to scalar conversion primitives SXF and VAL *)

PROCEDURE [SXF];
(* Specialised blueprints must always require binding to SXF. *)

PROCEDURE [VAL];
(* Specialised blueprints must always require binding to VAL. *)

(* Conversion between any two scalar ADTs can be synthesised utilising the
   ADTs' conversion procedures bound to SXF and VAL.
   
   A conversion expression of the form
     intValue :: CardinalADT
   is synthesised as
     IntegerADT.toSXF(intValue, temp);
     CardinalADT.fromSXF(temp, result);
   when no direct conversion is implemented. *)


(* Literal Assignment *)

(* Numeric literals are converted to scalar exchange format at compile time.
   Assignments of numeric literals to numeric ADTs are then synthesised
   utilising an ADT's conversion procedure bound to VAL.
   
   An assignment of the form
     scalar := 123;
   is synthesised as
     ScalarADT.fromSXF(sxfCompiletimeValue, scalar); *)


(* Iteration *)

(* Scalar ADTs may not bind any procedure to FOR.
   
   Instead, iteration over scalar ADTs and subranges of Scalar ADTs is auto-
   matically supported if and only if all of the following conditions are met:
   
   (1) the ADT binds a constant value of zero to both TMINEXP and TMAXEXP,
   (2) the ADT provides bindings for TMIN and TMAX,
   (3) the ADT provides bindings for + and -,
   (4) the ADT provides bindings for < and >.
   
   A statement of the form
     FOR s IN ScalarADT DO ...
   is equivalent to
     FOR s IN [lower .. upper] OF ScalarADT DO ...
   where lower = TMIN(ScalarADT) and upper = TMAX(ScalarADT).
     
   A statement of the form
     FOR s IN [lower .. upper] OF ScalarADT DO statementSeq END
   is synthesised as
     VAR s : ScalarADT;
     s := lower;
     LOOP
       statementSeq;
       IF s < upper THEN s++ ELSE EXIT END
     END;
   
   A statement of the form
     FOR s-- IN ScalarADT DO ...
   is equivalent to
     FOR s-- IN [lower .. upper] OF ScalarADT DO ...
   where lower = TMIN(ScalarADT) and upper = TMAX(ScalarADT).

   A statement of the form
     FOR s-- IN [lower .. upper] OF ScalarADT DO statementSeq END
   is synthesised as
     VAR s : ScalarADT;
     s := upper;
     LOOP
       statementSeq;
       IF s > lower THEN s-- ELSE EXIT END
     END; *)


(* Arithmetic Operations *)

(* Binding to Predefined Function ABS *)

PROCEDURE [ABS];
(* Specialised blueprints must always require binding to ABS. *)


(* Binding to Predefined Function ODD *)

(* The ODD operation is not common to all scalars.
   Specialised blueprints must require binding to ODD
   if and only if constants eMin and eMax are both zero. *)


(* Binding to Unary Minus Operator *)

isSigned -> PROCEDURE [+/-];

(* Specialised blueprints must require binding to unary minus
   if the ADT is signed. *)


(* Binding to the + Operator *)

PROCEDURE [+];
(* Specialised blueprints must always require binding to the + operator. *)


(* Binding to the - Operator *)

PROCEDURE [-];
(* Specialised blueprints must always require binding to the - operator. *)


(* Binding to the * Operator *)

PROCEDURE [*];
(* Specialised blueprints must always require binding to the * operator. *)


(* Binding to the / Operator *)

(* Real number division is not common to all scalars.
   Specialised blueprints must require binding to the / operator
   if and only if constants eMin and eMax are not both zero. *)


(* Binding to the DIV Operator *)

(* Integer division is not common to all scalars.
   Specialised blueprints must require binding to the DIV operator
   if and only if constants eMin and eMax are both zero. *)


(* Binding to the MOD Operator *)

(* The MOD operation is not common to all scalars.
   Specialised blueprints must require binding to the DIV operator
   if and only if constants eMin and eMax are both zero. *)


(* Relational Operations *)

(* Binding to Operators = and # *)

PROCEDURE [=];
(* Specialised blueprints must always require binding to the = operator. *)

(* The # operation is synthesised as (NOT s1 = s2). *)


(* Binding to Operators < and >= *)

PROCEDURE [<];
(* Specialised blueprints must always require binding to the = operator. *)

(* The >= operation is synthesised as (NOT s1 < s2). *)


(* Binding to Operators > and <= *)

PROCEDURE [>];
(* Specialised blueprints must always require binding to the = operator. *)

(* The <= operation is synthesised as (NOT s1 > s2). *)


(* Inhibited Bindings *)

NOT isSigned -> PROCEDURE [+/-] = NONE; (* inhibited *)
(* Conforming blueprints may not require binding to Unary Minus
   if the ADT is unsigned. *)


END ProtoScalar.