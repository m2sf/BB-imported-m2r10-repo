(* (C) 2012-2013 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Real Array ADTs *)

BLUEPRINT ProtoRealArray [ProtoNonScalar];

PLACEHOLDERS IndexType, RealType, ProcType;

(* Real Array ADTs must be opaque records to be statically allocatable,
   structured literals with lists of real number literals are compatible *)

TYPE ProtoRealArray = OPAQUE RECORD := { VARIADIC OF REAL };


(* Bindings required for Real Array ADTs *)

(* Capacity limit *)

(* Binding to pervasive function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the index/value pair limit of a Real Array ADT. *)

(* An expression of the form TLIMIT(ArrayADT))
   is synthesised as ArrayADT.capacityLimit() *)


(* Binding to assignment operator *)

PROCEDURE [:=] assign ( VAR array : ProtoRealArray;
                        valueList : VARIADIC OF RealType );

(* Procedure to assign a structured literal to a Real Array ADT variable. *)

(* A statement of the form array := { value1, value2, ..., valueN }
   is synthesised as assign( array, value1, value2, ..., valueN ) *)


(* Storage and retrieval *)

(* Binding to [ ] notation within left hand entities *)

PROCEDURE [STORE] storeValue ( VAR array : ProtoRealArray;
                                   index : IndexType; value : REAL );

(* Procedure to store a value at a given index in a Static Array ADT
   variable. *)

(* A statement of the form array[index] := value
   is synthesised as storeValue( array, index, value) *)


(* Binding to [ ] notation within expressions *)

PROCEDURE [RETRIEVE] valueAtIndex ( array : ProtoRealArray;
                                    index : IndexType ) : REAL;
(* Procedure to return the value stored at a given index in a Static Array
   ADT value. *)

(* An expression of the form array[index]
   is synthesised as valueAtIndex( array, index ) *)


(* Index/Value count *)

(* Binding to pervasive function COUNT *)

PROCEDURE [COUNT] count ( array : ProtoRealArray ) : LONGCARD;
(* Procedure to return the index/value count of a Static Array ADT value. *)

(* An expression of the form COUNT(array)
   is synthesised as ArrayADT.count(array) *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE ProcType = PROCEDURE ( VAR ProtoRealArray; CONST IndexType );

PROCEDURE [FOR] forIterator ( VAR array : ProtoRealArray;
                           doStatements : ProcType );

(* Procedure to iterate over all index/value pairs of a Static Array ADT
   value in ascending order and execute the passed in doStatements for each
   pair. *)
   
(* A statement of the form
     FOR index IN array DO statementSeq END
   is synthesised in two steps.
   The loop header is synthesised as
     ArrayADT.forIterator( array, forLoopBody );
   The loop body is synthesised as
     <* INLINE *> PROCEDURE forLoopBody ( VAR array : ArrayADT;
                                        CONST index : IndexType );
     BEGIN statementSeq END forLoopBody; *)

PROCEDURE [DESCENDING] reverseFor ( VAR array : ProtoRealArray;
                                 doStatements : ProcType );

(* Procedure to iterate over all index/value pairs of a Real Array ADT
   value in descending order and execute doStatements for each pair. *)
   
(* A statement of the form
     FOR DESCENDING index IN array DO statementSeq END
   is synthesised in two steps.
   The loop header is synthesised as
     ArrayADT.reverseFor( array, forLoopBody );
   The loop body is synthesised as
     <* INLINE *> PROCEDURE forLoopBody ( VAR array : ArrayADT;
                                        CONST index : IndexType );
     BEGIN statementSeq END forLoopBody; *)
   

(* Bindings to monadic operations *)

PROCEDURE [ABS] abs ( array : ProtoRealArray ) : ProtoRealArray;
(* Procedure to return a Real Array ADT calculated by obtaining the absolute
   value of all values of its operand. *)

(* An expression of the form ABS(array)
   is synthesised as ArrayADT.abs(array) *)


PROCEDURE [NEG] neg ( array : ProtoRealArray ) : ProtoRealArray;
(* Procedure to return a Real Array ADT calculated by reversing the sign of
   all values of its operand. *)

(* An expression of the form -array
   is synthesised as ArrayADT.neg(array) *)


(* Bindings to dyadic operations *)

PROCEDURE [+] add ( a1, a2 : ProtoRealArray ) : ProtoRealArray;
(* Procedure to return the sum of two Real Array ADT values. *)

(* An expression of the form array1 + array2
   is synthesised as ArrayADT.add(array1, array2) *)


PROCEDURE [-] subtract ( a1, a2 : ProtoRealArray ) : ProtoRealArray;
(* Procedure to return the difference of two Real Array ADT values. *)

(* An expression of the form array1 - array2
   is synthesised as ArrayADT.subtract(array1, array2) *)


PROCEDURE [*] multiply ( a1, a2 : ProtoRealArray ) : ProtoRealArray;
(* procedure to return the product of two Real Array ADT values. *)

(* An expression of the form array1 * array2
   is synthesised as ArrayADT.multiply(array1, array2) *)


PROCEDURE [/] divide ( a1, a2 : ProtoRealArray ) : ProtoRealArray;
(* procedure to return the quotient of two Real Array ADT values. *)

(* An expression of the form array1 / array2
   is synthesised as ArrayADT.divide(array1, array2) *)


(* Relational operations *)

(* Binding to = operator *)

PROCEDURE [=] isEqual ( a1, a2 : ProtoRealArray ) : BOOLEAN;
(* Procedure to test the equivalence of two Real Array ADT values. *)

(* An expression of the form array1 = array2
   is synthesised as ArrayADT.isEqual(array1, array2) *)

(* The operation for the # operator
   is synthesized as NOT (array1 = array2) *)


(* Binding to < operator *)

(* The operations < and <= are not meaningful for arrays. *)


(* Binding to > operator *)

(* The operations > and >= are not meaningful for arrays. *)


END ProtoRealArray.