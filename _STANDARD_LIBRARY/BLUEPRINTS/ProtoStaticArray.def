(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Statically Allocatable Array ADTs *)

BLUEPRINT ProtoStaticArray [ProtoCollection];

REFERENTIAL IndexType, ValueType, ProcType;

(* Static Array ADTs must be opaque records to be statically allocatable,
   array literals are compatible *)

MODULE TYPE = OPAQUE RECORD := { ValueType BY * };


(* Bindings required for Static Array ADTs *)


(* Required Constants *)

CONST [:=] isMutable = TRUE;
(* Static array ADTs are always mutable *)

CONST [DESCENDING] isOrdered = TRUE;
(* Static array ADTs are always ordered *)


(* Required Procedures *)

(* Capacity limit *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the allocation capacity limit of the array ADT. *)

(* An invocation of TLIMIT(ADT)) is transformed at compile time to
   ArrayADT.capacityLimit() when the operand is of the array ADT type. *)


(* Assignment and Copying *)

PROCEDURE [:=] assignStructuredValue
  ( array : ProtoStaticArray; value : ARGLIST capacityLimit OF ValueType );
(* Required procedure to assign a structured value to an array. *)

(* A statement of the form
     array := { 1, 2, 3, 4, 5 };
   is transformed at compile time into a procedure call of the form
     ArrayADT.assignStructuredValue(array, 1, 2, 3, 4, 5); *)


PROCEDURE [COPY] copy
  ( source : ProtoStaticArray; VAR target : ProtoStaticArray );
(* Required procedure to copy the contents of a source array into a
   target array. *)

(* A statement of the form
     array1 := array2;
   is transformed at compile time into a procedure call of the form
     ArrayADT.copy(array2, array1); *)


(* Storage, Retrieval and Inspection of Contents *)

PROCEDURE [STORE] storeValue
  ( VAR array : ProtoStaticArray;
    index : IndexType; value : ValueType );
(* Required procedure to store a given value for a given index in an array *)

(* A statement of the form
     array[index] := value
   is transformed at compile time into a procedure call of the form
     ArrayADT.storeValue(array, index, value); *)


PROCEDURE [RETRIEVE] valueAtIndex
  ( array : ProtoStaticArray; index : IndexType ) : ValueType;
(* Required procedure to return the value for a given index in an array. *)

(* An expression of the form
     array[index]
   is transformed at compile time into a function call of the form
     ArrayADT.valueAtIndex(array, index) *)


(* The REMOVE operation is not meaningful for static arrays. *)


(* Introspection *)

PROCEDURE [COUNT] count ( array : ProtoStaticArray ) : LONGCARD;
(* Required procedure to return the number of components of an array. *)

(* An expression of the form
    COUNT(array)
   is transformed at compile time to a function call of the form
    ArrayADT.count(array) *)


(* Iteration *)

TYPE ProcType = PROCEDURE ( VAR ProtoStaticArray; CONST IndexType );

PROCEDURE [FOR] forIterator
  ( VAR array : ProtoStaticArray; doStatements : ProcType );

(* Required procedure to iterate over all index/value pairs of an array
   in ascending order and execute doStatements for each pair. *)
   
(* A statement of the form
     FOR index IN array DO statementSeq END
   is synthesised in two steps.
   The loop header is synthesised as
     ArrayADT.forIterator( array, forLoopBody );
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR array : ArrayADT; CONST index : IndexType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody; *)


(* Relational operations *)

PROCEDURE [=] isEqual ( array1, array2 : ProtoStaticArray ) : BOOLEAN;
(* Required procedure to test the equivalence of two arrays. *)

(* An expression of the form
     array1 = array2
   is transformed at compile time to a function call of the form
     ArrayADT.isEqual(array1, array2) *)

(* The operation for the # operator
   is synthesized as NOT (array1 = array2) *)


(* The <, <=, > and >= operations are not meaningful for static arrays. *)


END ProtoStaticArray.