(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Dynamically Allocatable Array ADTs *)

BLUEPRINT ProtoArray [ProtoCollection];

REFERENTIAL IndexType, ValueType, ProcType;

(* Array ADTs must be opaque,
   array literals are compatible *)

MODULE TYPE = OPAQUE := { VARIADIC OF ValueType };


(* Bindings required for Array ADTs *)

(* Required Constants *)

CONST [:=] isMutable : BOOLEAN;
(* whether the Array ADT is mutable or immutable *)

CONST [DESCENDING] isOrdered = TRUE;
(* arrays are ordered and support ascending and descending iteration *)


(* Capacity limit *)

(* Binding to predefined function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the index/value pair limit of an Array ADT. *)

(* An expression of the form TLIMIT(ArrayADT))
   is synthesised as ArrayADT.capacityLimit() *)


(* Construction and Destruction *)

PROCEDURE [NEW] new ( VAR array : ProtoArray );
(* Procedure to allocate and initialise a new Array ADT variable. *)

(* A statement of the form NEW(array)
   is synthesised as ArrayADT.new(array) *)

PROCEDURE [RELEASE] release ( VAR array : ProtoArray );
(* Procedure to release an Array ADT variable. *)

(* A statement of the form RELEASE(array)
   is synthesised as ArrayADT.release(array) *)


(* Storage and retrieval *)

(* Binding to [ ] notation within L-values *)

PROCEDURE [STORE] storeValue ( VAR array : ProtoArray;
                                   index : IndexType; value : ValueType );
(* Procedure to store a value at a given index in an Array ADT variable. *)

(* A statement of the form array[index] := value
   is synthesised as storeValue( array, index, value) *)


(* Binding to [ ] notation within expressions *)

PROCEDURE [RETRIEVE] valueAtIndex ( array : ProtoArray;
                                    index : IndexType ) : ValueType;
(* Procedure to return the value stored at a given index in an Array ADT
   value. *)

(* An expression of the form array[index]
   is synthesised as valueAtIndex( array, index ) *)


PROCEDURE [INSERT] insertValuesAtIndex
  ( targetArray : ProtoArray;
    index : IndexType;
    values : ARGLIST OF ValueType );
(* Required procedure to insert a value list into a target array,
   starting at a given index. *)

(* A statement of the form
     INSERT(array, index, val1, val2, val3, ...);
   is transformed at compile time into a procedure call of the form
     ArrayADT.insertValuesAtIndex(array, index, val1, val2, val3, ...);
   for designators of the array ADT type. *)


PROCEDURE [INSERT] insertArrayAtIndex
  ( targetArray : ProtoArray;
    index : IndexType;
    sourceArray : ProtoArray );
(* Required procedure to insert a source array into a target array,
   starting at a given index. *)

(* A statement of the form
     INSERT(targetArray, index, sourceArray);
   is transformed at compile time into a procedure call of the form
     ArrayADT.insertArrayAtIndex(targetArray, index, sourceArray);
   for designators of the array ADT type. *)



(* Index/Value count *)

(* Binding to predefined function COUNT *)

PROCEDURE [COUNT] count ( array : ProtoArray ) : LONGCARD;
(* Procedure to return the index/value count of an Array ADT value. *)

(* An expression of the form COUNT(array)
   is synthesised as ArrayADT.count(array) *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE ProcType = PROCEDURE ( VAR ProtoArray; CONST IndexType );

PROCEDURE [FOR] forIterator
  ( VAR array : ProtoArray; doStatements : ProcType; ascending : BOOLEAN );

(* Procedure to iterate over all index/value pairs of an Array ADT value in
   ascending order and execute the passed in doStatements for each pair. *)
   
(* A statement of the form
     FOR index IN array DO statementSeq END
   is synthesised in two steps.
   The loop header is synthesised as
     ArrayADT.forIterator( array, forLoopBody, TRUE );
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR array : ArrayADT; CONST index : IndexType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody; *)


(* Dyadic operations *)

(* The operations +, -, * and / are not common to all Array ADTs,
   their bindings may be required by more specialised blueprints. *)


(* Relational operations *)

(* Binding to = operator *)

PROCEDURE [=] isEqual ( array1, array2 : ProtoArray ) : BOOLEAN;
(* Procedure to test the equivalence of two Array ADT values. *)

(* An expression of the form array1 = array2
   is synthesised as ArrayADT.isEqual(array1, array2) *)

(* The operation for the # operator
   is synthesized as NOT (array1 = array2) *)


(* Binding to < operator *)

(* The operations < and <= are not meaningful for array ADTs. *)


(* Binding to > operator *)

(* The operations > and >= are not meaningful for array ADTs. *)


END ProtoArray.