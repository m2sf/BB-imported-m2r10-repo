(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Dynamically Allocatable Array ADTs *)

BLUEPRINT ProtoArray [ProtoCollection];

REFERENTIAL IndexType, ValueType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE := { ARGLIST OF ValueType };
(* Array ADTs must be opaque,
   array literals with a variable number of values are compatible. *)


(* Required Constants *)

(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT is mutable.
   Its value may be TRUE or FALSE. *)

CONST isImmutable = NOT isMutable;
(* Required constant indicating whether the ADT is immutable.
   Its value must be the logical inverse of constant isMutable. *)


(* Order and Use of Descending Iteration *)

(* Use of FOR DESCENDING syntax with the ADT is only permitted
   when a constant is bound to DESCENDING and its value is TRUE. *)

CONST [DESCENDING] isOrdered = TRUE;
(* Required constant to define whether the ADT is ordered.
   Its value is always TRUE for Array ADTs. *)

CONST isUnordered = NOT isOrdered;
(* Required constant indicating whether the ADT is unordered.
   Its value must be the logical inverse of constant isOrdered. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether the ADT is reference counted.
   Its value may be TRUE or FALSE. *)

CONST isNotRefCounted = NOT isRefCounted;
(* Required constant indicating whether the ADT is reference counted.
   Its value must be the logical inverse of constant isRefCounted. *)


(* Binding Impediments *)

(* Conforming blueprints may not require bindings to any of
   COPY, STORE, INSERT and REMOVE if the ADT is immutable. *)

isImmutable -> PROCEDURE [COPY] NIL;

isImmutable -> PROCEDURE [STORE] NIL;

isImmutable -> PROCEDURE [INSERT] NIL;

isImmutable -> PROCEDURE [REMOVE] NIL;


(* Conforming blueprints may not require a binding to RETAIN
   if the ADT is not reference counted. *)

isNotRefCounted -> PROCEDURE [RETAIN] NIL;

   
(* Capacity limit *)

(* Binding to predefined function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the index/value pair limit of the ADT. *)

(* An expression of the form TLIMIT(ArrayADT))
   is synthesised as ArrayADT.capacityLimit() *)


(* Construction and Destruction *)

PROCEDURE [NEW] new
  ( VAR array : ProtoArray; values : ARGLIST OF ValueType );
(* Required procedure to allocate a new array and initialise it
   with zero or more given values. *)

(* A statement of the form NEW(array)
   is synthesised as ArrayADT.new(array).
   
   A statement of the form NEW(array, 1, 2, 3, 4, 5 ...)
   is synthesised as ArrayADT.new(array, 1, 2, 3, 4, 5, ...). *)


isMutable ->
PROCEDURE newWithCapacity
  ( VAR array : ProtoArray; capacity : LONGCARD );
(* Procedure to allocate a new array with a given initial capacity.
   The procedure is required when the ADT is mutable. *)


isRefCounted ->
PROCEDURE [RETAIN] retain ( VAR array : ProtoArray );
(* Procedure to retain an array and prevent its deallocation.
   The procedure is required when the ADT is reference counted. *)

(* A statement of the form RETAIN(array)
   is synthesised as ArrayADT.retain(array) *)


PROCEDURE [RELEASE] release ( VAR array : ProtoArray );
(* Required procedure to cancel an outstanding retain
   or deallocate an array if no retains are outstanding. *)

(* A statement of the form RELEASE(array)
   is synthesised as ArrayADT.release(array) *)


(* Storage, retrieval and insertion *)

(* Binding to [ ] notation within L-values *)

isMutable ->
PROCEDURE [STORE] storeValue ( VAR array : ProtoArray;
                                   index : IndexType; value : ValueType );
(* Procedure to store a value at a given index in an Array ADT variable.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form array[index] := value
   is synthesised as storeValue( array, index, value) *)


(* Binding to [ ] notation within expressions *)

PROCEDURE [RETRIEVE] valueAtIndex ( array : ProtoArray;
                                    index : IndexType ) : ValueType;
(* Required function to return the value stored in an array at a given index. *)

(* An expression of the form array[index]
   is synthesised as valueAtIndex( array, index ) *)


TYPE HandlerType = PROCEDURE ( VAR ValueType ) : BOOLEAN;
(* Required procedure type for user defined index-out-of-range handlers. *)

(* An index-out-of-range handler function may be used to modify the default
   behaviour when RETRIEVE is called with an out-of-range index. 
   
   An example of an index-out-of-range handler is given below:
   
   PROCEDURE mayAbortOnIndexOutOfRange
     ( VAR valueToReturn : CARDINAL ) : BOOLEAN;
   BEGIN
     valueToReturn := 0;
     RETURN FALSE
   END mayAbortOnIndexOutOfRange;
   
   This handler tells its caller to return zero and not to abort. *)


PROCEDURE installIndexOutOfRangeHandler ( handler : HandlerType );
(* Required procedure to install a user defined index-out-of-range handler. *)


isMutable ->
PROCEDURE [INSERT] insertValuesAtIndex
  ( targetArray : ProtoArray;
    index : IndexType;
    values : ARGLIST OF ValueType );
(* Procedure to insert a value list into a target array at a given index.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     INSERT(array, index, val1, val2, val3, ...);
   is transformed at compile time into a procedure call of the form
     ArrayADT.insertValuesAtIndex(array, index, val1, val2, val3, ...);
   for designators of the ADT type. *)


isMutable ->
PROCEDURE [INSERT] insertArrayAtIndex
  ( targetArray : ProtoArray;
    index : IndexType;
    sourceArray : ProtoArray );
(* Procedure to insert a source array into a target array at a given
   index. The procedure is required when the ADT is mutable. *)

(* A statement of the form
     INSERT(targetArray, index, sourceArray);
   is transformed at compile time into a procedure call of the form
     ArrayADT.insertArrayAtIndex(targetArray, index, sourceArray);
   for designators of the ADT type. *)


isMutable ->
PROCEDURE [REMOVE] removeValueAtIndex
  ( array : ProtoArray; index : IndexType);
(* Procedure to remove a value from an array at a given index.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     REMOVE(array, index);
   is transformed at compile time into a procedure call of the form
     ArrayADT.removeValueAtIndex(array, index);
   for designators of the ADT type. *)


(* Index/Value count *)

(* Binding to predefined function COUNT *)

PROCEDURE [COUNT] count ( array : ProtoArray ) : LONGCARD;
(* Required function to return the index/value count of an array. *)

(* An expression of the form COUNT(array)
   is synthesised as ArrayADT.count(array) *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoArray, CONST IndexType );
(* Required procedure type to synthesise the body of a for loop. *)

PROCEDURE [FOR] forIterator
  ( VAR array : ProtoArray; doStatements : LoopBodyType; ascending : BOOLEAN );

(* Required procedure to iterate over all index/value pairs of an array
   in a given order and execute the passed in doStatements for each pair. *)
   
(* A statement of the form
     FOR index IN array DO statementSeq END
   is synthesised in two steps.
   First, the loop header is synthesised as
     ArrayADT.forIterator( array, forLoopBody, TRUE );
   Then the loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR array : ArrayADT; CONST index : IndexType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   
   The loop header of a FOR DESCENDING statement is sythesised with
   FALSE passed for parameter ascending in the forIterator call. *)


(* Dyadic operations *)

(* The operations +, -, * and / are not common to all Array ADTs,
   their bindings may be required by more specialised blueprints. *)


(* Relational operations *)

(* Binding to = operator *)

PROCEDURE [=] isEqual ( array1, array2 : ProtoArray ) : BOOLEAN;
(* Required function to test the equivalence of two arrays. *)

(* An expression of the form array1 = array2
   is synthesised as ArrayADT.isEqual(array1, array2) *)

(* The operation for the # operator
   is synthesized as NOT (array1 = array2) *)


(* Binding to predefined function SUBSET. *)

(* The SUBSET operation is not meaningful for array ADTs. *)

PROCEDURE [SUBSET] NIL;
(* Conforming blueprints may not require a binding to SUBSET. *)


(* Binding to < operator *)

(* The operations < and <= are not meaningful for array ADTs. *)

PROCEDURE [<] NIL;
(* Conforming blueprints may not require a binding to the < operator. *)


(* Binding to > operator *)

(* The operations > and >= are not meaningful for array ADTs. *)

PROCEDURE [>] NIL;
(* Conforming blueprints may not require a binding to the > operator. *)


END ProtoArray.