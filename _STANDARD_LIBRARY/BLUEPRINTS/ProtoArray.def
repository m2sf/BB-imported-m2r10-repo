(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Dynamically Allocatable Array ADTs *)

BLUEPRINT ProtoArray [ProtoCollection];

REFERENTIAL IndexType, ValueType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE := { ARGLIST OF ValueType };
(* Array ADTs must be opaque,
   array literals with a variable number of values are compatible. *)


(* Required Constants *)


(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT is mutable.
   Its value may be TRUE or FALSE. *)


(* Orderedness *)

(* Use of FOR DESCENDING syntax with the ADT is only permitted
   when a constant is bound to DESCENDING and its value is TRUE. *)

CONST [DESCENDING] isOrdered = TRUE;
(* Required constant to define whether the ADT is ordered.
   Its value is always TRUE for Array ADTs. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether the ADT is reference counted.
   Its value may be TRUE or FALSE. *)


(* Storability of NIL *)

CONST [NIL] allowsNilStorage : BOOLEAN;
(* Required constant to define whether NIL is a storable value.
   Its value may be TRUE or FALSE. *)


(* Use of IN Operator *)

CONST [IN] supportsIN = FALSE;
(* Required constant to define whether the ADT supports the IN operator.
   Its value is always FALSE for Array ADTs. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the index/value pair limit of the ADT. *)

(* An expression of the form TLIMIT(ArrayADT))
   is synthesised as ArrayADT.capacityLimit(). *)


(* Binding to Predefined Function COUNT *)

PROCEDURE [COUNT] count ( array : ProtoArray ) : LONGCARD;
(* Required function to return the index/value count of an array. *)

(* An expression of the form COUNT(array)
   is synthesised as ArrayADT.count(array). *)


(* Memory Management *)

(* Binding to Predefined Procedure NEW *)

PROCEDURE [NEW] new
  ( VAR array : ProtoArray; values : ARGLIST OF ValueType );
(* Required procedure to allocate a new array and initialise it
   with zero or more given values. *)

(* A statement of the form NEW(array)
   is synthesised as ArrayADT.new(array).
   
   A statement of the form NEW(array, val1, val2, val3, ...)
   is synthesised as ArrayADT.new(array, val1, val2, val3, ...). *)


isMutable ->
PROCEDURE newWithCapacity
  ( VAR array : ProtoArray; capacity : LONGCARD );
(* Procedure to allocate a new array with a given initial capacity.
   The procedure is required when the ADT is mutable. *)


(* Binding to Predefined Procedure RETAIN *)

isRefCounted ->
PROCEDURE [RETAIN] retain ( VAR array : ProtoArray );
(* Procedure to retain an array and prevent its deallocation.
   The procedure is required when the ADT is reference counted. *)

(* A statement of the form RETAIN(array)
   is synthesised as ArrayADT.retain(array). *)


(* Binding to Predefined Procedure RELEASE *)

PROCEDURE [RELEASE] release ( VAR array : ProtoArray );
(* Required procedure to cancel an outstanding retain
   or deallocate an array if no retains are outstanding. *)

(* A statement of the form RELEASE(array)
   is synthesised as ArrayADT.release(array). *)


(* Literal Assignment *)

(* Binding to the := Operator *)

isMutable ->
PROCEDURE [:=] assignLiteral
  ( array : ProtoArray; literal : ARGLIST OF ValueType );
(* Procedure to destructively copy the contents of an array literal to an
   array. The procedure is required when the ADT is mutable. *)

(* A statement of the form
     array := { val1, val2, val3, ... };
   is synthesised as
     ArrayADT.assignLiteral(array, val1, val2, val3, ...). *)


(* Copying *)

(* Binding to Predefined Function DUP *)

PROCEDURE [DUP] newWithCopy ( source : ProtoArray ) : ProtoArray;
(* Required function to return a newly allocated copy of an array. *)

(* An expression of the form DUP(array)
   is synthesised as ArrayADT.newWithCopy(array). *)


(* Binding to Predefined Procedure COPY *)

isMutable ->
PROCEDURE [COPY] copy ( source : ProtoArray; VAR target : ProtoArray );
(* Procedure to destructively copy the contents of one array to another.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form COPY(array1, array2)
   is synthesised as ArrayADT.copy(array1, array2). *)


(* Value Storage *)

(* Binding to Predefined Procedure STORE *)

isMutable ->
PROCEDURE [STORE] storeValue
 ( VAR array : ProtoArray; index : IndexType; value : ValueType );
(* Procedure to store a value at a given index in an array.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form array[index] := value
   is equivalent to STORE(array, index, value) and
   is synthesised as ArrayADT.storeValue(array, index, value). *)


(* Value Retrieval *)

(* Binding to Predefined Function RETRIEVE *)

PROCEDURE [RETRIEVE] valueAtIndex
 ( array : ProtoArray; index : IndexType ) : ValueType;
(* Required function to return the value stored in an array at a given index. *)

(* An expression of the form array[index]
   is equivalent to RETRIEVE(array, index) and
   is synthesised as ArrayADT.valueAtIndex(array, index). *)


(* Index Out Of Range Retrieval Error Handling *)

(* A user defined index-out-of-range handler function may be used to change
   the default behaviour when RETRIEVE is called with an out-of-range index. *)

(* Handler Type *)

TYPE HandlerType = PROCEDURE ( VAR ValueType ) : BOOLEAN;
(* Required procedure type for user defined index-out-of-range handlers. *)

(* An example of an index-out-of-range handler is given below:
   
   PROCEDURE mayAbortOnIndexOutOfRange
     ( VAR valueToReturn : CARDINAL ) : BOOLEAN;
   BEGIN
     valueToReturn := 0;
     RETURN FALSE
   END mayAbortOnIndexOutOfRange;
   
   This handler tells its caller not to abort and to return zero. *)


(* Handler Installation *)

PROCEDURE installIndexOutOfRangeHandler ( handler : HandlerType );
(* Required procedure to install a user defined index-out-of-range handler. *)


(* Value Insertion *)

(* Binding to Predefined Procedure INSERT *)

isMutable ->
PROCEDURE [INSERT] insertValuesAtIndex
  ( targetArray : ProtoArray;
    index : IndexType;
    values : ARGLIST OF ValueType );
(* Procedure to insert a value list into a target array at a given index.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     INSERT(array, index, val1, val2, val3, ...)
   is synthesised as
     ArrayADT.insertValuesAtIndex(array, index, val1, val2, val3, ...). *)


isMutable ->
PROCEDURE insertArrayAtIndex
  ( targetArray : ProtoArray; index : IndexType; sourceArray : ProtoArray );
(* Procedure to insert a source array into a target array at a given
   index. The procedure is required when the ADT is mutable. *)


(* Value Removal *)

(* Binding to Predefined Procedure REMOVE *)

isMutable ->
PROCEDURE [REMOVE] removeValuesAtIndex
  ( array : ProtoArray; index : IndexType; valueCount : LONGCARD );
(* Procedure to remove one or more values from an array at a given index.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     REMOVE(array, index, n);
   is synthesised as
     ArrayADT.removeValuesAtIndex(array, index, n).
   
   A statement of the form
     array[index] := NIL
   is treated equivalent to
     REMOVE(array, index, 1)
   if a constant of value TRUE is bound to NIL. *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoArray, CONST IndexType );
(* Required procedure type to synthesise the body of a for loop. *)

PROCEDURE [FOR] forIterator
  ( VAR array : ProtoArray; doStatements : LoopBodyType; ascending : BOOLEAN );

(* Required procedure to iterate over all index/value pairs of an array
   in a given order and execute the passed in doStatements for each pair. *)
   
(* A statement of the form
     FOR index IN array DO statementSeq END
   is synthesised in two steps.
   
   The loop header is synthesised as
     ArrayADT.forIterator( array, forLoopBody, TRUE );
   
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR array : ArrayADT; CONST index : IndexType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   
   The loop header of a FOR DESCENDING statement is sythesised with
   FALSE passed for parameter ascending in the call to forIterator. *)


(* Relational Operations *)

(* Binding to the = and # Operators *)

PROCEDURE [=] isEqual ( array1, array2 : ProtoArray ) : BOOLEAN;
(* Required function to test the equivalence of two arrays. *)

(* An expression of the form array1 = array2
   is synthesised as ArrayADT.isEqual(array1, array2). *)

(* The operation for the # operator
   is synthesized as NOT (array1 = array2). *)


(* Conditionally Inhibited Bindings *)


(* Conforming blueprints may not require bindings to any of
   :=, COPY, STORE, INSERT and REMOVE if the ADT is immutable. *)

NOT isMutable -> PROCEDURE [:=] : NIL;

NOT isMutable -> PROCEDURE [COPY] : NIL;

NOT isMutable -> PROCEDURE [STORE] : NIL;

NOT isMutable -> PROCEDURE [INSERT] : NIL;

NOT isMutable -> PROCEDURE [REMOVE] : NIL;


(* Conforming blueprints may not require bindings to
   RETAIN and CONCAT if the ADT is not reference counted. *)

NOT isRefCounted -> PROCEDURE [RETAIN] : NIL;

NOT isRefCounted -> PROCEDURE [CONCAT] : NIL;


(* Unconditionally Inhibited Bindings *)

(* Numeric Properties *)

(* Numeric properties are not meaningful for Array ADTs.
   Conforming blueprints may not require bindings to these properties. *)

CONST [TSIGNED] : NIL; (* TSIGNED is inhibited *)

CONST [TBASE] : NIL; (* TBASE is inhibited *)

CONST [TPRECISION] : NIL; (* TPRECISION is inhibited *)

CONST [TMINEXP] : NIL; (* TMINEXP is inhibited *)

CONST [TMAXEXP] : NIL; (* TMAXEXP is inhibited *)


(* Introspection *)

(* Operations TMIN and TMAX are not meaningful for Array ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [TMIN] : NIL; (* TMIN is inhibited *)

PROCEDURE [TMAX] : NIL; (* TMAX is inhibited *)


(* Arithmetic Operations *)

(* Arithmetic operations are not meaningful for Array ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [ABS] : NIL; (* ABS is inhibited *)

PROCEDURE [NEG] : NIL; (* NEG is inhibited *)

PROCEDURE [+] : NIL; (* Addition is inhibited *)

PROCEDURE [-] : NIL; (* Subtraction is inhibited *)

PROCEDURE [*] : NIL; (* Multiplication is inhibited *)

PROCEDURE [/] : NIL; (* Division is inhibited *)

PROCEDURE [DIV] : NIL; (* DIV is inhibited *)

PROCEDURE [MOD] : NIL; (* MOD is inhibited *)


(* Arithmetic Conversion *)

(* Arithmetic conversions are not meaningful for Array ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [SXF] : NIL; (* SXF is inhibited *)

PROCEDURE [VAL] : NIL; (* VAL is inhibited *)


(* Relational Operations *)

(* Relational operations >, >=, < and <= are not meaningful for Array ADTs.
   Conforming blueprints may not require bindings to these operations. *)

PROCEDURE [<] : NIL; (* less-than inhibited *)

PROCEDURE [>] : NIL; (* greater-than inhibited *)

(* The SUBSET operation is not meaningful for array ADTs.
   Conforming blueprints may not require a binding to it. *)

PROCEDURE [SUBSET] : NIL; (* SUBSET inhibited *)


END ProtoArray.