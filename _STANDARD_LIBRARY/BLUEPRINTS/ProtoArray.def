(* (C) 2009-2015 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Dynamically Allocatable Array ADTs *)

BLUEPRINT ProtoArray [ProtoCollection];

REFERENTIAL IndexType, ValueType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE;

LITERAL = { ARGLIST OF ValueType };
(* Array literals with a variable number of values are compatible. *)


(* Required Constants *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether conforming ADTs should implement
   reference counting.  Its value may be TRUE or FALSE. *)


(* Concatenation and Slicing *)

CONST supportsConcatAndSlicing : BOOLEAN;
(* Required constant to define whether conforming ADTs should implement
   concatenation and slicing.  Its value may be TRUE or FALSE. *)


(* NIL Storage *)

CONST [TNIL] supportsNilStorage : BOOLEAN;
(* Required constant to define whether conforming ADTs should treat
(* NIL as a storable value.  Its value may be TRUE or FALSE. *)

(* This value may be queried by invoking TNIL(ArrayADT) *)


(* Iteration Order *)

CONST [TBIDI] bidirectionalIteration = TRUE;
(* Required constant to define whether conforming ADTs support bidirectional
   FOR loop iteration.  Its value is always TRUE for Array ADTs. *)

(* This value may be queried by invoking TBIDI(ArrayADT) *)


(* Support for Invalid Accessor Retrieval Intercept *)

CONST * invAccessorRetrievalIntercept = TRUE;
(* Required constant to define whether invalid accessor retrieval errors may
   be intercepted by user defined handlers.  Always TRUE for Array ADTs. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the index/value pair limit of the ADT. *)

(* Supports use case: TLIMIT(ArrayADT) *)


(* Binding to Predefined Function COUNT *)

PROCEDURE [COUNT] count ( array : ProtoArray ) : LONGCARD;
(* Required function to return the number of values stored in an array. *)

(* Supports use case: COUNT(array)  *)


PROCEDURE capacity ( array : ProtoArray ) : LONGCARD;
(* Required function to return the allocated capacity of an array. *)

PROCEDURE entryLimit ( array : ProtoArray ) : LONGCARD;
(* Required function to return the value limit of an array. *)

PROCEDURE isResizable ( array : ProtoArray ) : BOOLEAN;
(* Required function to return the resizable property of an array. *)


(* Memory Management *)

(* Binding to NEW *)

PROCEDURE [NEW] new
  ( NEW newArray : ProtoArray; initialCapacity : LONGCARD );
(* Required procedure to allocate a new array with a default or given initial
   capacity. *)

(* Supports use cases:
   
   NEW array;
   
   NEW array OF capacity;
   
   and in combination with binding to COPY:
   
   NEW array := initValue; *)


(* Binding to RETAIN *)

isRefCounted ->
PROCEDURE [RETAIN] retain ( array : ProtoArray );
(* Procedure to retain an array and prevent its deallocation.
   Required when reference counting is supported. *)

(* Supports use case:
   
   RETAIN array; *)


(* Binding to RELEASE *)

PROCEDURE [RELEASE] release ( array : ProtoArray );
(* Required procedure to cancel an outstanding retain and ultimately deallocate an array
   when no further retains are outstanding or immediately when reference counting is not
   supported. *)

(* Supports use case:
   
   RELEASE array; *)


(* Copying *)

(* Binding to COPY *)

PROCEDURE [COPY] copyValues
  ( VAR target : ProtoArray; values : ARGLIST OF ValueType );
(* Required procedure to destructively update a target array from a given value list. *)

(* Supports use cases of the form:
      
   COPY array := { val1, val2, val3, ... };
   
   and in combination with binding to NEW:
   
   NEW array := { val1, val2, val3, ... }; *)


NOT supportsConcatAndSlicing ->
PROCEDURE [COPY*] copyArray ( VAR target : ProtoArray; source : ProtoArray );
(* Procedure to destructively update a target array from a given source array.
   Required when slicing is not supported. *)

(* Supports use cases:
   
   COPY target := source;
   
   and in combination with binding to NEW:
   
   NEW array := source; *)


supportsConcatAndSlicing ->
PROCEDURE [COPY*] copyArrayOrSlice
  ( VAR target : ProtoArray; source : ProtoArray; start, end : INTEGER );
(* Procedure to destructively update a target array from a given source array
   or slice.  Required when slicing is supported. *)

(* Supports use cases:
   
   COPY target := source;
   
   COPY target := source[n..m];
   
   and in combination with binding to NEW:
   
   NEW array := source;
   
   NEW array := source[n..m]; *)


supportsConcatAndSlicing ->
PROCEDURE [COPY+] copyArraysOrSlices
  ( VAR target : ProtoArray;
    source : ARGLIST OF { array : ProtoArray; start, end : INTEGER } );
(* Procedure to destructively update a target array with a concatenation of given
   source arrays and slices.  Required when concatenation and slicing is supported. *)

(* Supports use cases of the form:

   COPY target := arrayConcatenation;
   
   where ...
   
   arrayConcatenation : term ( '+>' term )* ;
   term : arraySlice | array ;
   arraySlice : array '[' start '..' end ']' ;
   start, end : integerExpression ;
   array : qualident ; *)


supportsConcatAndSlicing ->
PROCEDURE [COPY++] copyArrayExpression
  ( VAR target : ProtoArray;
    source : ARGLIST OF
      { array : ProtoArray;
        start, end : INTEGER;
        values : ARRAY OF ValueType } );
(* Procedure to destructively update a target array with an array expression evaluation.
   Required when concatenation and slicing is supported. *)

(* Supports use cases of the form:
   
   COPY target := arrayExpression;
   
   where ...
   
   arrayExpression : term ( '+>' term )* ;
   term : valueList | arraySlice | array ;
   valueList : '{' value ( ',' value )* '}' ;
   arraySlice : array '[' start '..' end ']' ;
   start, end : integerExpression ;
   value : qualident | expression ;
   array : qualident; *)


(* Insertion *)

(* Binding to INSERT *)

PROCEDURE [INSERT] insertValues
  ( VAR target : ProtoArray; atIndex : INTEGER; values : ARGLIST OF ValueType );
(* Required procedure to insert values from a given value list at a given index
   into an array. *)

(* Supports use cases:

   INSERT(target, n, val1, val2, val3, ...);
   
   COPY target[n..] := { val1, val2, val3, ... }; *)


NOT supportsConcatAndSlicing ->
PROCEDURE [INSERT*] insertArray
  ( VAR target : ProtoArray; atIndex : INTEGER; source : ProtoArray );
(* Procedure to insert the values of a given source array at a given index
   into a target array.  Required when slicing is not supported. *)

(* Supports use case:

   COPY target[n..] := source; *)


supportsConcatAndSlicing ->
PROCEDURE [INSERT*] insertArrayOrSlice
  ( VAR target : ProtoArray; atIndex : INTEGER;
        source : ProtoArray; start, end : INTEGER );
(* Procedure to insert the values of a given source array or slice at a given
   index into a target array.  Required when slicing is supported. *)

(* Supports use cases:

   COPY target[n..] := source;

   COPY target[n..] := source[m..p]; *)


supportsConcatAndSlicing ->
PROCEDURE [INSERT+] insertArraysOrSlices
  ( VAR target : ProtoArray; atIndex : INTEGER;
    source : ARGLIST OF { array : ProtoArray; start, end : INTEGER } );
(* Procedure to insert a concatenation of given source arrays and slices
   at a given index into a target array.  Required when concatenation and
   slicing is supported. *)

(* Supports use cases of the form:

   COPY target[n..] := arrayConcatenation;
   
   where ...
   
   arrayConcatenation : term ( '+>' term )* ;
   term : arraySlice | array ;
   arraySlice : array '[' start '..' end ']' ;
   start, end : integerExpression ;
   array : qualident ; *)


supportsConcatAndSlicing ->
PROCEDURE [INSERT++] insertArrayExpression
  ( VAR target : ProtoArray; atIndex : INTEGER;
    source : ARGLIST OF
      { array : ProtoArray; start, end : INTEGER;
        values : ARRAY OF ValueType } );
(* Procedure to insert the values of an array expression evaluation
   at a given index into a target array.  Required when concatenation
   and slicing is supported. *)

(* Supports use cases of the form:
   
   COPY target[n..] := arrayExpression;
   
   where ...
   
   arrayExpression : term ( '+>' term )* ;
   term : valueList | arraySlice | array ;
   valueList : '{' value ( ',' value )* '}' ;
   arraySlice : array '[' start '..' end ']' ;
   start, end : integerExpression ;
   value : qualident | expression ;
   array : qualident; *)


(* L-Value Slicing *)

(* Binding to .. *)

supportsConcatAndSlicing ->
PROCEDURE [..] updateSliceWithValues
  ( VAR target : ProtoArray; start, end : INTEGER; values : ARGLIST OF ValueType );
(* Procedure to destructively update a slice of a target array from a given value
   list.  Required when slicing is supported. *)

(* Supports use case:
   
   COPY target[n..m] := { val1, val2, val3, ... }; *)


supportsConcatAndSlicing ->
PROCEDURE [..*] updateSliceWithArrayOrSlice
  ( VAR target : ProtoArray; tgtStart, tgtEnd : INTEGER;
        source : ProtoArray; srcStart, srcEnd : INTEGER );
(* Procedure to destructively update a slice of a target array with the values
   of a given source array or slice.  Required when slicing is supported. *)

(* Supports use cases:
   
   COPY target[n..m] := source;
   
   COPY target[n..m] := source[p..q]; *)


supportsConcatAndSlicing ->
PROCEDURE [..+] updateSliceWithArraysOrSlices
  ( VAR target : ProtoArray; tgtStart, tgtEnd : INTEGER;
        source : ARGLIST OF { array : ProtoArray; start, end : INTEGER } );
(* Procedure to destructively update a slice of a target array with a
   concatenation of given source arrays and slices.  Required when
   concatenation and slicing is supported. *)

(* Supports use cases of the form:
   
   COPY target[n..m] := arrayConcatenation;
   
   where ...
   
   arrayConcatenation : term ( '+>' term )* ;
   term : arraySlice | array ;
   arraySlice : array '[' start '..' end ']' ;
   start, end : integerExpression ;
   array : qualident ; *)


supportsConcatAndSlicing ->
PROCEDURE [..++] updateSliceWithArrayExpression
  ( VAR target : ProtoArray; tgtStart, tgtEnd : INTEGER;
    source : ARGLIST OF
      { array : ProtoArray; start, end : INTEGER;
        values : ARRAY OF ValueType } );
(* Procedure to destructively update a slice of a target array with a given
   array expression evaluation.  Required when concatenation and slicing is
   supported. *)

(* Supports use cases of the form:
   
   COPY target[n..m] := arrayExpression;
   
   where ...
   
   arrayExpression : term ( '+>' term )* ;
   term : valueList | arraySlice | array ;
   valueList : '{' value ( ',' value )* '}' ;
   arraySlice : array '[' start '..' end ']' ;
   start, end : integerExpression ;
   value : qualident | expression ;
   array : qualident; *)


(* Conversion of Built-in Arrays *)

NOT supportsConcatAndSlicing ->
PROCEDURE [ARRAY] convertBuiltinArray
  ( VAR array : ProtoArray; CONST from : ARRAY OF ValueType );
(* Procedure to destructively update a target array with the values of a
   given static array with matching value type.  Required when slicing
   is not supported. *)

(* Supports use cases:
   
   COPY array := builtinArray;
   
   and in combination with binding to NEW:
   
   NEW target := builtinArray;
   
   where builtinArray is any array of a static array type constructed
   using ARRAY OF type constructor with a matching value type. *)


supportsConcatAndSlicing ->
PROCEDURE [ARRAY] convertBuiltinArrayOrSlice
  ( VAR array : ProtoArray;
    CONST from : ARRAY OF ValueType; start, end : INTEGER );
(* Procedure to destructively update a target array with the values of a
   given static array or slice thereof with matching value type.  Required
   when slicing is supported. *)

(* Supports use cases:
   
   COPY target := builtinArray;
   
   COPY target := builtinArray[n..m];
   
   and in combination with binding to NEW:
   
   NEW target := builtinArray;
   
   NEW target := builtinArray[n..m];
   
   where builtinArray is any array of a static array type constructed
   using ARRAY OF type constructor with a matching value type. *)


(* Value Storage *)

(* Binding to STORE *)

PROCEDURE [STORE] storeValue
 ( array : ProtoArray; index : IndexType; value : ValueType );
(* Required procedure to store a value at a given index in an
   array. *)

(* A statement of the form array[index] := value
   is equivalent to STORE(array, index, value) and
   is synthesised as ArrayADT.storeValue(array, index, value). *)


(* Value Retrieval *)

(* Binding to RETRIEVE *)

PROCEDURE [RETRIEVE] valueAtIndex
 ( array : ProtoArray; index : IndexType ) : ValueType;
(* Required function to return the value stored in an array at a given index. *)

(* An expression of the form array[index]
   is equivalent to RETRIEVE(array, index) and
   is synthesised as ArrayADT.valueAtIndex(array, index). *)


(* Index Out Of Range Retrieval Error Handling *)

(* A user defined index-out-of-range handler function may be used to change
   the default behaviour when RETRIEVE is called with an out-of-range index. *)

(* Handler Type *)

invAccessorRetrievalIntercept ->
TYPE HandlerType = PROCEDURE ( VAR ValueType ) : BOOLEAN;
(* Procedure type for user defined index-out-of-range handlers.
   The type is required when invAccessorRetrievalIntercept is TRUE. *)


(* An example of an index-out-of-range handler is given below:
   
   PROCEDURE mayAbortOnIndexOutOfRange
     ( VAR valueToReturn : CARDINAL ) : BOOLEAN;
   BEGIN
     valueToReturn := 0;
     RETURN FALSE
   END mayAbortOnIndexOutOfRange;
   
   This handler tells its caller not to abort and to return zero. *)


(* Handler Installation *)

invAccessorRetrievalIntercept ->
PROCEDURE installIndexOutOfRangeHandler ( handler : HandlerType );
(* Procedure to install a user defined index-out-of-range handler.
   The procedure is required when invAccessorRetrievalIntercept is TRUE. *)


(* Value Removal *)

(* Binding to REMOVE *)

PROCEDURE [REMOVE] removeValue
  ( array : ProtoArray; atIndex : IndexType );
(* Required procedure to remove a value from an array at a given index. *)

(* Supports use case:
   
   REMOVE(array, n);
   
   further, if TNIL(ArrayADT) is FALSE, the alternative syntax:
   
   array[n] := NIL; *)


PROCEDURE [REMOVE*] removeAllValues ( array : ProtoArray );
(* Required procedure to remove all values from an array. *)

(* Supports use case:
      
   COPY array := EMPTY; *)


PROCEDURE [REMOVE+] removeValuesInRange
  ( array : ProtoArray; start, end : IndexType );
(* Required procedure to remove one or more values from an array. *)

(* Supports use cases:
      
   REMOVE(array, n, m);
   
   further, if slicing is supported, the alternative syntax:
   
   COPY array[n..m] := EMPTY; *)


(* Iteration *)

(* Binding to FOR *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoArray, CONST IndexType );
(* Required procedure type to synthesise the body of a for loop. *)

PROCEDURE [FOR] forIterator
  ( VAR array : ProtoArray; doStatements : LoopBodyType; ascending : BOOLEAN );

(* Required procedure to iterate over all index/value pairs of an array
   in a given order and execute the passed in doStatements for each pair. *)
   
(* A statement of the form
     FOR index IN array DO statementSeq END
   is synthesised in two steps.
   
   The loop header is synthesised as
     ArrayADT.forIterator(array, forLoopBody, TRUE);
   
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR array : ArrayADT; CONST index : IndexType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   
   The loop header of a FOR DESCENDING statement is sythesised with
   FALSE passed for parameter ascending in the call to forIterator. *)


(* Relational Operations *)

(* Binding to the = and # Operators *)

PROCEDURE [=] isEqual ( array1, array2 : ProtoArray ) : BOOLEAN;
(* Required function to test the equivalence of two arrays. *)

(* An expression of the form array1 = array2
   is synthesised as ArrayADT.isEqual(array1, array2). *)

(* The operation for the # operator
   is synthesized as NOT (array1 = array2). *)


(* Conditionally Inhibited Bindings *)

(* None *)


(* Unconditionally Inhibited Bindings *)

(* Arithmetic Operations *)

(* Arithmetic operations +, -, *, and / are not meaningful for Array ADTs.
   Conforming blueprints may not require binding to these operations. *)

PROCEDURE [+] = NONE; (* inhibited *)

PROCEDURE [-] = NONE; (* inhibited *)

PROCEDURE [*] = NONE; (* inhibited *)

PROCEDURE [/] = NONE; (* inhibited *)


(* Relational Operations *)

(* Relational operations >, >=, < and <= are not meaningful for Array ADTs.
   Conforming blueprints may not require binding to these operations. *)

PROCEDURE [<] = NONE; (* inhibited *)

PROCEDURE [>] = NONE; (* inhibited *)

(* The SUBSET operation is not meaningful for array ADTs.
   Conforming blueprints may not require binding to SUBSET. *)

PROCEDURE [SUBSET] = NONE; (* inhibited *)


END ProtoArray.