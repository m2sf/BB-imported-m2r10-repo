(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Dynamically Allocatable String ADTs *)

BLUEPRINT ProtoString [ProtoCollection];

REFERENTIAL CharType (* CHAR or UNICHAR *), POSINT, ForLoopBodyProc;

(* String ADTs must be opaque,
   quoted literals of base type CHAR or UNICHAR are compatible *)

MODULE TYPE = OPAQUE := CHAR | UNICHAR;


(* Bindings required for String ADTs *)


(* Required Constants *)

CONST [:=] isMutable : BOOLEAN;
(* whether the ADT is mutable *)

CONST [DESCENDING] isOrdered = TRUE;
(* String ADTs are always ordered *)


(* Required Procedures *)

(* Capacity limit *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the allocation capacity limit of a string ADT. *)

(* An invocation of TLIMIT(StringADT)) is transformed at compile time to
   StringADT.capacityLimit() when the operand is of the string ADT type. *)


(* Memory Management *)

PROCEDURE [NEW] new
  ( VAR s : ProtoString; initWith : ARRAY OF CharType );
(* Required procedure to allocate and initialise a new string. *)

(* A statement of the form
     NEW(string);
   is transformed at compile time to a procedure call of the form
     StringADT.new(string);
   for operands of the string ADT type.
   
   A statement of the form
     NEW(string, "foo bar baz");
   is transformed at compile time to a procedure call of the form
     StringADT.new(string, "foo bar baz");
   for operands of the string ADT type. *)


PROCEDURE [RETAIN] retain ( VAR s : ProtoString );
(* Required procedure to retain a string ADT variable. *)

(* A statement of the form
     RETAIN(string);
   is transformed at compile time to a procedure call of the form
     StringADT.retain(string);
   for operands of the string ADT type. *)


PROCEDURE [RELEASE] release ( VAR s : ProtoString );
(* Required procedure to release and eventually deallocate a string. *)

(* A statement of the form
     RELEASE(string);
   is transformed at compile time to a procedure call of the form
     StringADT.release(string);
   for operands of the string ADT type. *)


(* Assignment and Copying *)

PROCEDURE [:=] NEW;
(* Procedure bound to NEW will be used for literal assignment. *)

(* A statement of the form
     string := "foo bar baz";
   is transformed at compile time into a procedure call of the form
     StringADT.new(string, "foo bar baz");
   for L-values of the string ADT type. *)


PROCEDURE [DUP] duplicateOf ( string : ProtoString ) : ProtoString;
(* Reuired procedure to return a duplicate of a string. *)

(* An expression of the form
     DUP(string)
   is transformed at compile time into a function call of the form
     StringADT.duplicateOf(string)
   for operands of the string ADT type. *)


(* Storage, Retrieval, Insertion and Removal of Contents *)

PROCEDURE [STORE] replaceCharAtIndex
  ( string : ProtoString;
    index : INTEGER; char : CharType );
(* Required procedure to replace a char at a given index in a string *)

(* A statement of the form
     STORE(string, index, char);
   is transformed at compile time into a procedure call of the form
     StringADT.replaceCharAtIndex(string, index, char);
   for first operands of the string ADT type.
   
   An assignment of the form
     string[index] := char;
   is transformed at compile time into a procedure call of the form
     StringADT.replaceCharAtIndex(string, index, char);
   for designators of the string ADT type. *)


PROCEDURE [RETRIEVE] charAtIndex
  ( string : ProtoString; index : INTEGER ) : CharType;
(* Required procedure to return the char at a given index in a string. *)

(* An expression of the form
     RETRIEVE(string, index)
   is transformed at compile time into a function call of the form
     StringADT.charAtIndex(string, index)
   for first operands of the string ADT type.
   
   An expression of the form
     string[index]
   is transformed at compile time into a function call of the form
     StringADT.charAtIndex(string, index)
   for designators of the string ADT type. *)


PROCEDURE [INSERT] insertCharsAtIndex
  ( targetStr : ProtoString; index : INTEGER; chars : ARRAY OF CharType );
(* Required procedure to insert a character array into a target string,
   starting at a given index. *)

(* A statement of the form
     INSERT(string, index, "foo");
   is transformed at compile time into a procedure call of the form
     StringADT.insertCharsAtIndex(string, index, "foo");
   for designators of the string ADT type. *)


PROCEDURE [INSERT] insertStringAtIndex
  ( targetStr : ProtoString; index : INTEGER; sourceStr : ProtoString );
(* Required procedure to insert a source string into a target string,
   starting at a given index. *)

(* A statement of the form
     INSERT(targetStr, index, sourceStr);
   is transformed at compile time into a procedure call of the form
     StringADT.insertStringAtIndex(targetStr, index, stringStr);
   for designators of the string ADT type. *)


PROCEDURE [REMOVE] removeCharsAtIndex
  ( string : ProtoString; index : INTEGER; n : POSINT );
(* Required rocedure to remove n characters from a string,
   starting at a given index. *)

(* A statement of the form
     REMOVE(string, index, 5);
   is transformed at compile time into a procedure call of the form
     StringADT.removeCharsAtIndex(string, index, 5);
   for first operands of the string ADT type.
   
   An assignment of the form
     string[index] := NIL;
   is transformed at compile time into a procedure call of the form
     StringADT.removeCharsAtIndex(string, index, 1);
   for designators of the string ADT type. *)


(* Introspection *)

PROCEDURE [LENGTH] length ( string : ProtoString ) : POSINT;
(* Required procedure to return the length of a string. *)

(* An expression of the form
     LENGTH(string)
   is transformed at compile time to a function call of the form
     StringADT.count(string)
   for operands of the string ADT type. *)


(* Concatenation and Slicing *)

PROCEDURE [CONCAT] concat
  ( VAR result : ProtoString;
    arglist : ARGLIST OF { lit : ARRAY OF CharType; s : ProtoString } );
(* Required procedure to concatenate an alternating list of character string
   literals and string ADT variables, and return a newly allocated result
   string. Empty literals and NIL values in the argument list are ignored. *)

(* Concatenation of consecutive string literals takes place at compile time.
   Thus, string literals do not occur consecutively in run time expressions.
      
   Invocations of CONCAT are mapped to procedure StringADT.concat as follows:
   
   A statement of the form
     CONCAT(resultStr, str1, str2);
   is transformed at compile time into a procedure call of the form
     StringADT.concat(resultStr, "", str1, "", str2);

   A statement of the form
     CONCAT(resultStr, str1, "literal", str2);
   is transfored at compile time into a procedure call of the form
     StringADT.concat(resultStr, "", str1, "lit", str2);
      
   A statement of the form
     CONCAT(resultStr, "lit", str1, str2);
   is transformed at compile time into a procedure call of the form
     StringADT.concat(resultStr, "lit", str1, "", lit2);
   
   A statement of the form
     CONCAT(resultStr, "lit1", str, "lit2")
   is transformed at compile time into a procedure call of the form
     StringADT.concat(resultStr, "lit1", str, "lit2", NIL);
   
   When a concatenation expression is passed as an argument to a procedure
   it is first assigned to a temporary variable,  which is then passed as
   a parameter in the subsequent procedure call and finally released.
   
   A procedure invocation of the form
     FooProc(str1 + str2);
   is transformed at compile time into a temporary variable declaration
     VAR tempResult : StringADT;
   and a statement sequence of the form
     CONCAT(tempResult, str1, str2);
     FooProc(tempResult); RELEASE(tempResult);
   
   A function invocation of the form
     foo := BarFunc(str1 + str2);
   is transformed at compile time into a temporary variable declaration
     VAR tempResult : StringADT;
   and a statement sequence of the form   
     CONCAT(tempResult, str1, str2);
     foo := BarFunc(tempResult); RELEASE(tempResult); *)


PROCEDURE [..] copySlice
  ( VAR target : ProtoString; tgtStartIndex, tgtEndIndex : INTEGER;
    source : ProtoString; srcStartIndex, srcEndIndex : INTEGER );
(* Required procedure to copy a slice from a source string, indicated by
   a given start and end index,  into a slice within a target string,
   indicated by a given start and end index.  If target is NIL and the
   target indices are 0 and -1, a newly allocated string is to be passed
   back in target as result.
   Consult the documentation for specific details. *)

(* An assignment of the form
     target := source[2..5];
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 0, -1, source, 2, 5);
   
   An assignment of the form
     target[2..5] := source;
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 2, 5, source, 0, -1);
   
   An assignment of the form
     target[1..4] := source[2..5];
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 1, 4, source, 2, 5);
   
   When a slice expression is passed as an argument to a procedure, it is
   first assigned to a temporary variable,  which is then passed as a
   parameter in the subsequent procedure call and finally released.

   A procedure invocation of the form
     FooProc(string[2..5]);
   is transformed at compile time into a temporary variable declaration
     VAR tempTarget : StringADT;
   and a statement sequence of the form
     StringADT.copySlice(tempTarget, 0, -1, string, 2, 5);
     FooProc(tempTarget); RELEASE(tempTarget);
   
   A function invocation of the form
     foo := BarFunc(string[2..5]);
   is transformed at compile time into a temporary variable declaration
     VAR tempTarget : StringADT;
   and a statement sequence of the form
     StringADT.copySlice(tempTarget, 0, -1, string, 2, 5);
     foo := BarFunc(tempTarget); RELEASE(tempTarget); *)


(* Iteration *)

TYPE ProcType = PROCEDURE ( ProtoString; CONST IndexType );
(* Required procedure type to represent a FOR loop body. *)

PROCEDURE [FOR] forIterator
  ( s : ProtoString; forLoopBody : ProcType; ascending : BOOLEAN );
(* Required procedure to iterate over all characters in a string,
   executing procedure forLoopBody for each index value,
   using the iteration order indicated by ascending. *)

   
(* A statement of the form
     FOR index IN string DO statementSeq END
   is transformed at compile time in two steps:
   
   The FOR loop header is transformed into a procedure call of the form
     StringADT.forIterator(string, forLoopBody, TRUE);
   
   The FOR loop body is transformed into a procedure declaration of the form
     PROCEDURE forLoopBody ( string : StringADT; CONST index : IndexType );
     BEGIN statementSeq END forLoopBody;
   
   A FOR DESCENDING loop header is transformed into a call of the form
     StringADT.forIterator(string, forLoopBody, FALSE);

   The use of FOR DESCENDING syntax is dependent on property isOrdered.
   If an ADT defines isOrdered as FALSE, the use of FOR DESCENDING is
   not permitted and will cause a compile time error. *)


(* Relational Operations *)

PROCEDURE [=] isEqual ( string1, string2 : ProtoString ) : BOOLEAN;
(* Required procedure to test the equivalence of two strings. *)

(* An expression of the form
     string1 = string2
   is transformed at compile time into a function call of the form
     StringADT.isEqual(string1, string2)
   for L- and R-values of the string ADT type. *)

(* The operation for the # operator
   is synthesized as NOT (string1 = string2) *)


PROCEDURE [<] isLess ( string1, string2 : ProtoString ) : BOOLEAN;
(* Required procedure to test if the value of a string comes lexically
   after another. *)

(* An expression of the form
     string1 < string2
   is transformed at compile time into a function call of the form
     StringADT.isLess(string1, string2)
   for L- and R-values of the string ADT type. *)

(* The operation for the <= operator
   is synthesized as NOT (string1 > string2) *)


PROCEDURE [>] isGreater ( string1, string2 : ProtoString ) : BOOLEAN;
(* Required procedure to test if the value of a string comes lexically
   before another. *)

(* An expression of the form
     string1 > string2
   is transformed at compile time into a function call of the form
     StringADT.isGreater(string1, string2)
   for L- and R-values of the string ADT type. *)

(* The operation for the >= operator
   is synthesized as NOT (string1 < string2) *)


END ProtoString.