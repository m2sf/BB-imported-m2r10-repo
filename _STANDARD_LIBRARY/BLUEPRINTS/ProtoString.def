(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Dynamically Allocatable String ADTs *)

BLUEPRINT ProtoString [ProtoCollection];

REFERENTIAL POSINT (* index type *),
  CharType (* value type CHAR or UNICHAR *), HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE := CHAR | UNICHAR;
(* String ADTs must be opaque,
   quoted literals of base type CHAR or UNICHAR are compatible *)


(* Required Constants *)


(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT is mutable.
   Its value may be TRUE or FALSE. *)


(* Orderedness *)

(* Use of FOR DESCENDING syntax with the ADT is only permitted
   when a constant is bound to DESCENDING and its value is TRUE. *)

CONST [DESCENDING] isOrdered = TRUE;
(* Required constant to define whether the ADT is ordered.
   Its value is always TRUE for String ADTs. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether the ADT is reference counted.
   Its value may be TRUE or FALSE. *)


(* Semantics of NIL Assignment *)

CONST [NIL] nilRemovesValue = TRUE;
(* Required constant to define whether NIL assignment is treated as
   a call to REMOVE. The constant is always TRUE for String ADTs. *)


(* Sliceability *)

CONST isSliceable = isMutable AND isRefCounted;
(* Required constant indicating whether the ADT supports slicing.
   Its value is TRUE if the ADT is both mutable and reference counted. *)


(* Required Procedures *)

(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the index/value pair limit of the ADT. *)

(* An expression of the form TLIMIT(StringADT))
   is synthesised as StringADT.capacityLimit(). *)


(* Binding to Predefined Function LENGTH *)

PROCEDURE [LENGTH] length ( string : ProtoString ) : LONGCARD;
(* Required function to return the length of a string. *)

(* An expression of the form LENGTH(string)
   is synthesised as ArrayADT.length(string). *)


(* Memory Management *)

PROCEDURE [NEW] new
  ( VAR string : ProtoString; initWith : ARRAY OF CharType );
(* Required procedure to allocate and initialise a new string. *)

(* A statement of the form NEW(string)
   is synthesised as StringADT.new(string).
   
   A statement of the form NEW(string, "foo bar baz")
   is synthesised as StringADT.new(string, "foo bar baz").  *)


isMutable ->
PROCEDURE newWithCapacity
  ( VAR string : ProtoString; capacity : POSINT );
(* Procedure to allocate a new string with a given initial capacity.
   The procedure is required when the ADT is mutable. *)


(* Binding to Predefined Procedure RETAIN *)

isRefCounted ->
PROCEDURE [RETAIN] retain ( VAR string : ProtoString );
(* Procedure to retain an array and prevent its deallocation.
   The procedure is required when the ADT is reference counted. *)

(* A statement of the form RETAIN(string)
   is synthesised as StringADT.retain(string). *)


(* Binding to Predefined Procedure RELEASE *)

PROCEDURE [RELEASE] release ( VAR string : ProtoString );
(* Required procedure to cancel an outstanding retain
   or deallocate a string if no retains are outstanding. *)

(* A statement of the form RELEASE(string)
   is synthesised as StringADT.release(string). *)


(* Literal Assignment *)

(* Binding to the := Operator *)

isMutable ->
PROCEDURE [:=] assignLiteral
  ( string : ProtoString; literal : ARRAY OF CharType );
(* Procedure to destructively copy the contents of a string literal to a
   string. The procedure is required when the ADT is mutable. *)

(* A statement of the form
     string := "foo bar baz";
   is synthesised as
     StringADT.assignLiteral(string, "foo bar baz"). *)


(* Copying *)

(* Binding to Predefined Function DUP *)

PROCEDURE [DUP] newWithCopy ( source : ProtoString ) : ProtoString;
(* Required function to return a newly allocated copy of a string. *)

(* An expression of the form DUP(string)
   is synthesised as StringADT.newWithCopy(string). *)


(* Binding to Predefined Procedure COPY *)

isMutable ->
PROCEDURE [COPY] copy ( source : ProtoString; VAR target : ProtoString );
(* Procedure to destructively copy the contents of one string to another.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form COPY(string1, string2)
   is synthesised as StringADT.copy(string1, string2). *)


(* Value Storage *)

(* Binding to Predefined Procedure STORE *)

isMutable ->
PROCEDURE [STORE] replaceCharAtIndex
 ( VAR string : ProtoString; index : POSINT; char : CharType );
(* Procedure to store a character at a given index in a string.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     string[index] := char
   is equivalent to
     STORE(string, index, char)
   and is synthesised as
     StringADT.replaceCharAtIndex(string, index, char). *)


(* Value Retrieval *)

(* Binding to Predefined Function RETRIEVE *)

PROCEDURE [RETRIEVE] charAtIndex
 ( string : ProtoString; index : POSINT ) : CharType;
(* Required function to return the character stored in a string
   at a given index. *)

(* An expression of the form string[index]
   is equivalent to RETRIEVE(string, index) and
   is synthesised as StringADT.charAtIndex(string, index). *)


(* Storage, Retrieval, Insertion and Removal of Contents *)

PROCEDURE [STORE] replaceCharAtIndex
  ( string : ProtoString;
    index : INTEGER; char : CharType );
(* Required procedure to replace a char at a given index in a string *)

(* An assignment of the form
     string[index] := char
   is equivalent to
     STORE(string, index, char)
   and is synthesised as
     StringADT.replaceCharAtIndex(string, index, char). *)


PROCEDURE [RETRIEVE] charAtIndex
  ( string : ProtoString; index : INTEGER ) : CharType;
(* Required procedure to return the char at a given index in a string. *)

(* An expression of the form
     string[index]
   is equivalent to
     RETRIEVE(string, index)
   and is synthesised as
     StringADT.charAtIndex(string, index). *)


(* Index Out Of Range Retrieval Error Handling *)

(* A user defined index-out-of-range handler function may be used to change
   the default behaviour when RETRIEVE is called with an out-of-range index. *)

(* Handler Type *)

TYPE HandlerType = PROCEDURE ( VAR CharType ) : BOOLEAN;
(* Required procedure type for user defined index-out-of-range handlers. *)

(* An example of an index-out-of-range handler is given below:
   
   PROCEDURE mayAbortOnIndexOutOfRange
     ( VAR valueToReturn : CARDINAL ) : BOOLEAN;
   BEGIN
     valueToReturn := 0u0;
     RETURN FALSE
   END mayAbortOnIndexOutOfRange;
   
   This handler tells its caller not to abort and to return ASCII-NUL. *)


(* Handler Installation *)

PROCEDURE installHandler ( handler : HandlerType );
(* Required procedure to install a user defined index-out-of-range handler. *)


(* Value Insertion *)

(* Binding to Predefined Procedure INSERT *)

isMutable ->
PROCEDURE [INSERT] insertCharsAtIndex
  ( targetString : ProtoString;
    index : POSINT;
    values : ARRAY OF CharType );
(* Procedure to insert characters into a target string at a given index.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     INSERT(string, index, "foo" )
   is synthesised as
     StringADT.insertCharsAtIndex(array, index, "foo"). *)


isMutable ->
PROCEDURE insertStringAtIndex
  ( targetStr : ProtoString; index : POSINT; sourceStr : ProtoString );
(* Procedure to insert a source string into a string array at a given
   index. The procedure is required when the ADT is mutable. *)


(* Value Removal *)

(* Binding to Predefined Procedure REMOVE *)

isMutable ->
PROCEDURE [REMOVE] removeCharsAtIndex
  ( string : ProtoString; index : POSINT; charCount : POSINT );
(* Procedure to remove one or more characters from a string at a given index.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     REMOVE(string, index, n);
   is synthesised as
     StringADT.removeCharsAtIndex(string, index, n).
   
   A statement of the form
     string[index] := NIL
   is treated equivalent to
     REMOVE(string, index, 1)
   if a constant of value TRUE is bound to NIL. *)


(* Concatenation and Slicing *)

(* Binding to Predefined Procedure CONCAT *)

isRefCounted ->
PROCEDURE [CONCAT] concat
  ( VAR result : ProtoString;
    arglist : ARGLIST OF { lit : ARRAY OF CharType; s : ProtoString } );
(* Required procedure to concatenate an alternating list of character string
   literals and string ADT variables, and return a newly allocated result
   string. Empty literals and NIL values in the argument list are ignored.
   The Procedure is required if the ADT is reference counted. *)

(* Concatenation of consecutive string literals takes place at compile time.
   Thus, string literals do not occur consecutively in run time expressions.
      
   Invocations of CONCAT are mapped to procedure StringADT.concat as follows:
   
   A statement of the form
     CONCAT(resultStr, str1, str2);
   is transformed at compile time into a procedure call of the form
     StringADT.concat(resultStr, "", str1, "", str2);

   A statement of the form
     CONCAT(resultStr, str1, "literal", str2);
   is transfored at compile time into a procedure call of the form
     StringADT.concat(resultStr, "", str1, "lit", str2);
      
   A statement of the form
     CONCAT(resultStr, "lit", str1, str2);
   is transformed at compile time into a procedure call of the form
     StringADT.concat(resultStr, "lit", str1, "", lit2);
   
   A statement of the form
     CONCAT(resultStr, "lit1", str, "lit2")
   is transformed at compile time into a procedure call of the form
     StringADT.concat(resultStr, "lit1", str, "lit2", NIL);
   
   When a concatenation expression is passed as an argument to a procedure
   it is first assigned to a temporary variable,  which is then passed as
   a parameter in the subsequent procedure call and finally released.
   
   A procedure invocation of the form
     FooProc(str1 + str2);
   is transformed at compile time into a temporary variable declaration
     VAR tempResult : StringADT;
   and a statement sequence of the form
     CONCAT(tempResult, str1, str2);
     FooProc(tempResult); RELEASE(tempResult);
   
   A function invocation of the form
     foo := BarFunc(str1 + str2);
   is transformed at compile time into a temporary variable declaration
     VAR tempResult : StringADT;
   and a statement sequence of the form   
     CONCAT(tempResult, str1, str2);
     foo := BarFunc(tempResult); RELEASE(tempResult); *)


(* Binding to the Slicing Operator *)

isSliceable ->
PROCEDURE [..] copySlice
  ( VAR target : ProtoString; tgtStartIndex, tgtEndIndex : INTEGER;
    source : ProtoString; srcStartIndex, srcEndIndex : INTEGER );
(* Required procedure to copy a slice from a source string, indicated by
   a given start and end index,  into a slice within a target string,
   indicated by a given start and end index.  If target is NIL and the
   target indices are 0 and -1, a newly allocated string is to be passed
   back in target as result. The procedure is required if the ADT is
   mutable and reference counted. *)

(* An assignment of the form
     target := source[2..5];
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 0, -1, source, 2, 5);
   
   An assignment of the form
     target[2..5] := source;
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 2, 5, source, 0, -1);
   
   An assignment of the form
     target[1..4] := source[2..5];
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 1, 4, source, 2, 5);
   
   When a slice expression is passed as an argument to a procedure, it is
   first assigned to a temporary variable,  which is then passed as a
   parameter in the subsequent procedure call and finally released.

   A procedure invocation of the form
     FooProc(string[2..5]);
   is transformed at compile time into a temporary variable declaration
     VAR tempTarget : StringADT;
   and a statement sequence of the form
     StringADT.copySlice(tempTarget, 0, -1, string, 2, 5);
     FooProc(tempTarget); RELEASE(tempTarget);
   
   A function invocation of the form
     foo := BarFunc(string[2..5]);
   is transformed at compile time into a temporary variable declaration
     VAR tempTarget : StringADT;
   and a statement sequence of the form
     StringADT.copySlice(tempTarget, 0, -1, string, 2, 5);
     foo := BarFunc(tempTarget); RELEASE(tempTarget); *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoString, CONST POSINT );
(* Required procedure type to synthesise the body of a for loop. *)

PROCEDURE [FOR] forIterator
  ( VAR string : ProtoString; doStatements : LoopBodyType; ascending : BOOLEAN );

(* Required procedure to iterate over all characters of a string in a
   given order and execute the passed in doStatements for each character. *)
   
(* A statement of the form
     FOR index IN string DO statementSeq END
   is synthesised in two steps.
   
   The loop header is synthesised as
     StringADT.forIterator( string, forLoopBody, TRUE );
   
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR string : StringADT; CONST index : POSINT ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   
   The loop header of a FOR DESCENDING statement is sythesised with
   FALSE passed for parameter ascending in the call to forIterator. *)


(* Relational Operations *)

(* Binding to the = and # Operators *)

PROCEDURE [=] isEqual ( string1, string2 : ProtoString ) : BOOLEAN;
(* Required function to test the equivalence of two strings. *)

(* An expression of the form string1 = string2
   is synthesised as StringADT.isEqual(string1, string2). *)

(* The operation for the # operator
   is synthesized as NOT (string1 = string2). *)


PROCEDURE [<] isLess ( string1, string2 : ProtoString ) : BOOLEAN;
(* Required procedure to test if the value of a string comes lexically
   after another. *)

(* An expression of the form string1 < string2
   is synthesised as StringADT.isLess(string1, string2). *)

(* The operation for the <= operator
   is synthesized as NOT (string1 > string2) *)


PROCEDURE [>] isGreater ( string1, string2 : ProtoString ) : BOOLEAN;
(* Required procedure to test if the value of a string comes lexically
   before another. *)

(* An expression of the form string1 > string2
   is synthesised as StringADT.isGreater(string1, string2). *)

(* The operation for the >= operator
   is synthesized as NOT (string1 < string2) *)


END ProtoString.