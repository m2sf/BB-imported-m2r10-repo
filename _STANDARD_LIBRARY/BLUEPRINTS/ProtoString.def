(* (C) 2009-2012 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Dynamically Allocatable String ADTs *)

BLUEPRINT FOR ProtoString [ProtoCollection];

PLACEHOLDERS IndexType, ProcType;

(* String ADTs must be opaque,
   Character and string literals are compatible *)

TYPE ProtoString = OPAQUE := CHAR;


(* Bindings required for String ADTs *)

(* Capacity limit *)

(* Binding to pervasive function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the character limit of a String ADT. *)

(* An expression of the form TLIMIT(StringADT))
   is synthesised as StringADT.capacityLimit() *)


(* Construction and Destruction *)

PROCEDURE [NEW] new ( VAR string : ProtoString );
(* Procedure to allocate and initialise a new String ADT variable. *)

(* A statement of the form NEW(string)
   is synthesised as StringADT.new(string) *)

(* EXPERIMENTAL *)
PROCEDURE [RETAIN] retain ( VAR string : ProtoString );
(* Procedure to retain a String ADT variable, incrementing its ref count. *)

(* A statement of the form RETAIN(string)
   is synthesised as StringADT.retain(string) *)

(* EXPERIMENTAL *)
PROCEDURE [RELEASE] release ( VAR string : ProtoString );
(* Procedure to release a String ADT variable, decrementing its ref count
   and deallocating it if the ref count value has reached zero. *)

(* A statement of the form RELEASE(string)
   is synthesised as StringADT.release(string) *)


(* Binding to assignment operator *)

PROCEDURE [:=] assign ( VAR string : ProtoString;
                        strLiteral : ARRAY OF CHAR );

(* Procedure to assign a string literal to a String ADT variable. *)

(* A statement of the form string := "the quick brown fox ..."
   is synthesised as assign( string, "the quick brown fox ..." ) *)


(* Character access *)

(* Binding to [ ] notation within left hand entities *)

PROCEDURE [!] replaceChar ( VAR string : ProtoString;
                                 index : IndexType; char : CHAR );

(* Procedure to replace the character at a given index in a String ADT
   variable. *)

(* A statement of the form string[index] := char
   is synthesised as replaceChar( string, index, char ) *)


(* Binding to [ ] notation within expressions *)

PROCEDURE [?] charAtIndex ( string : ProtoString;
                             index : IndexType ) : CHAR;
(* Procedure to return the character at a given index in a String ADT
   value. *)

(* An expression of the form string[index]
   is synthesised as charAtIndex( string, index ) *)


(* Length *)

(* Binding to pervasive function LENGTH *)

PROCEDURE [LENGTH] length ( string : ProtoString ) : LONGCARD;
(* Procedure to return the length of a String ADT value. *)

(* An expression of the form LENGTH(string)
   is synthesised as StringADT.length(string) *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE ProcType = PROCEDURE ( VAR ProtoString; CONST IndexType );

PROCEDURE [FOR] forIterator ( VAR string : ProtoString;
                            doStatements : ProcType );

(* Procedure to iterate over all characters of a String ADT value in
   ascending order and execute the passed in doStatements for each
   character. *)
   
(* A statement of the form
     FOR index IN string DO statementSeq END
   is synthesised in two steps.
   The loop header is synthesised as
     StringADT.forIterator( string, forLoopBody );
   The loop body is synthesised as
     <* INLINE *> PROCEDURE forLoopBody ( VAR string : StringADT;
                                         CONST index : IndexType );
     BEGIN statementSeq END forLoopBody; *)

PROCEDURE [DESCENDING] reverseFor ( VAR string : StringType;
                                  doStatements : ProcType );

(* Procedure to iterate over all characters of a String ADT value in
   descending order and execute the passed in doStatements for each
   character. *)
   
(* A statement of the form
     FOR DESCENDING index IN string DO statementSeq END
   is synthesised in two steps.
   The loop header is synthesised as
     StringADT.reverseFor( string, forLoopBody );
   The loop body is synthesised as
     <* INLINE *> PROCEDURE forLoopBody ( VAR string : StringADT;
                                         CONST index : IndexType );
     BEGIN statementSeq END forLoopBody; *)
   

(* Dyadic operations *)

(* Concatenation *)

(* EXPERIMENTAL *)
PROCEDURE [+] strFromConcatExpr (
   strList : VARIADIC OF { CONST literal : ARRAY OF CHAR;
                           CONST str     : ProtoString } ) : ProtoString;

(* Procedure to concatenate a variadic list of string literals and String ADT
   values and return the result in a newly allocated String ADT variable. *)

(* An expression of the form
     s := s1 + s2 + s3;
   is synthesised as
     s := strFromConcatExpr( "", s1, "", s2, "", s3 );

   An expression of the form
     s := "foo" + s1 + s2;
   is synthesised as
     s := strFromConcatExpr( "foo", s1, "", s2 );

   An expression of the form
     s := s1 + "foo" + s2;
   is synthesised as
     s := strFromConcatExpr( "", s1, "foo", s2 );

   An expression of the form
     s := s1 + s2 + "foo";
   is synthesised as
     s := strFromConcatExpr( "", s1, "", s2, "foo", NIL );
   
   An statement of the form
     foobar(s1 + s2);
   is synthesised as
     tempStr := strFromConcatExpr( "", s1, "", s2);
     foobar(tempStr); RELEASE(tempStr); *)

(* EXPERIMENTAL *)
PROCEDURE [+] concatenateInSitu ( VAR str : ProtoString;
    strList : VARIADIC OF { CONST literal : ARRAY OF CHAR;
                            CONST str     : ProtoString } );

(* Procedure to concatenate a variadic list of string literals and String ADT
   values to a String ADT variable and return the result in this variable. *)

(* An expression of the form
     s := s + s1 + s2 + s3;
   is synthesised as
     concatenateInSitu( s, "", s1, "", s2, "", s3 );

   An expression of the form
     s := s + "foo" + s1 + s2;
   is synthesised as
     concatenateInSitu( s, "foo", s1, "", s2 );

   An expression of the form
     s := s + s1 + "foo" + s2;
   is synthesised as
     concatenateInSitu( s, "", s1, "foo", s2 );

   An expression of the form
     s := s + s1 + s2 + "foo";
   is synthesised as
     concatenateInSitu( s, "", s1, "", s2, "foo", NIL ); *)


(* Sub-String removal *)

(* EXPERIMENTAL *)
PROCEDURE [-] reductionOf ( str : ProtoString
                     removeList : VARIADIC OF ProtoString ) : ProtoString;

(* Procedure to remove all sub-strings in a variadic list of String ADT values
   from a first String ADT value and return the result in a newly allocated
   String ADT variable. *)

(* An expression of the form
     s := s1 - s2 - ... - sN;
   is synthesised as
     s := StringADT.reductionOf( s1, s2, ..., sN );

   A statement of the form
     foobar(s1 - s2);
   is synthesised as
     tempStr := reductionOf(s1, s2);
     foobar(tempStr); RELEASE(tempStr); *)

(* EXPERIMENTAL *)
PROCEDURE [-] reduceInSitu ( VAR str : ProtoString;
                          removeList : VARIADIC OF ProtoString );

(* Procedure to remove all sub-strings in a variadic list of String ADT values
   from a first String ADT value and return the result in the first String ADT
   variable passed. *)

(* An expression of the form
     s := s - s1 - s2 - ... - sN;
   is synthesised as
     StringADT.reduceInSitu( s, s1, s2, ..., sN ); *)


(* The operations * and / are not meaningful for strings. *)


(* Relational operations *)

(* Binding to = operator *)

PROCEDURE [=] isEqual ( s1, s2 : ProtoString ) : BOOLEAN;
(* Procedure to test the equivalence of two String ADT values. *)

(* An expression of the form string1 = string2
   is synthesised as StringADT.isEqual(string1, string2) *)

(* The operation for the # operator
   is synthesized as NOT (string1 = string2) *)


(* Binding to < operator *)

PROCEDURE [<] isLess ( s1, s2 : ProtoString ) : BOOLEAN;
(* Procedure to test if String ADT value s1 comes lexically before String ADT
   value s2. *)

(* The operation for the <= operator is synthesized as NOT (s1 > s2) *)

PROCEDURE [>] isGreater ( s1, s2 : ProtoString ) : BOOLEAN;
(* Procedure to test if String ADT value s1 comes lexically after String ADT
   value s2. *)

(* The operation for the >= operator is synthesized as NOT (s1 < s2) *)


END ProtoString.