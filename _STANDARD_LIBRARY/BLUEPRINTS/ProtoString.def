(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Dynamically Allocatable String ADTs *)

BLUEPRINT ProtoString [ProtoCollection];

REFERENTIAL CharType (* CHAR or UNICHAR *), POSINT, ForLoopBodyProc;

(* String ADTs must be opaque,
   quoted literals of base type CHAR or UNICHAR are compatible *)

TYPE ProtoString = OPAQUE := CHAR | UNICHAR;


(* Bindings required for String ADTs *)


(* Required Constants *)

CONST [:=] isMutable : BOOLEAN;
(* whether the ADT is mutable *)

CONST [DESCENDING] isOrdered = TRUE;
(* String ADTs are always ordered *)


(* Required Procedures *)

(* Capacity limit *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the allocation capacity limit of a string ADT. *)

(* An invocation of TLIMIT(StringADT)) is transformed at compile time to
   StringADT.capacityLimit() when the operand is of the string ADT type. *)


(* Memory Management *)

PROCEDURE [NEW] new
  ( VAR s : ProtoString; initWith : ARRAY OF CharType );
(* Required procedure to allocate and initialise a new string. *)

(* A statement of the form
     NEW(string);
   is transformed at compile time to a procedure call of the form
     StringADT.new(string);
   for operands of the string ADT type.
   
   A statement of the form
     NEW(string, "foo bar baz");
   is transformed at compile time to a procedure call of the form
     StringADT.new(string, "foo bar baz");
   for operands of the string ADT type. *)


PROCEDURE [RETAIN] retain ( VAR s : ProtoString );
(* Required procedure to retain a string ADT variable. *)

(* A statement of the form
     RETAIN(string);
   is transformed at compile time to a procedure call of the form
     StringADT.retain(string);
   for operands of the string ADT type. *)


PROCEDURE [RELEASE] release ( VAR s : ProtoString );
(* Required procedure to release and eventually deallocate a string. *)

(* A statement of the form
     RELEASE(string);
   is transformed at compile time to a procedure call of the form
     StringADT.release(string);
   for operands of the string ADT type. *)


(* Assignment and Copying *)

PROCEDURE [:=] NEW;
(* Procedure bound to NEW will be used for literal assignment. *)

(* A statement of the form
     string := "foo bar baz";
   is transformed at compile time into a procedure call of the form
     StringADT.new(string, "foo bar baz");
   for L-values of the string ADT type. *)


PROCEDURE [DUP] duplicateOf ( string : ProtoString ) : ProtoString;
(* Reuired procedure to return a duplicate of a string. *)

(* An expression of the form
     DUP(string)
   is transformed at compile time into a function call of the form
     StringADT.duplicateOf(string)
   for operands of the string ADT type. *)


(* Storage, Removal, Retrieval and Inspection of Contents *)

PROCEDURE [STORE] replaceCharAtIndex
  ( string : ProtoString;
    index : INTEGER; char : CharType );
(* Required procedure to replace a char at a given index in a string *)

(* A statement of the form
     STORE(string, index, char);
   is transformed at compile time into a procedure call of the form
     StringADT.replaceCharAtIndex(string, index, char);
   for first operands of the string ADT type.
   
   An assignment of the form
     string[index] := char;
   is transformed at compile time into a procedure call of the form
     StringADT.replaceCharAtIndex(string, index, char);
   for designators of the string ADT type. *)


PROCEDURE [RETRIEVE] charAtIndex
  ( string : ProtoString; index : INTEGER ) : CharType;
(* Required procedure to return the char at a given index in a string. *)

(* An expression of the form
     RETRIEVE(string, index)
   is transformed at compile time into a function call of the form
     StringADT.charAtIndex(string, index)
   for first operands of the string ADT type.
   
   An expression of the form
     string[index]
   is transformed at compile time into a function call of the form
     StringADT.charAtIndex(string, index)
   for designators of the string ADT type. *)


PROCEDURE [REMOVE] removeCharsAtIndex
  ( string : ProtoString; index : INTEGER; n : POSINT );
(* Required rocedure to remove n characters from a string,
   starting at a given index. *)

(* A statement of the form
     REMOVE(string, index, 5);
   is transformed at compile time into a procedure call of the form
     StringADT.removeCharsAtIndex(string, index, 5);
   for first operands of the string ADT type.
   
   An assignment of the form
     string[index] := NIL;
   is transformed at compile time into a procedure call of the form
     StringADT.removeCharsAtIndex(string, index, 1);
   for designators of the string ADT type. *)


(* Introspection *)

PROCEDURE [LENGTH] length ( string : ProtoString ) : POSINT;
(* Required procedure to return the length of a string. *)

(* An expression of the form
     LENGTH(string)
   is transformed at compile time to a function call of the form
     StringADT.count(string)
   for operands of the string ADT type. *)


(* Concatenation and Slicing *)

PROCEDURE [CONCAT] concat
  ( VAR result : ProtoString;
    arglist : ARGLIST OF { lit : ARRAY OF CharType; s : ProtoString } );
(* Required procedure to concatenate an alternating list of character string
   literals and string ADT variables, and return a newly allocated result
   string. Empty literals and NIL values in the argument list are ignored. *)

(* Concatenation of consecutive string literals takes place at compile time.
   Thus, string literals do not occur consecutively in run time expressions.
      
   Invocations of CONCAT are mapped to procedure StringADT.concat as follows:
   
   A statement of the form
     CONCAT(str1, str2, str3);
   is transformed at compile time into a procedure call of the form
     StringADT.concat(str1, "", str2, "", str3);

   A statement of the form
     str1 := CONCAT(str1, str2, "literal", str3);
   is transfored at compile time into a procedure call of the form
     StringADT.concat(str1, "", str2, "lit", str3);
      
   A statement of the form
     CONCAT(str1, "lit", str2, str3);
   is transformed at compile time into a procedure call of the form
     StringADT.concat(str1, "lit", str2, "", lit3);
   
   A statement of the form
     CONCAT(str1, "lit1", str2, "lit2")
   is transformed at compile time into a procedure call of the form
     StringADT.concat(str1, "lit1", str2, "lit2", NIL);
   
   When a concatenation expression is passed as an argument to a procedure
   it is first assigned to a temporary variable,  which is then passed as
   a parameter in the subsequent procedure call and finally released.
   
   A procedure invocation of the form
     FooProc(str1 + str2);
   is transformed at compile time into a statement sequence of the form
     CONCAT(temp, str1, str2);
     FooProc(temp); RELEASE(temp);
   
   A function invocation of the form
     foo := BarFunc(str1 + str2);
   is transformed at compile time into a statement sequence of the form   
     CONCAT(temp, str1, str2);
     foo := BarFunc(temp); RELEASE(temp); *)


PROCEDURE [..] copySlice
  ( VAR target : ProtoString; tgtStartIndex, tgtEndIndex : INTEGER;
    source : ProtoString; srcStartIndex, srcEndIndex : INTEGER );
(* Required procedure to copy a slice from a source string, indicated by
   a given start and end index,  into a slice within a target string,
   indicated by a given start and end index.  If target is NIL and the
   target indices are 0 and -1, a newly allocated string is to be passed
   back in target as result.
   Consult the documentation for specific details. *)

(* An assignment of the form
     target := source[2..5];
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 0, -1, source, 2, 5);
   
   An assignment of the form
     target[2..5] := source;
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 2, 5, source, 0, -1);
   
   An assignment of the form
     target[1..4] := source[2..5];
   is transformed at compile time into a procedure call of the form
     StringADT.copySlice(target, 1, 4, source, 2, 5);
   
   When a slice expression is passed as an argument to a procedure, it is
   first assigned to a temporary variable,  which is then passed as a
   parameter in the subsequent procedure call and finally released.

   A procedure invocation of the form
     FooProc(string[2..5]);
   is transformed at compile time into a statement sequence of the form
     StringADT.copySlice(temp, 0, -1, string, 2, 5);
     FooProc(temp); RELEASE(temp);
   
   A function invocation of the form
     foo := BarFunc(string[2..5]);
   is transformed at compile time into a statement sequence of the form
     StringADT.copySlice(temp, 0, -1, string, 2, 5);
     foo := BarFunc(temp); RELEASE(temp); *)


(* ### Revision pending beyond this point ### *)


PROCEDURE insertCharsAtIndex
  ( s : ProtoString; index : IndexType; CONST chars : ARRAY OF CHAR );
(* Procedure to insert character sequence chars into a String ADT
   variable s starting at index. *)


(* Iteration *)

(* TYPE ForLoopBodyProc = PROCEDURE ( (* index : *) CONST IndexType ); *)

PROCEDURE [FOR] forIterator
  ( s : STRING; doStatementSeq : ForLoopBodyProc; ascending : BOOLEAN );
(* Procedure to iterate over all characters in String ADT variable s,
   executing procedure doStatementSeq for each index value, using the
   iteration order indicated by ascending. *)

   
(* A statement of the form FOR index IN string DO statementSeq END
   is synthesised in two steps.
   
   The FOR loop header is synthesised as
   
   StringADT.forIterator(string, forLoopBody, TRUE);
   
   The FOR loop body is synthesised as
   
   PROCEDURE forLoopBody
     ( VAR string : StringADT; CONST index : IndexType );
   BEGIN statementSeq END forLoopBody;
   
   A FOR DESCENDING loop header is synthesised as
   
   StringADT.forIterator(string, forLoopBody, TRUE);

   The use of FOR DESCENDING syntax is dependent on property isOrdered.
   If the ADT defines isOrdered as FALSE, the use of FOR DESCENDING is
   not permitted and will cause a compile time error. *)


(* Relational Operations *)

PROCEDURE [=] isEqual ( s1, s2 : ProtoString ) : BOOLEAN;
(* Procedure to test the equivalence of two String ADT values. *)

(* An expression of the form string1 = string2
   is synthesised as StringADT.isEqual(string1, string2) *)

(* The operation for the # operator
   is synthesized as NOT (string1 = string2) *)

PROCEDURE [<] isLess ( s1, s2 : ProtoString ) : BOOLEAN;
(* Procedure to test if String ADT value s1 comes lexically before
   String ADT value s2. *)

(* The operation for the <= operator is synthesized as NOT (s1 > s2) *)

PROCEDURE [>] isGreater ( s1, s2 : ProtoString ) : BOOLEAN;
(* Procedure to test if String ADT value s1 comes lexically after
   String ADT value s2. *)

(* The operation for the >= operator is synthesized as NOT (s1 < s2) *)


(* IO Operations *)

PROCEDURE [READ] Read ( infile : File; s : ProtoString );
(* Procedure to read a value from a file into a String ADT variable. *)

(* A statement of the form READ(string)
   is synthesised as StringADT.Read(stdIn, string)
   
   A statement of the form READ(file, string)
   is synthesised as StringADT.Read(file, string) *)

PROCEDURE [WRITE] Write ( outfile : File; s : STRING );
(* Procedure to write the value of String ADT variable to a file. *)

(* A statement of the form WRITE(string)
   is synthesised as StringADT.Write(stdOut, string)
   
   A statement of the form WRITE(file, string)
   is synthesised as StringADT.Write(file, string) *)

PROCEDURE [WRITEF] WriteF
  ( outfile      : File;
    CONST fmtStr : ARRAY OF CHAR;
    items        : VARIADIC OF STRING );
(* Procedure to write a variadic list of String ADT variables formatted
   to a file. *)

(* A statement of the form WRITEF("\n", string)
   is synthesised as StringADT.WriteF(stdIn, "\n", string)
   
   A statement of the form WRITEF(file, "\n", string)
   is synthesised as StringADT.WriteF(file, "\n", string) *)


END ProtoString.