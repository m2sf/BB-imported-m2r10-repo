(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Statically Allocatable Set ADTs *)

BLUEPRINT ProtoStaticSet [ProtoCollection];

REFERENTIAL ElementType, ProcType;

(* Static Set ADTs must be opaque records to be statically allocatable,
   structured literals with a list of elements are compatible *)

MODULE TYPE = OPAQUE RECORD := { ElementType BY * };


(* Bindings required for static set ADTs *)


(* Required Constants *)

CONST [:=] isMutable = TRUE;
(* Static set ADTs are always mutable *)

CONST [DESCENDING] isOrdered = TRUE;
(* Static set ADTs are always ordered *)


(* Required Procedures *)

(* Capacity limit *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Procedure to return the allocation capacity limit of the set ADT. *)

(* An invocation of TLIMIT(ADT)) is transformed at compile time to
   SetADT.capacityLimit() when the operand is the set ADT type. *)


(* Assignment and Copying *)

PROCEDURE [:=] assignStructuredValue
  ( VAR set : ProtoStaticSet; elementList : ARGLIST OF ElementType );
(* Required procedure to assign a structured value to a set. *)

(* A statement of the form
     set := { elem1, elem2, elem3, ... };
   is transformed at compile time into a procedure call of the form
     SetADT.assignStructuredValue(set, elem1, elem2, elem3, ...);
   for L-values of the set ADT type. *)


PROCEDURE [COPY] copy
  ( source : ProtoStaticSet; VAR target : ProtoStaticSet );
(* Required procedure to copy the contents of a source set into a
   target set. *)

(* A statement of the form
     set1 := set2;
   is transformed at compile time into a procedure call of the form
     SetADT.copy(set2, set1);
   for L- and R-values of the set ADT type. *)


(* Storage, Retrieval and Inspection of Contents *)

PROCEDURE [STORE] storeElements
  ( VAR set : ProtoStaticSet; elementList : ARGLIST OF ElementType );
(* Required procedure to store zero or more elements in a set. *)

(* A statement of the form
     STORE(set, elem1, elem2, elem3 ...)
   is transformed at compile time into a procedure call of the form
     SetADT.storeElements(set, elem1, elem2, elem3 ...)
   for first operands of the set ADT type.
   
   A statement of the form
     set[element] := TRUE;
   is transformed at compile time into a procedure call of the form
     SetADT.storeElements(set, element);
   for designators of the set ADT type. *)


PROCEDURE [REMOVE] removeElements
  ( VAR set : ProtoStaticSet; elementList : ARGLIST OF ElementType );
(* Required procedure to remove one or more elements from a set. *)

(* A statement of the form
     REMOVE(set, elem1, elem2, elem3 ...)
   is transformed at compile time into a procedure call of the form
     SetADT.removeElements(set, elem1, elem2, elem3 ...)
   for first operands of the set ADT type.
   
   A statement of the form
     set[element] := FALSE;
   is transformed at compile time into a procedure call of the form
     SetADT.removeElements(set, element);
   for designators of the set ADT type. *)


PROCEDURE [RETRIEVE] membershipOfElement
  ( CONST set : ProtoStaticSet; element : ElementType ) : BOOLEAN;
(* Required function to retrieve an element from a set. *)

(* An expression of the form
     RETRIEVE(set, element)
   is transformed at compile time into a function call of the form
     SetADT.membershipOfElement(set, element)
   for first operands of the set ADT type.
   
   An expression of the form
     set[element]
   is transformed at compile time into a function call of the form
     SetADT.membershipOfElement(set, element)
   for designators of the set ADT type. *)


PROCEDURE [IN] isElement
  ( CONST set : ProtoStaticSet; element : ElementType ) : BOOLEAN;
(* Function to test whether a value is stored in a set. *)

(* An expression of the form
     elem IN set
   is transformed at compile time into a function call of the form
     SetADT.isElement(set, elem)
   for right operands of the set ADT type. *)


PROCEDURE [COUNT] count ( CONST set : ProtoStaticSet ) : LONGCARD;
(* Procedure to return the number of elements stored in a set. *)

(* An expression of the form
     COUNT(set)
   is transformed at compile time into a function call of the form
     SetADT.count(set)
   for operands of the set ADT type. *)


(* Iteration *)

TYPE ProcType = PROCEDURE ( ElementType );

PROCEDURE [FOR] forIterator
  ( VAR set : ProtoStaticSet; forLoopBody : ProcType; ascending : BOOLEAN );
(* Procedure to iterate over all elements of a set and invoke procedure
   forLoopBody for each element with the given iteration order. *)
   
(* A statement of the form
     FOR elem IN set DO statementSeq END
   is transformed at compile time in two steps.
   The loop header is transformed to
     SetADT.forIterator( set, forLoopBody, TRUE );
   The loop body is transformed to a procedure definition
     PROCEDURE forLoopBody ( element : ElementType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   inserted before the current scope's BEGIN-END block.
   
   A loop header of the form
     FOR DESCENDING elem IN set
   is transformed at compile time to
     SetADT.forIterator(set, forLoopBody, FALSE)
   To allow this, an ADT must bind a constant of value TRUE to DESCENDING. *)   


(* Set Operations *) 

PROCEDURE [+] union
  ( CONST set1, set2 : ProtoStaticSet ) : ProtoStaticSet;
(* Required procedure to return the union of two sets. *)

(* An expression of the form
     set1 + set2
   is transformed at compile time into a function call of the form
     SetADT.union(set1, set2)
   for operands of the set ADT type. *)


PROCEDURE [-] difference
  ( CONST set1, set2 : ProtoStaticSet ) : ProtoStaticSet;
(* Required procedure to return the set difference of two sets. *)

(* An expression of the form
     set1 - set2
   is transformed at compile time into a function call of the form
     SetADT.difference(set1, set2)
   for operands of the set ADT type. *)


PROCEDURE [*] intersection
  ( CONST set1, set2 : ProtoStaticSet ) : ProtoStaticSet;
(* Required procedure to return the intersection of two sets. *)

(* An expression of the form
     set1 * set2
   is transformed at compile time into a function call of the form
     SetADT.intersection(set1, set2)
   for operands of the set ADT type. *)


PROCEDURE [/] symmetricDiff
  ( CONST set1, set2 : ProtoStaticSet ) : ProtoStaticSet;
(* Required procedure to return the symmetric difference of two sets. *)

(* An expression of the form
     set1 / set2
   is transformed at compile time into a function call of the form
     SetADT.symmetricDiff(set1, set2)
   for operands of the set ADT type. *)


(* Relational operations *)

PROCEDURE [=] isEqual ( CONST set1, set2 : ProtoStaticSet ) : BOOLEAN;
(* Required procedure to test the equality of two sets. *)

(* An expression of the form
     set1 = set2
   is transformed at compile time into a function call of the form
     SetADT.isEqual(set1, set2)
   for operands of the set ADT type.
   
   An expression of the form
     set1 # set2
   is transformed at compile time into an expression of the form
     NOT SetADT.isEqual(set1, set2)
   for operands of the set ADT type. *)


PROCEDURE [SUBSET] isSubset ( CONST set1, set2 : ProtoStaticSet ) : BOOLEAN;
(* Required procedure to test whether one set is a subset of another. *)

(* An expression of the form
     set1 > set2
   is transformed at compile time into a function call of the form
     SetADT.isSubset(set2, set1)
   for operands of the set ADT type.
   
   An expression of the form
     set1 >= set2
   is transformed at compile time into an expression of the form
     (COUNT(set1) > COUNT(set2)) AND SetADT.isSubset(set2, set1)
   for operands of the set ADT type.
   
   An expression of the form
     set1 < set2
   is transformed at compile time into a function call of the form
     SetADT.isSubset(set1, set2)
   for operands of the set ADT type.
   
   An expression of the form
     set1 <= set2
   is transformed at compile time into an expression of the form
     (COUNT(set1) < COUNT(set2)) AND SetADT.isSubset(set1, set2)
   for operands of the set ADT type. *)


END ProtoStaticSet.