(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Blueprint for Dynamically Allocatable Dictionary ADTs *)

BLUEPRINT ProtoDictionary [ProtoCollection];

REFERENTIAL KeyType, ValueType, LoopBodyType, File;


(* Required Module Type *)

MODULE TYPE = OPAQUE := { ARGLIST OF { KeyType, ValueType } };
(* Dictionary ADTs must be opaque,
   variadic structured literals with key/value pairs are compatible *)


(* Required Constants *)


(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT should be mutable.
   Its value may be TRUE or FALSE. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether conforming ADTs should be
   reference counted. Its value may be TRUE or FALSE. *)


(* Orderedness *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* Required constant to define whether conforming ADTs should be ordered.
   Its value may be TRUE or FALSE. *)


(* NIL Storage *)

CONST [NIL] allowsNilStorage : BOOLEAN;
(* Required constant to define whether NIL should be a storable value.
   Its value may be TRUE or FALSE. *)


(* Support for Invalid Accessor Retrieval Intercept *)

CONST * invAccessorRetrievalIntercept = TRUE;
(* Required constant to define whether invalid accessor retrieval errors may
   be intercepted by user defined handlers. Its value may be TRUE or FALSE. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the allocation capacity limit of the ADT. *)

(* An expression of the form TLIMIT(DictADT))
   is synthesised as DictADT.capacityLimit(). *)


(* Binding to Predefined Function COUNT *)

PROCEDURE [COUNT] count ( dict : ProtoDictionary ) : LONGCARD;
(* Required function to return the number of key/value pairs stored
   in a dictionary. *)

(* An expression of the form COUNT(dict)
   is synthesised as DictADT.count(dict). *)


(* Memory Management *)

PROCEDURE [NEW] new ( VAR dict : ProtoDictionary; capacity : LONGCARD );
(* Procedure to allocate and initialise a new dictionary. *)

(* An invocation of NEW(dict, n) is transformed at compile time to
   ADT.new(dict, n) for first operands of the ADT type. *)


PROCEDURE [RETAIN] retain ( dict : ProtoDictionary );
(* Procedure to retain a dictionary. *)

(* An invocation of RETAIN(dict) is transformed at compile time to
   ADT.retain(dict) for operands of the ADT type. *)


PROCEDURE [RELEASE] release ( VAR dict : ProtoDictionary );
(* Procedure to release and eventually deallocate a dictionary. *)

(* An invocation of RELEASE(dict) is transformed at compile time to
   ADT.release(dict) for operands of the ADT type. *)


(* Copying *)

PROCEDURE [DUP] duplicate ( dict : ProtoDictionary ) : ProtoDictionary;
(* Function to return a newly allocated copy of a dictionary. *)

(* An expression of the form DUP(dict) is transformed at compile time to
   ADT.duplicate(dict) for operands of the ADT type. *)


(* Storage, Removal, Retrieval and Inspection of Contents *)

PROCEDURE [STORE] storeEntries
  ( VAR dict : ProtoDictionary;
    keyValueList : ARGLIST OF { key : KeyType; value : ValueType } );
(* Procedure to store or replace zero or more entries in a dictionary. *)

(* An invocation of STORE(dict, key1, value1, key2, value2 ...) is transformed
   at compile time to ADT.storeEntries(dict, key1, value1, key2, value2 ...)
   for first operands of the ADT type. *)


PROCEDURE [REMOVE] removeEntries
  ( VAR dict : ProtoDictionary;
    keyList : ARGLIST OF KeyType );
(* Procedure to remove one or more entries from a dictionary. *)

(* An invocation of REMOVE(dict, key1, key2, key3 ...) is transformed
   at compile time to ADT.removeEntries(dict, key1, key2, key3 ...)
   for first operands of the ADT type. *)


PROCEDURE [RETRIEVE] valueForKey
  ( dict : ProtoDictionary; key : KeyType ) : ValueType;
(* Function to retrieve and return a value from a dictionary. *)

(* An invocation of RETRIEVE(dict, key) is transformed at compile time to
   ADT.valueForKey(dict, key) for first operands of the ADT type. *)


PROCEDURE [IN] entryExists
  ( dict : ProtoDictionary; key : KeyType ) : BOOLEAN;
(* Function to test whether a key is stored in a dictionary. *)

(* An expression of the form key IN dict is transformed at compile time to
   ADT.entryExists(dict, key) for right operands of the ADT type. *)


PROCEDURE [COUNT] count ( dict : ProtoDictionary ) : LONGCARD;
(* Function to return the number of key/value pairs in a dictionary. *)

(* An expression of the form COUNT(dict) is transformed at compile time to
   ADT.count(dict) for operands of the ADT type. *)


(* Iteration *)

TYPE ProcType = PROCEDURE ( KeyType );

PROCEDURE [FOR] forIterator
  ( dict : ProtoDictionary; forLoopBody : ProcType; ascending : BOOLEAN );
(* Procedure to iterate over all keys of a dictionary and invoke procedure
   forLoopBody for each key with the given iteration order. *)
   
(* A statement of the form
     FOR key IN dict DO statementSeq END
   is transformed at compile time in two steps.
   The loop header is transformed to
     ADT.forIterator(dict, forLoopBody, TRUE);
   The loop body is transformed to a procedure definition
     PROCEDURE forLoopBody ( key : KeyType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   inserted before the current scope's BEGIN-END block.
   
   If a constant with value TRUE has been bound to DESCENDING, a loop
   header of the form
     FOR DESCENDING key IN dict
   is transformed at compile time to
     ADT.forIterator(dict, forLoopBody, FALSE)
   otherwise the use of FOR DESCENDING will cause a compile time error. *)   


(* Relational operations *)

PROCEDURE [=] isEqual ( dict1, dict2 : ProtoDictionary ) : BOOLEAN;
(* Function to test the equality of two dictionaries. *)

(* An expression of the form dict1 = dict2 is transformed at compile time to
   ADT.isEqual(dict1, dict2) for operands of the ADT type.
   
   An expression of the form dict1 # dict2 is transformed at compile time to
   NOT ADT.isEqual(dict1, dict2) for operands of the ADT type. *)


PROCEDURE [SUBSET] isSubset ( dict1, dict2 : ProtoDictionary ) : BOOLEAN;
(* Function to test whether one dictionary is a subset of another *)

(* An expression of the form dict1 > dict2 is transformed at compile time to
   ADT.isSubset(dict2, dict1) for operands of the ADT type.
   
   An expression of the form dict1 >= dict2 is transformed at compile time
   to (COUNT(dict1) > COUNT(dict2)) AND ADT.isSubset(dict2, dict1) for
   operands of the ADT type.
   
   An expression of the form dict1 < dict2 is transformed at compile time to
   ADT.isSubset(dict1, dict2) for operands of the ADT type.
   
   An expression of the form dict1 <= dict2 is transformed at compile time
   to (COUNT(dict1) < COUNT(dict1)) AND ADT.isSubset(dict1, dict2) for
   operands of the ADT type. *)
   

(* IO operations *)

PROCEDURE [READ] Read ( infile : File; VAR dict : ProtoDictionary );
(* Procedure to read a value from a file into a dictionary. *)

(* An invocation of READ(file, dict) is transformed at compile time
   to ADT.Read(file, dict) for second operands of the ADT type. *)


PROCEDURE [WRITE] Write ( outfile : File; dict : ProtoDictionary );
(* Procedure to write a dictionary to a file. *)

(* An invocation of WRITE(file, dict) is transformed at compile time
   to ADT.Write(file, dict) for second operands of the ADT type. *)


PROCEDURE [WRITEF] WriteF
  ( outfile      : File;
    CONST fmtStr : ARRAY OF CHAR;
    items        : ARGLIST OF ProtoDictionary );
(* Procedure to write one or more dictionaries formatted into a file. *)

(* An invocation of WRITEF(file, fmt, dict1, dict2, dict3, ...) is transformed
   at compile time to ADT.WriteF(file, fmt, dict1, dict2, dict3, ...) for
   third operands and any following operands of the ADT type. *)


(* Introspection *)

PROCEDURE capacity ( dict : ProtoDictionary ) : LONGCARD;
(* Function to return the allocated capacity of a dictionary. *)


PROCEDURE entryLimit ( dict : ProtoDictionary ) : LONGCARD;
(* Function to return the key/value pair limit of a dictionary. *)


PROCEDURE isResizable ( dict : ProtoDictionary ) : BOOLEAN;
(* Function to return the resizable property of a dictionary. *)


END ProtoDictionary.