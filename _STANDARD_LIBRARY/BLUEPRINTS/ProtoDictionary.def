(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Specialised Blueprint for Dynamically Allocatable Dictionary ADTs *)

BLUEPRINT ProtoDictionary [ProtoCollection];

REFERENTIAL KeyType, ValueType, HandlerType, LoopBodyType;


(* Required Module Type *)

MODULE TYPE = OPAQUE := { ARGLIST OF { KeyType, ValueType } };
(* Dictionary ADTs must be opaque,
   variadic structured literals with key/value pairs are compatible *)


(* Required Constants *)


(* Mutability *)

CONST isMutable : BOOLEAN;
(* Required constant to define whether the ADT should be mutable.
   Its value may be TRUE or FALSE. *)


(* Memory Management Model *)

CONST isRefCounted : BOOLEAN;
(* Required constant to define whether conforming ADTs should be
   reference counted. Its value may be TRUE or FALSE. *)


(* Orderedness *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* Required constant to define whether conforming ADTs should be ordered.
   Its value may be TRUE or FALSE. *)


(* NIL Storage *)

CONST [NIL] allowsNilStorage : BOOLEAN;
(* Required constant to define whether NIL should be a storable value.
   Its value may be TRUE or FALSE. *)


(* Support for Invalid Accessor Retrieval Intercept *)

CONST * invAccessorRetrievalIntercept = TRUE;
(* Required constant to define whether invalid accessor retrieval errors may
   be intercepted by user defined handlers. Its value may be TRUE or FALSE. *)


(* Required Procedures *)


(* Introspection *)

(* Binding to Predefined Function TLIMIT *)

PROCEDURE [TLIMIT] capacityLimit : LONGCARD;
(* Required function to return the allocation capacity limit of the ADT. *)

(* An expression of the form TLIMIT(DictADT))
   is synthesised as DictADT.capacityLimit(). *)


(* Binding to Predefined Function COUNT *)

PROCEDURE [COUNT] count ( dict : ProtoDictionary ) : LONGCARD;
(* Required function to return the key/value pair count in a dictionary. *)

(* An expression of the form COUNT(dict)
   is synthesised as DictADT.count(dict). *)


PROCEDURE capacity ( dict : ProtoDictionary ) : LONGCARD;
(* Required function to return the allocated capacity of a dictionary. *)


PROCEDURE entryLimit ( dict : ProtoDictionary ) : LONGCARD;
(* Required function to return the key/value pair limit of a dictionary. *)


PROCEDURE isResizable ( dict : ProtoDictionary ) : BOOLEAN;
(* Required function to return the resizable property of a dictionary. *)


(* Memory Management *)

(* Binding to Predefined Procedure NEW *)

PROCEDURE [NEW] new
  ( VAR dict : ProtoDictionary;
    initWith : ARGLIST OF { key : KeyType; value : ValueType } );
(* Required procedure to allocate and initialise a new dictionary. *)

(* A statement of the form NEW(dict)
   is synthesised as DictADT.new(dict).
   
   A statement of the form
     NEW(dict, key1, val1, key2, val2, key3, val3, ...)
   is synthesised as
     DictADT.new(dict, key1, val1, key2, val2, key3, val3, ...). *)


isMutable ->
PROCEDURE newWithCapacity
  ( VAR dict : ProtoDictionary; capacity : LONGCARD );
(* Procedure to allocate a new dictionary with a given initial capacity.
   The procedure is required when the ADT is mutable. *)


(* Binding to Predefined Procedure RETAIN *)

isRefCounted ->
PROCEDURE [RETAIN] retain ( dict : ProtoDictionary );
(* Procedure to retain a dictionary and prevent its deallocation.
   The procedure is required when the ADT is reference counted. *)

(* A statement of the form RETAIN(dict)
   is synthesised as DictADT.retain(dict). *)


(* Binding to Predefined Procedure RELEASE *)

PROCEDURE [RELEASE] release ( dict : ProtoDictionary );
(* Required procedure to cancel an outstanding retain
   or deallocate a dictionary if no retains are outstanding. *)

(* A statement of the form RELEASE(dict)
   is synthesised as DictADT.release(dict). *)


(* Literal Assignment *)

(* Binding to the := Operator *)

isMutable ->
PROCEDURE [:=] assign
  ( dict : ProtoDictionary;
    literal : ARGLIST OF { key : KeyType; value : ValueType } );
(* Procedure to assign a structured literal to a dictionary.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     dict := {{key1, val1}, {key2, val2}, {key3, val3}, ...}
   is synthesised as
     DictADT.assign(dict, key1, val1, key2, val2, key3, val3, ...). *)


(* Copying *)

(* Binding to Predefined Function DUP *)

PROCEDURE [DUP] newWithCopy ( dict : ProtoDictionary ) : ProtoDictionary;
(* Required function to return a newly allocated copy of a dictionary. *)

(* An expression of the form DUP(dict)
   is synthesised as DictADT.newWithCopy(dict). *)


(* Binding to Predefined Procedure COPY *)

isMutable ->
PROCEDURE [COPY] copy ( source : ProtoDict; target : ProtoDict );
(* Procedure to destructively copy the contents of one dictionary to another.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form COPY(dict1, dict2)
   is synthesised as DictADT.copy(dict1, dict2). *)


(* Value Storage *)

(* Binding to Predefined Procedure STORE *)

isMutable ->
PROCEDURE [STORE] storeValueForKey
 ( string : ProtoDictionary; key : KeyType; value : ValueType );
(* Procedure to store a value for a given key in a dictionary.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form dict[key] := value
   is equivalent to STORE(dict, key, value)
   and is synthesised as DictADT.storeValueForKey(dict, key, value). *)


(* Value Retrieval *)

(* Binding to Predefined Function RETRIEVE *)

PROCEDURE [RETRIEVE] valueForKey
 ( dict : ProtoDictionary; key : KeyType ) : ValueType;
(* Required function to return the value stored for a given key
   in a dictionary. *)

(* An expression of the form dict[key]
   is equivalent to RETRIEVE(dict, key) and
   is synthesised as DictADT.valueForKey(dict, key). *)

(* Invalid Key Retrieval Error Handling *)

(* A user defined invalid-key handler function may be used to change
   the default behaviour when RETRIEVE is called with an invalid key. *)

(* Handler Type *)

invAccessorRetrievalIntercept ->
TYPE HandlerType = PROCEDURE ( VAR ValueType ) : BOOLEAN;
(* Required procedure type for user defined invalid-key handlers. *)

(* An example of an invalid-key handler is given below:
   
   PROCEDURE mayAbortOnInvalidKey
     ( VAR valueToReturn : ValueType ) : BOOLEAN;
   BEGIN
     valueToReturn := default;
     RETURN FALSE
   END mayAbortOnInvalidKey;
   
   This handler tells its caller not to abort and to return value default. *)


(* Handler Installation *)

invAccessorRetrievalIntercept ->
PROCEDURE installHandler ( handler : HandlerType );
(* Required procedure to install a user defined invalid-key handler. *)


(* Value Insertion *)

(* Binding to Predefined Procedure INSERT *)

isMutable ->
PROCEDURE [INSERT] insertKeysAndValues
  ( targetDict : ProtoDictionary;
    keyValueList : ARGLIST OF { key : KeyType; value : ValueType } );
(* Procedure to insert key/value pairs into a target dictionary.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form
     INSERT(dict, key1, val1, key2, val2, key3, val3, ...)
   is synthesised as
     DictADT.insertKeysAndValues
       (dict, key1, val1, key2, val2, key3, val3, ...). *)

isMutable ->
PROCEDURE insertDictionary
  ( targetDict, sourceDict : ProtoDictionary );
(* Procedure to insert the key/value pairs of one dictionary into another.
   The procedure is required when the ADT is mutable. *)


(* Value Removal *)

(* Binding to Predefined Procedure REMOVE *)

isMutable ->
PROCEDURE [REMOVE] removeKeys
  ( dict : ProtoDictionary; keyList : ARGLIST OF KeyType );
(* Procedure to remove one or more key/value pairs from a dictionary.
   The procedure is required when the ADT is mutable. *)

(* A statement of the form REMOVE(dict, key1, key2, key3, ...)
   is synthesised as DictADT.removeKeys(dict, key1, key2, key3, ...).
   
   A statement of the form dict[key] := NIL
   is treated equivalent to REMOVE(dict, key)
   and synthesised as DictADT.removeKeys(dict, key)
   if and only if constant allowsNilStorage is FALSE. *)


(* Membership Test *)

(* Binding to IN syntax *)

PROCEDURE [IN] keyExists ( dict : ProtoDictionary; key : KeyType ) : BOOLEAN;
(* Function to test whether a given key is stored in a dictionary. *)

(* An expression of the form key IN dict
   is synthesised as DictADT.keyExists(dict, key). *)


(* Iteration *)

(* Binding to FOR IN iterator *)

TYPE LoopBodyType = PROCEDURE ( VAR ProtoDictionary, CONST KeyType );
(* Required procedure type to synthesise the body of a for loop. *)

PROCEDURE [FOR] forIterator
  ( VAR dict : ProtoDictionary;
    doStatements : LoopBodyType;
    ascending : BOOLEAN );
(* Required procedure to iterate over all keys of a dictionary in a
   given order and execute the passed in doStatements for each key. *)
   
(* A statement of the form
     FOR key IN dict DO statementSeq END
   is synthesised in two steps.
   
   The loop header is synthesised as
     DictADT.forIterator(dict, forLoopBody, TRUE);
   
   The loop body is synthesised as
     PROCEDURE forLoopBody
       ( VAR dict : DictADT; CONST key : KeyType ) <*INLINE*>;
     BEGIN statementSeq END forLoopBody;
   
   The loop header of a FOR DESCENDING statement is sythesised with
   FALSE passed for parameter ascending in the call to forIterator. *)


(* Relational operations *)

(* Binding to the = and # Operators *)

PROCEDURE [=] isEqual ( dict1, dict2 : ProtoDictionary ) : BOOLEAN;
(* Function to test the equivalence of two dictionaries. *)

(* An expression of the form dict1 = dict2
   is synthesised as DictADT.isEqual(dict1, dict2).
   
   An expression of the form dict1 # dict2
   is synthesised as NOT (dict1 = dict2). *)


(* Conditionally Inhibited Bindings *)

(* None *)


(* Unconditionally Inhibited Bindings *)

(* Arithmetic Operations *)

(* Operations +, -, *, and / are not meaningful for Dictionary ADTs.
   Conforming blueprints may not require binding to these operations. *)

PROCEDURE [+] : NIL; (* inhibited *)

PROCEDURE [-] : NIL; (* inhibited *)

PROCEDURE [*] : NIL; (* inhibited *)

PROCEDURE [/] : NIL; (* inhibited *)


(* Relational Operations *)

(* Operations >, >=, < and <= are not meaningful for Dictionary ADTs.
   Conforming blueprints may not require binding to these operations. *)

PROCEDURE [<] : NIL; (* inhibited *)

PROCEDURE [>] : NIL; (* inhibited *)

(* The SUBSET operation is not meaningful for Dictionary ADTs.
   Conforming blueprints may not require binding to SUBSET. *)

PROCEDURE [SUBSET] : NIL; (* inhibited *)


END ProtoDictionary.