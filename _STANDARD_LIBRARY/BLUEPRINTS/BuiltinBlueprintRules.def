(* (C) 2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Built-in Blueprint Consistency Rules *)

(*PSEUDO*) BLUEPRINT BUILTIN;
(* Not a compilation unit, documentation only *)

(* Classification *)

(* An ADT is deemed a Numeric ADT if binding to TSIGNED is required. *)

(* An ADT is deemed to be a Scalar ADT if binding to any of
   TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF or VAL is required. *)

(* An ADT is deemed to be a Non-Scalar ADT if binding to TSIGNED is
   required but none of TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF nor VAL. *)

(* An ADT is deemed to be a Collection ADT if binding to any of
   TLIMIT, DESCENDING, STORE, RETRIEVE, IN or SUBSET is required. *)

(* A Scalar ADT is deemed a (signed or unsigned) Integer ADT
   if the values bound to TMINEXP and TMAXEXP are both zero. *)

(* An Integer ADT is deemed a Signed Integer ADT
   if the value bound to TSIGNED is TRUE. *)

(* An Integer ADT is deemed an Unsigned Integer ADT
   if the value bound to TSIGNED is FALSE. *)

(* A Scalar ADT is deemed a Real Number ADT
   if one or both values bound to TMINEXP and TMAXEXP is not zero. *)

(* An ADT is allocatable at runtime (aka dynamic)
   if its module type is an opaque pointer or binding to NEW is required. *)

(* An ADT is allocatable at compile time (aka static) if its module
   type is not an opaque pointer and binding to NEW is not required. *)

(* A static ADT is always deemed mutable. *)

(* A dynamic ADT is deemed mutable if binding to any of
   :=, COPY, STORE, INSERT, REMOVE is required. *)


(* Notation *)

(* The notation used in this document follows the EBNF below:

rule :
  condition '->' implication

condition :
  term (( AND NOT? | OR ) term )? |
  NOT term
  ;

implication :
  term ( ('->' term)* | (AND term)* | (OR term)* ) |
  NOT term
  ;

term :
  '[' BindableEntity ( ('=' | '#') (TRUE | FALSE | 0) )? ']'
  ;
*)


(* GENERAL REQUIREMENTS *)


(* Mandatory Pairings *)


(* One-way Dependencies *)

(* TBASE always implies TSIGNED. *)
[TBASE] -> [TSIGNED];

(* Rationale: Paired for integrity.
   TBASE indicates a scalar ADT. Scalar ADTs are always signed. *)


(* RETAIN always implies RELEASE. *)
[RETAIN] -> [RELEASE];

(* Rationale: Paired for integrity.
   RETAIN indicates reference counting.
   Reference counting requires both a retain and release operation. *)


(* DUP always implies runtime allocation. *)
[DUP] -> [NEW];

(* Rationale: Paired for integrity.
   DUP is per definition a runtime allocator function.
   It therefore necessitates a dynamicaly allocatable ADT. *)


(* STORE always implies RETRIEVE. *)
[STORE] -> [RETRIEVE];

(* Rationale: Paired for integrity.
   Mutable ADTs require both storage and retrieval.
   Immutable ADTs require retrieval but no storage. *)


(* NEG always implies ABS. *)
[NEG] -> [ABS];

(* Rationale: Paired for integrity.
   NEG indicates a Signed ADT.
   Signed ADTs require both sign reversal and sign removal.
   Unsigned ADTs require sign removal but no reversal. *)


(* DIV always implies multiplication. *)
[DIV] -> [*];

(* Rationale: Paired for integrity.
   DIV indicates an Integer ADT.
   Integer ADTs require integer division and multiplication.
   Other ADTs may require multiplication but not integer division. *)


(* Mutual Dependencies *)

(* TBASE, SXF and VAL imply each other. *)
[TBASE] -> [SXF] -> [VAL] -> [TBASE];

(* Rationale: Grouped for integrity.
   TBASE implies a Scalar ADT.
   Scalar ADTs require scalar conversion.
   Scalar conversion is per definition limited to Scalar ADTs. *)


(* TBASE, TMIN and TMAX imply each other. *)
[TBASE] -> [TMIN] -> [TMAX] -> [TBASE];

(* Rationale: Grouped for integrity.
   TBASE implies a Scalar ADT.
   Scalar ADTs require a minimal and maximal value.
   Non-scalars do not have a minimal and maximal value. *)


(* NEW and RELEASE imply each other. *)
[NEW] -> [RELEASE] -> [NEW];

(* Rationale: Paired for integrity.
   NEW indicates runtime allocation.
   Runtime allocation requires deallocation.
   Even garbage collectors may need to call RELEASE internally. *)


(* INSERT and REMOVE imply each other. *)
[INSERT] -> [REMOVE] -> [INSERT];

(* Rationale: Paired for integrity. *)


(* DIV and MOD imply each other. *)
[DIV] -> [MOD] -> [DIV];

(* Rationale: Paired for integrity. *)


(* Inhibited Pairings *)


(* One-Way Inhibition *)

(* Absence of TSIGNED always inhibits ABS. *)
NOT [TSIGNED] -> NOT [ABS];

(* Absence of TSIGNED always inhibits NEG. *)
NOT [TSIGNED] -> NOT [NEG];

(* Absence of TSIGNED always inhibits DIV. *)
NOT [TSIGNED] -> NOT [DIV];


(* Mutual Inhibition *)

(* TBASE and TLIMIT are always mutually exclusive. *)
[TBASE] -> NOT [TLIMIT];
[TLIMIT] -> NOT [TBASE];

(* COUNT and LENGTH are always mutually exclusive. *)
[COUNT] -> NOT [LENGTH];
[LENGTH] -> NOT [COUNT];

(* CONCAT and + are always mutually exclusive. *)
[CONCAT] -> NOT [+];
[+] -> NOT [CONCAT];

(* DIV and / are always mutually exclusive. *)
[DIV] -> NOT [/];
[/] -> NOT [DIV];

(* SUBSET and < are always mutually exclusive. *)
[SUBSET] -> NOT [<];
[<] -> NOT [SUBSET];

(* SUBSET and > are always mutually exclusive. *)
[SUBSET] -> NOT [>];
[>] -> NOT [SUBSET];


(* NUMERIC ADT REQUIREMENTS *)


(* Signed and Unsigned ADTs *)

(* Signed ADTs always require NEG. *)
[TSIGNED=TRUE] -> [NEG];

(* Unsigned ADTs always inhibit NEG. *)
[TSIGNED=FALSE] -> NOT [NEG];


(* Scalar ADTs *)

(* Scalar ADTs are always signed. *)
[TBASE] -> [TSIGNED];

(* Scalar ADTs always require scalar properties
    TBASE, TPRECISION, TMINEXP, and TMAXEXP. *)
[TBASE] -> [TPRECISION] -> [TMINEXP] -> [TMAXEXP] -> [TBASE];

(* Scalar ADTs always require TMIN and TMAX. *)
[TBASE] -> [TMIN] -> [TMAX] -> [TBASE];

(* Scalar ADTs always require scalar conversion primitives *)
[TBASE] -> [SXF] -> [VAL] -> [TBASE];



(* For Scalar ADTs, binding to +, - and * shall be required. *)
[TBASE] -> [+];
[TBASE] -> [-];
[TBASE] -> [*];

(* For Real Number ADTs, binding to / shall be required. *)
[TMINEXP#0] OR [TMAXEXP#0] -> [/];

(* For Whole Number ADTs, binding to DIV and MOD shall be required. *)
[TMINEXP=0] AND [TMAXEXP=0] -> [DIV];




(* Unidirectional Dependencies *)

(* TLIMIT requires either COUNT or LENGTH. *)
[TLIMIT] -> [COUNT] OR [LENGTH];

(* RETAIN requires NEW. *)
[RETAIN] -> [NEW];

(* DUP requires NEW. *)
[DUP] -> [NEW];

(* STORE requires RETRIEVE. *)
[STORE] -> [RETRIEVE];

(* If NEW is required, CONCAT requires RETAIN. *)
[NEW] AND [CONCAT] -> [RETAIN];

(* If NEW is required, L-value slicing requires RETAIN. *)
[NEW] AND [..] -> [RETAIN];


(* If SUBSET is required, +, -, * and / are mutually inclusive. *)
[SUBSET] AND [+] -> [-] -> [*] -> [/] -> [+];




(* If the proto literal is CHAR or UNICHAR, LENGTH is required. *)
[CHAR] OR [UNICHAR] -> [LENGTH];

(* If NEW is required, COPY requires DUP. *)
[NEW] AND [COPY] -> [DUP];

(* If for-loop iteration is required, either COUNT or LENGTH is required. *)
[FOR] -> [COUNT] OR [LENGTH];


(* IO *)

(* READ requires WRITE. *)
[READ] -> [WRITE];

(* If STORE is required, WRITE requires READ. *)
[NEW] AND [STORE] AND [WRITE] -> [READ];

[WRITE] AND NOT [NEW] -> [READ];

(* WRITE and WRITEF are mutually inclusive. *)
[WRITE] -> [WRITEF] -> [WRITE];


(* To be reviewed ... *)

[TMIN] -> [CONCAT];
[CONCAT] -> [TMIN];
(* TMIN and CONCAT are mutually exclusive. *)

[DESCENDING] -> [FOR];
(* If DESCENDING is required, for loop iteration is required. *)


END BUILTIN.