(* (C) 2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Built-in Blueprint Consistency Rules *)

(*PSEUDO*) BLUEPRINT BUILTIN;
(* Not a compilation unit, documentation only *)

(* Classification *)

(* An ADT is deemed a Numeric ADT if binding to TSIGNED is required. *)

(* An ADT is deemed to be a Scalar ADT if binding to any of
   TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF or VAL is required. *)

(* An ADT is deemed to be a Non-Scalar ADT if binding to TSIGNED is
   required but none of TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF nor VAL. *)

(* An ADT is deemed to be a Collection ADT if binding to any of
   TLIMIT, DESCENDING, STORE, RETRIEVE, IN or SUBSET is required. *)

(* A Scalar ADT is deemed a (signed or unsigned) Integer ADT
   if the values bound to TMINEXP and TMAXEXP are both zero. *)

(* An Integer ADT is deemed a Signed Integer ADT
   if the value bound to TSIGNED is TRUE. *)

(* An Integer ADT is deemed an Unsigned Integer ADT
   if the value bound to TSIGNED is FALSE. *)

(* A Scalar ADT is deemed a Real Number ADT
   if one or both values bound to TMINEXP and TMAXEXP is not zero. *)

(* An ADT is allocatable at runtime (aka dynamic)
   if its module type is an opaque pointer or binding to NEW is required. *)

(* An ADT is allocatable at compile time (aka static) if its module
   type is not an opaque pointer and binding to NEW is not required. *)

(* A static ADT is always deemed mutable. *)

(* A dynamic ADT is deemed mutable if binding to any of
   :=, COPY, STORE, INSERT, REMOVE is required. *)


(* Notation *)

(* The notation used in this document follows the EBNF below:

rule :
  condition '->' implication

condition :
  term (( AND NOT? | OR ) term )? |
  NOT term
  ;

implication :
  term ( ('->' term)* | (AND term)* | (OR term)* ) |
  NOT term
  ;

term :
  '[' BindableEntity ( ('=' | '#') (TRUE | FALSE | 0) )? ']'
  ;
*)


(* Mandatory Pairings *)

(* One-way Dependencies *)

(* RETAIN always implies RELEASE. *)
[RETAIN] -> [RELEASE];

(* DUP always implies runtime allocation. *)
[DUP] -> [NEW];

(* STORE always implies RETRIEVE. *)
[STORE] -> [RETRIEVE];

(* NEG always implies ABS. *)
[NEG] -> [ABS];

(* DIV always implies multiplication. *)
[DIV] -> [*];


(* Mutual Dependencies *)

(* TMIN and TMAX imply each other. *)
[TMIN] -> [TMAX] -> [TMIN];

(* SXF and VAL imply each other. *)
[SXF] -> [VAL] -> [SXF];

(* NEW and RELEASE imply each other. *)
[NEW] -> [RELEASE] -> [NEW];

(* INSERT and REMOVE imply each other. *)
[INSERT] -> [REMOVE] -> [INSERT];

(* DIV and MOD imply each other. *)
[DIV] -> [MOD] -> [DIV];


(* Inhibit *)

(* TBASE and TLIMIT are always mutually exclusive. *)
[TBASE] -> NOT [TLIMIT];
[TLIMIT] -> NOT [TBASE];

(* COUNT and LENGTH are always mutually exclusive. *)
[COUNT] -> NOT [LENGTH];
[LENGTH] -> NOT [COUNT];

(* CONCAT and + are always mutually exclusive. *)
[CONCAT] -> NOT [+];
[+] -> NOT [CONCAT];

(* DIV and / are always mutually exclusive. *)
[DIV] -> NOT [/];
[/] -> NOT [DIV];

(* SUBSET and < are always mutually exclusive. *)
[SUBSET] -> NOT [<];
[<] -> NOT [SUBSET];

(* SUBSET and > are always mutually exclusive. *)
[SUBSET] -> NOT [>];
[>] -> NOT [SUBSET];


(* Linear Exclusions *)

(* For non-numeric ADTs, ABS, NEG, DIV and MOD are inhibited. *)
NOT [TSIGNED] -> NOT [ABS];
NOT [TSIGNED] -> NOT [NEG];
NOT [TSIGNED] -> NOT [DIV];


(* Numeric ADTs *)

(* Requirements for Signed and Unsigned ADTs *)

(* For Signed ADTs, binding to NEG shall be required. *)
[TSIGNED=TRUE] -> [NEG];

(* For Unsigned ADTs, binding to NEG is inhibited. *)
[TSIGNED=FALSE] -> NOT [NEG];


(* Scalar Properties *)

(* A Scalar ADT shall be required to define properties
   TSIGNED, TBASE, TPRECISION, TMINEXP, and TMAXEXP. *)
[TBASE] -> [TSIGNED];
[TBASE] -> [TPRECISION] -> [TMINEXP] -> [TMAXEXP] -> [TBASE];

(* For Scalar ADTs, binding to TMIN and TMAX shall be required. *)
[TBASE] -> [TMIN];

(* For Scalar ADTs, binding to SXF and VAL shall be required. *)
[TBASE] -> [SXF];

(* For Scalar ADTs, binding to +, - and * shall be required. *)
[TBASE] -> [+];
[TBASE] -> [-];
[TBASE] -> [*];

(* For Real Number ADTs, binding to / shall be required. *)
[TMINEXP#0] OR [TMAXEXP#0] -> [/];

(* For Whole Number ADTs, binding to DIV and MOD shall be required. *)
[TMINEXP=0] AND [TMAXEXP=0] -> [DIV];




(* Unidirectional Dependencies *)

(* TLIMIT requires either COUNT or LENGTH. *)
[TLIMIT] -> [COUNT] OR [LENGTH];

(* RETAIN requires NEW. *)
[RETAIN] -> [NEW];

(* DUP requires NEW. *)
[DUP] -> [NEW];

(* STORE requires RETRIEVE. *)
[STORE] -> [RETRIEVE];

(* If NEW is required, CONCAT requires RETAIN. *)
[NEW] AND [CONCAT] -> [RETAIN];

(* If NEW is required, L-value slicing requires RETAIN. *)
[NEW] AND [..] -> [RETAIN];


(* If SUBSET is required, +, -, * and / are mutually inclusive. *)
[SUBSET] AND [+] -> [-] -> [*] -> [/] -> [+];




(* If the proto literal is CHAR or UNICHAR, LENGTH is required. *)
[CHAR] OR [UNICHAR] -> [LENGTH];

(* If NEW is required, COPY requires DUP. *)
[NEW] AND [COPY] -> [DUP];

(* If for-loop iteration is required, either COUNT or LENGTH is required. *)
[FOR] -> [COUNT] OR [LENGTH];


(* IO *)

(* READ requires WRITE. *)
[READ] -> [WRITE];

(* If STORE is required, WRITE requires READ. *)
[NEW] AND [STORE] AND [WRITE] -> [READ];

[WRITE] AND NOT [NEW] -> [READ];

(* WRITE and WRITEF are mutually inclusive. *)
[WRITE] -> [WRITEF] -> [WRITE];


(* To be reviewed ... *)

[TMIN] -> [CONCAT];
[CONCAT] -> [TMIN];
(* TMIN and CONCAT are mutually exclusive. *)

[DESCENDING] -> [FOR];
(* If DESCENDING is required, for loop iteration is required. *)


END BUILTIN.