(* (C) 2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Built-in Blueprint Consistency Rules *)

(*PSEUDO*) BLUEPRINT BUILTIN;
(* Not a compilation unit, documentation only *)

(* Classification *)

(* An ADT is deemed a Numeric ADT if binding to any of TSIGNED,
   TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF or VAL is required. *)

(* An ADT is deemed to be a Scalar ADT if binding to any of
   TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF or VAL is required. *)

(* An ADT is deemed to be a Non-Scalar ADT if binding to TSIGNED is
   required but none of TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF nor VAL. *)

(* An ADT is deemed to be a Collection ADT if binding to any of
   DESCENDING, STORE, RETRIEVE, IN or SUBSET is required. *)

(* A Scalar ADT is deemed a (signed or unsigned) Integer ADT
   if the values bound to TMINEXP and TMAXEXP are both zero. *)

(* An Integer ADT is deemed a Signed Integer ADT
   if the value bound to TSIGNED is TRUE. *)

(* An Integer ADT is deemed an Unsigned Integer ADT
   if the value bound to TSIGNED is FALSE. *)

(* A Scalar ADT is deemed a Real Number ADT
   if the values bound to TMINEXP and TMAXEXP are not both zero. *)

(* An ADT is allocatable at runtime (aka dynamic)
   if its module type is an opaque pointer or binding to NEW is required. *)

(* An ADT is allocatable at compile time (aka static) if its module
   type is not an opaque pointer and binding to NEW is not required. *)

(* A static ADT is always deemed mutable. *)

(* A dynamic ADT is deemed mutable if binding to any of
   :=, COPY, STORE, INSERT, REMOVE is required. *)


(* Grammar *)

(* The notation used in this document follows the EBNF below:

rule :
  condition '->' implication

condition :
  term (( AND NOT? | OR ) term )?
  ;

implication :
  term ( ('->' term)* | (AND term)* | (OR term)* ) |
  NOT term
  ;

term :
  '[' BindableEntity ( ('=' | '#') (TRUE | FALSE | 0) )? ']'
  ;
*)


(* Mutual Inclusion *)

(* TBASE, TPRECISION, TMINEXP and TMAXEXP are mutually inclusive. *)
[TBASE] -> [TPRECISION] -> [TMINEXP] -> [TMAXEXP] -> [TBASE];

(* TSIGNED having a value of TRUE is mutually inclusive with NEG. *)
[TSIGNED=TRUE] -> [NEG] -> [TSIGNED=TRUE];

(* SXF and VAL are mutually inclusive. *)
[SXF] -> [VAL] -> [SXF];

(* TMIN and TMAX are mutually inclusive. *)
[TMIN] -> [TMAX] -> [TMIN];

(* NEW and RELEASE are mutually inclusive. *)
[NEW] -> [RELEASE] -> [NEW];

(* INSERT and REMOVE are mutually inclusive. *)
[INSERT] -> [REMOVE] -> [INSERT];

(* DIV and MOD are mutually inclusive. *)
[DIV] -> [MOD] -> [DIV];


(* Mutual Exclusions *)

(* TLIMIT and TBASE are mutually exclusive. *)
[TLIMIT] -> NOT [TBASE];
[TBASE] -> NOT [TLIMIT];

(* COUNT and LENGTH are mutually exclusive *)
[COUNT] -> NOT [LENGTH];
[LENGTH] -> NOT [COUNT];

(* CONCAT and + are mutually exclusive *)
[CONCAT] -> NOT [+];
[+] -> NOT [CONCAT];

(* DIV and / are mutually exclusive *)
[DIV] -> NOT [/];
[/] -> NOT [DIV];

(* SUBSET and < are mutually exclusive. *)
[SUBSET] -> NOT [<];
[<] -> NOT [SUBSET];

(* SUBSET and > are mutually exclusive. *)
[SUBSET] -> NOT [>];
[>] -> NOT [SUBSET];


(* Unidirectional Dependencies *)

(* TLIMIT requires either COUNT or LENGTH. *)
[TLIMIT] -> [COUNT] OR [LENGTH];

(* RETAIN requires NEW. *)
[RETAIN] -> [NEW];

(* DUP requires NEW. *)
[DUP] -> [NEW];

(* STORE requires RETRIEVE. *)
[STORE] -> [RETRIEVE];

(* If NEW is required, CONCAT requires RETAIN. *)
[NEW] AND [CONCAT] -> [RETAIN];

(* If NEW is required, L-value slicing requires RETAIN. *)
[NEW] AND [..] -> [RETAIN];

(* If TBASE is required, + and - are mutually inclusive. *)
[TBASE] AND [+] -> [-] -> [+];

(* If TBASE is required, * requires either / or DIV. *)
[TBASE] AND [*] -> [/] OR [DIV];

(* If TBASE is required, / requires *. *)
[TBASE] AND [/] -> [*];

(* If TBASE is required, DIV requires *. *)
[TBASE] AND [DIV] -> [*];

(* If SUBSET is required, +, -, * and / are mutually inclusive. *)
[SUBSET] AND [+] -> [-] -> [*] -> [/] -> [+];

(* Relational operations require TMIN (and TMAX). *)
[<] -> [TMIN];
[>] -> [TMIN];


(* Unidirectional Exclusions *)

(* If TSIGNED is FALSE, NEG is inhibited. *)
[TSIGNED=FALSE] -> NOT [NEG];

(* If values bound to TMINEXP and TMAXEXP
   are both zero, real division is inhibited. *)
[TMINEXP=0] AND [TMAXEXP=0] -> NOT [/];

(* If either value bound to TMINEXP or TMAXEXP
   is not zero, integer division is inhibited. *)
[TMINEXP#0] OR [TMAXEXP#0] -> NOT [DIV];

[TBASE] -> PROCEDURE [TMIN];
(* If TBASE is required, TMIN is required. *)

(* If the proto literal is CHAR or UNICHAR, LENGTH is required. *)
[CHAR] OR [UNICHAR] -> [LENGTH];

(* If NEW is required, COPY requires DUP. *)
[NEW] AND [COPY] -> [DUP];

(* If for-loop iteration is required, either COUNT or LENGTH is required. *)
[FOR] -> [COUNT] OR [LENGTH];


(* IO *)

(* READ requires WRITE. *)
[READ] -> [WRITE];

(* If STORE is required, WRITE requires READ. *)
[NEW] AND [STORE] AND [WRITE] -> [READ];

[WRITE] AND NOT [NEW] -> [READ];

(* WRITE and WRITEF are mutually inclusive. *)
[WRITE] -> [WRITEF] -> [WRITE];


(* To be reviewed ... *)

[TMIN] -> PROCEDURE [CONCAT] : NIL;
[CONCAT] -> PROCEDURE [TMIN] : NIL;
(* TMIN and CONCAT are mutually exclusive. *)

[DESCENDING] -> PROCEDURE [FOR];
(* If DESCENDING is required, for loop iteration is required. *)


END BUILTIN.