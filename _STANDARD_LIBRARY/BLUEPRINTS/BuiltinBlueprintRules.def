(* (C) 2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Built-in Blueprint Consistency Rules *)

(*PSEUDO*) BLUEPRINT BUILTIN;
(* Not a compilation unit, documentation only *)

(* Classification *)

(* An ADT is deemed a Numeric ADT if binding to TSIGNED is required. *)

(* An ADT is deemed to be a Scalar ADT if binding to any of
   TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF or VAL is required. *)

(* An ADT is deemed to be a Non-Scalar ADT if binding to TSIGNED is
   required but none of TBASE, TPRECISION, TMINEXP, TMAXEXP, SXF nor VAL. *)

(* An ADT is deemed to be a Collection ADT if binding to any of
   TLIMIT, DESCENDING, STORE, RETRIEVE, IN or SUBSET is required. *)

(* A Scalar ADT is deemed a (signed or unsigned) Integer ADT
   if the values bound to TMINEXP and TMAXEXP are both zero. *)

(* An Integer ADT is deemed a Signed Integer ADT
   if the value bound to TSIGNED is TRUE. *)

(* An Integer ADT is deemed an Unsigned Integer ADT
   if the value bound to TSIGNED is FALSE. *)

(* A Scalar ADT is deemed a Real Number ADT
   if one or both values bound to TMINEXP and TMAXEXP is not zero. *)

(* An ADT is allocatable at runtime (aka dynamic)
   if its module type is an opaque pointer or binding to NEW is required. *)

(* An ADT is allocatable at compile time (aka static) if its module
   type is not an opaque pointer and binding to NEW is not required. *)

(* A static ADT is always deemed mutable. *)

(* A dynamic ADT is deemed mutable if binding to any of
   :=, COPY, STORE, INSERT, REMOVE is required. *)


(* Notation *)

(* The notation used in this document follows the EBNF below:

rule :
  condition '->' implication

condition :
  term (( AND NOT? | OR ) term )? |
  NOT term
  ;

implication :
  term ( ('->' term)* | (AND term)* | (OR term)* ) |
  NOT term
  ;

term :
  '[' BindableEntity ( ('=' | '#') (TRUE | FALSE | 0) )? ']'
  ;
*)


(* GENERAL REQUIREMENTS *)

(* Mandatory Pairings *)

(* One-way Dependencies *)

[TBASE] -> [TSIGNED];
(* TBASE always implies the presence of TSIGNED. *)

(* Rationale: Integrity.
   TBASE indicates a scalar ADT.
   Scalar ADTs are always signed, but not all signed ADTs are scalars. *)


[TLIMIT] -> [COUNT] OR [LENGTH];
(* TLIMIT always implies the presence of either COUNT or LENGTH. *)

(* Rationale: Integrity.
   TLIMIT indicates a Collection ADT.
   String ADTs always require a length function.
   Non-String Collection ADTs always require a count function. *)


[RETAIN] -> [RELEASE];
(* RETAIN always implies the presence of RELEASE. *)

(* Rationale: Integrity.
   RETAIN indicates reference counting.
   Reference counting requires both a retain and release operation,
   but not all dynamically allocatable ADTs are reference counted. *)


[DUP] -> [NEW];
(* DUP always implies the presence of runtime allocation. *)

(* Rationale: Integrity.
   DUP is per definition a runtime allocator function.
   It therefore necessitates a dynamicaly allocatable ADT. *)


[STORE] -> [RETRIEVE];
(* STORE always implies the presence of RETRIEVE. *)

(* Rationale: Integrity.
   Mutable ADTs require both storage and retrieval.
   Immutable ADTs require retrieval but no storage. *)


[NEG] -> [ABS];
(* NEG always implies the presence of ABS. *)

(* Rationale: Integrity.
   NEG indicates a Signed ADT.
   Signed ADTs require both sign reversal and sign removal.
   Unsigned ADTs require sign removal but no reversal. *)


[DIV] -> [*];
(* DIV always implies the presence of multiplication. *)

(* Rationale: Integrity.
   DIV indicates an Integer ADT.
   Integer ADTs require integer division and multiplication.
   Other ADTs may require multiplication but not integer division. *)


(* Mutual Dependencies *)

[TBASE] -> [TPRECISION] -> [TMINEXP] -> [TMAXEXP] -> [TBASE];
(* TBASE, TPRECISION, TMINEXP and TMAXEXP always imply each other's presence. *)

(* Rationale: Integrity.
   TBASE indicates a Scalar ADT.
   Scalar ADTs require base, precision, eMax and eMin to be implemented. 
   An ADT that defines scalar properties is always a Scalar ADT. *)


[TBASE] -> [TMIN] -> [TMAX] -> [TBASE];
(* TBASE, TMIN and TMAX always imply each other's presence. *)

(* Rationale: Integrity.
   TBASE implies a Scalar ADT.
   Scalar ADTs require a minimal and maximal value.
   An ADT that has a minimal and maximal value is always a Scalar ADT. *)


[TBASE] -> [SXF] -> [VAL] -> [TBASE];
(* TBASE, SXF and VAL always imply each other's presence. *)

(* Rationale: Integrity.
   TBASE implies a Scalar ADT.
   Scalar ADTs require scalar conversion.
   Scalar conversion is per definition limited to Scalar ADTs. *)


[NEW] -> [RELEASE] -> [NEW];
(* NEW and RELEASE always imply each other's presence. *)

(* Rationale: Integrity.
   NEW indicates runtime allocation.
   Runtime allocation requires deallocation.
   Even garbage collectors may need to call RELEASE internally. *)


[INSERT] -> [REMOVE] -> [INSERT];
(* INSERT and REMOVE always imply each other's presence. *)

(* Rationale: Integrity. *)


[DIV] -> [MOD] -> [DIV];
(* DIV and MOD always imply each other's presence. *)

(* Rationale: Integrity. *)


(* Inhibited Pairings *)

(* One-Way Inhibition *)

NOT [TSIGNED] -> NOT [ABS];
(* Absence of TSIGNED always inhibits the presence of ABS. *)

(* Rationale: Correctness.
   Without a signed property, sign removal makes no sense. *)


NOT [TSIGNED] -> NOT [NEG];
(* Absence of TSIGNED always inhibits the presence of NEG. *)

(* Rationale: Correctness.
   Without a signed property, sign reversal makes no sense. *)


NOT [TSIGNED] -> NOT [DIV];
(* Absence of TSIGNED always inhibits the presence of DIV. *)

(* Rationale: Correctness.
   Without a signed property, DIV and MOD make no sense. *)


(* Mutual Inhibition *)

[TBASE] -> NOT [TLIMIT];
[TLIMIT] -> NOT [TBASE];
(* TBASE and TLIMIT always inhibit each other's presence. *)

(* Rationale: Integrity.
   TBASE indicates a Scalar ADT.
   TLIMIT indicates a Collection ADT.
   The two are mutually exclusive. *)


[COUNT] -> NOT [LENGTH];
[LENGTH] -> NOT [COUNT];
(* COUNT and LENGTH always inhibit each other's presence. *)

(* Rationale: Consistency.
   LENGTH is defined exclusively for String ADTs.
   COUNT is defined for Collection ADTs other than String ADTs. *)


[CONCAT] -> NOT [+];
[+] -> NOT [CONCAT];
(* CONCAT and + always inhibit each other's presence. *)

(* Rationale: Correctness.
   Binding to the + operator is for arithmetic operations exclusively.
   CONCAT binds to the + operator for string concatenation.
   The two are mutually exclusive. *)


[DIV] -> NOT [/];
[/] -> NOT [DIV];
(* DIV and / always inhibit each other's presence. *)

(* Rationale: Consistency.
   DIV is defined exclusively for integer division.
   The / operator is defined for non-integer division and set difference. *)


[SUBSET] -> NOT [<];
[<] -> NOT [SUBSET];
(* SUBSET and < always inhibit each other's presence. *)

(* Rationale: Correctness.
   Binding to the < operator is for arithmetic operations exclusively.
   SUBSET binds to the < operator for relational set operations.
   The two are mutually exclusive. *)


[SUBSET] -> NOT [>];
[>] -> NOT [SUBSET];
(* SUBSET and > always inhibit each other. *)

(* Rationale: Correctness.
   Binding to the > operator is for arithmetic operations exclusively.
   SUBSET binds to the > operator for relational set operations.
   The two are mutually exclusive. *)


(* NUMERIC ADT REQUIREMENTS *)

(* Signed and Unsigned ADTs *)

[TSIGNED=TRUE] -> [NEG];
(* Signed ADTs always require NEG. *)

[TSIGNED=FALSE] -> NOT [NEG];
(* Unsigned ADTs always inhibit NEG. *)


(* Scalar ADTs *)

[TBASE] -> [+];
[TBASE] -> [-];
[TBASE] -> [*];
(* Scalar ADTs imply the availability of +, - and * notation. *)

(* Rationale: Consistency.
   TBASE indicates a Scalar ADT.
   Scalar ADTs require arithmetic operators common to all scalars. *)


[TMINEXP#0] OR [TMAXEXP#0] -> [/];
(* Number ADTs imply the availability of / notation. *)

(* Rationale: Consistency.
   TMINEXP or TMAXEXP with a non-zero value indicates a Real Number ADT.
   Real Number ADTs require the real number division operator. *)


[TMINEXP=0] AND [TMAXEXP=0] -> [DIV];
(* Whole Number ADTs imply the availability of DIV and MOD operators. *)

(* Rationale: Consistency.
   TMINEXP and TMAXEXP both with zero value indicate a Whole Number ADT.
   Whole Number ADTs require the integer division and modulus operators. *)


(* COLLECTION ADT REQUIREMENTS *)

(* Concatenation *)

[NEW] AND [CONCAT] -> [RETAIN];
(* If NEW is present, CONCAT implies the presence of RETAIN. *)

(* Rationale: Correctness.
   NEW indicates a dynamically allocatable ADT.
   Concatenation of dynamic ADTs requires reference counting. *)


(* Slicing *)


[NEW] AND [..] -> [RETAIN];
(* If NEW is present, L-value slicing implies the presence of RETAIN. *)

(* Rationale: Correctness.
   NEW indicates a dynamically allocatable ADT.
   L-value slicing of dynamic ADTs requires reference counting. *)


(* Set Operations *)

[SUBSET] AND [+] -> [-] -> [*] -> [/] -> [+];
(* If SUBSET is present, +, -, * and / imply each other's presence. *)

(* Rationale: Integrity.
   SUBSET in combination with any of +, -, * or / indicates a Set ADT.
   Set operations +, -, * and / are required on an all-or-nothing basis. *)



(* If NEW is required, COPY requires DUP. *)
[NEW] AND [COPY] -> [DUP];

(* If for-loop iteration is required, either COUNT or LENGTH is required. *)
[FOR] -> [COUNT] OR [LENGTH];


(* IO *)

(* READ requires WRITE. *)
[READ] -> [WRITE];

(* If STORE is required, WRITE requires READ. *)
[NEW] AND [STORE] AND [WRITE] -> [READ];

[WRITE] AND NOT [NEW] -> [READ];

(* WRITE and WRITEF are mutually inclusive. *)
[WRITE] -> [WRITEF] -> [WRITE];


(* To be reviewed ... *)

[CONCAT] -> [TLIMIT];
(* CONCAT implies the presence of TLIMIT. *)

(* We certainly don't want concatenation for scalars.
   But should it be limited to collections? or even strings? *)


[DESCENDING] -> [FOR];
(* DESCENDING implies the presence of FOR. *)

(* Should this be a mutual dependency? *)


(* If the proto literal is CHAR or UNICHAR, LENGTH is required. *)
[CHAR] OR [UNICHAR] -> [LENGTH];

(* But how about character set ADTs? *)


END BUILTIN.