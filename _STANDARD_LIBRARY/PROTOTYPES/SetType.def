(* (C) 2009-2012 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* Prototype Definition for Static Set ADTs *)

PROTOTYPE SetType;

(* Static Set ADTs must be opaque records to be statically allocatable,
   structured literals may be used *)

PLACEHOLDERS ElementType;

TYPE = OPAQUE RECORD := { VARIADIC OF ElementType };


(* Bindings required for SetType ADTs *)

(* Capacity *)

(* Binding to pervasive function TCOUNT *)

PROCEDURE [TCOUNT] capacity : LONGCARD;
(* Procedure to return the maximum element count a SetType ADT can hold *)

(* An expression of the form TCOUNT(SetTypeADT))
   is synthesised as SetTypeADT.capacity() *)


(* Binding to assignment operator *)

PROCEDURE [:=] assign ( VAR set : SetType;
                        elementList  : VARIADIC OF ElementType );
(* Procedure to assign a structured literal to a value of a SetType ADT. *)

(* A statement of the form set := { element1, element2, ..., elementN }
   is synthesised as assign( set, element1, element2, ... elementN ) *)


(* Setting and querying set membership *)

(* Binding to [ ] notation within left hand entities *)

PROCEDURE [!] setElement ( VAR set : SetType;
                           element : ElementType; value : BOOLEAN );
(* Procedure to include and exclude an element in a SetType ADT variable,
   where values of TRUE include and values of FALSE exclude the element. *)

(* A statement of the form set[element] := value
   is synthesised as setElement( set, element, value) *)


(* Binding to [ ] notation within expressions *)

PROCEDURE [?] isElement ( set : SetType;
                      element : ElementType ) : BOOLEAN;
(* Procedure to test whether an element is included in a SetType ADT
   variable, bound to right hand side [ ] notation for SetType ADTs. *)

(* An expression of the form set[element]
   is synthesised as isElement( set, element ) *)


(* Element count *)

(* Binding to pervasive function COUNT *)

PROCEDURE [COUNT] count ( set : SetType ) : LONGCARD;
(* Procedure to return the element count of a SetType ADT variable *)

(* An expression of the form COUNT(set)
   is synthesised as SetTypeADT.count(set) *)


(* Iteration *)

(* Binding to FOR IN iterator *)

PROCEDURE [FOR] forEnumerator ( VAR set : SetType; doStatements : PROC );

(* Procedure to enumerate over all elements of a SetType ADT variable
   and execute the passed in doStatements for each element. *)
   
(* A statement of the form FOR element IN set DO statementSeq END
   is synthesised as
   <* INLINE *> PROCEDURE statements; BEGIN statementSeq END statements;
   SetTypeADT.forEnumerator( set, statements ); *)


(* Dyadic operations *)

(* Binding to + operator *)

PROCEDURE [+] union ( set1, set2 : SetType ) : SetType;
(* Procedure to return the union of two SetType ADT values *)

(* An expression of the form set1 + set2
   is synthesised as SetTypeADT.union(set1, set2) *)


(* Binding to - operator *)

PROCEDURE [-] difference ( set1, set2 : SetType ) : SetType;
(* Procedure to return the set difference of two SetType ADT values *)

(* An expression of the form set1 - set2
   is synthesised as SetTypeADT.difference(set1, set2) *)


(* Binding to * operator *)

PROCEDURE [*] intersection ( set1, set2 : SetType ) : SetType;
(* Procedure to return the intersection of two SetType ADT values *)

(* An expression of the form set1 * set2
   is synthesised as SetTypeADT.intersection(set1, set2) *)


(* Binding to / operator *)

PROCEDURE [/] symmetricDiff ( set1, set2 : SetType ) : SetType;
(* Procedure to return the symmetric difference of two SetType ADT values *)

(* An expression of the form set1 / set2
   is synthesised as SetTypeADT.symmetricDiff(set1, set2) *)


(* Relational operations *)

(* Binding to = operator *)

PROCEDURE [=] isEqual ( CONST set1, set2 : SetType ) : BOOLEAN;
(* Procedure to test the equivalence of two SetType ADT values *)

(* An expression of the form set1 = set2
   is synthesised as SetTypeADT.isEqual(set1, set2) *)

(* The operation for the # operator is synthesized as NOT (set1 = set2) *)


(* Binding to < operator *)

PROCEDURE [<] isSubset ( CONST set1, set2 : SetType ) : BOOLEAN;
(* Procedure to test whether one SetType ADT value is a subset of another *)

(* An expression of the form set1 > set2
   is synthesised as SetTypeADT.isSubset(set1, set2) *)

(* The operation for the <= operator
   is synthesized as (set1 < set2) OR (set1 = set2) *)


(* Binding to > operator *)

PROCEDURE [>] isSuperset ( CONST set1, set2 : SetType ) : BOOLEAN;
(* Procedure to test whether one SetType ADT value is a superset of another *)

(* The operation for the >= operator
   is synthesized as (set1 > set2) OR (set1 = set2) *)


END SetType.