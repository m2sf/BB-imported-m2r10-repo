Modula-2 R10 Concise Language Description

This document is a concise description of a dialect of the Modula-2 programming
language, tentatively called R10, jointly developed in 2009 and 2010 by
B.Kowarsch and R.Sutcliffe as a modern revision of classic Modula-2.

At the time of writing, the authoritative language report is still work in
progress and has not yet been published. The present document is intended
strictly as a non-authoritative informational source for contributors who
wish to participate in work on the reference compiler, the standard library
and associated compliance test tools. Details may change without prior notice.


The notation used to describe syntax in this document is based on the EBNF
notation used by the lexer and parser generator ANTLR:

* names that start with a capital letter represent terminal symbols
* names that start with a lowercase letter represent non-terminal symbols
* single and double quotes are used to delimit literals
* parentheses are used to group syntactic entities
* the vertical bar is used to separate alternatives
* a preceding tilde is used to denote logical not
* a trailing question mark is used to denote zero or one occurence
* a trailing plus sign is used to denote one or more occurences
* a trailing asterisk is used to denote zero or more occurences
* a colon is used between a production rule's name and its body
* a semicolon is used to terminate a production rule


1 Lexical Entities

1.1 Special Symbols

Special symbols are non-alphanumeric characters or sequences of two
non-alphanumeric characters that have special meaning in the language.

List of Special Symbols

!     denotes ADT binding to [ ]
#     not-equal operator, obsoletes <>
&     synonym for logical AND operator
*     multiplication and set intersection operator
+     addition and set union operator
++    postfix increment operator
,     punctuation, used as a separator in item lists
-     subtraction and set difference operator
--    postfix decrement operator
.     punctuation, used as a separator, decimal point and module terminator
..    range operator
/     division and symmetric set difference operator
:     punctuation, used as a separator between identifiers and formal types
::    type conversion operator
:=    assignment operator
;     punctuation, used as a separator in statement sequences
<     less-than and true-subset relational operator
<=    less-than-or-equal and subset relational operator
=     equal operator
>     greater-than and true-superset relational operator
>=    greather-than-or-equal and superset relational operator
^     pointer dereferencing operator
|     punctuation, used as a separator in case label lists
~     synonym for logical NOT operator
'     single quote, used as a string delimiter
"     double quote, used as a string delimiter
\     escape symbol within a quoted string

[ ]   brackets, used as index operator and to delimit special syntax
( )   parentheses, used to group expressions and to delimit argument lists
{ }   braces, used to delimit structured literals

<*    opening delimiter for pragmas
*>    closing delimiter for pragmas
//    single line comment prefix
(*    opening delimiter for nestable comments
*)    closing delimiter for nestable comments
/*    opening delimiter for non-nestable comments
*/    closing delimiter for non-nestable comments


1.2 Non-Semantic Symbols

Non-semantic symbols are symbols that do not impact the meaning of a program.
They may occur anywhere in a program before or after semantic symbols but not
within them. There are three types of non-semantic symbols:

* pragmas
* comments
* lexical separators


1.2.1 Pragmas

Pragmas are directives used to control the translation process but do not
change the meaning of the program text. Pragmas consist of a pragma name
optionally followed by other symbols, delimited by "<*" and "*>". Pragma
names never conflict with identifiers or reserved words because they
can only occur within pragma delimiters.

There are two types of pragmas:

* implementation defined pragmas
* language defined pragmas

EBNF:

pragma : "<*" pragmaName otherSymbols? "*>" ;

pragmaName : Ident ;


1.2.1.1 Implementation Defined Pragmas

Any implementation may define its own set of pragmas, specific to the compiler.
Implementation defined pragma names must not be all-uppercase words.


1.2.1.2 Language Defined Pragmas

Language defined pragmas use all-uppercase words as pragma names. The pragma
names of language defined pragmas are reserved.

List of Language Defined Pragma Names

IF               INFO             FATAL            MAKE             VOLATILE
ELSIF            WARN             ALIGN            INLINE
ENDIF            ERROR            FOREIGN          NOINLINE


1.2.2 Comments

Comments are symbols ignored by the compiler but intended for a human reader.
There are three types of comments:

* single line comments
* nestable multi-line comments
* non-nestable multi-line comments

EBNF:

Comment : SingleLineComment | NestableComment | NonNestableComment ;
SingleLineComment : "//" ~( EndOfLine )* EndOfLine ;
NestableComment : "(*" ~( "*)" )* NestableComment* "*)" ;
NonNestableComment : "/*" ~( "*/" )* "*/" ;

Examples:

// comment until end-of-line
/* This is a non-nesting comment */
(* This is a comment (* and a comment within *) *)

Non-nestable C-style comments are intended strictly to allow support of
source code processing tools that require such comments. For ordinary
multi-line comments, classic Modula-2 style comments are recommended.


1.2.3 Lexical Separators

Tab and newline are ignored anywhere in a program. The space character is
ignored anywhere other than within string literals. These symbols always
terminate a numeric literal, an identifier, a reserved word or a pragma name.

EBNF:

LexicalSeparator : " " | TAB | NewLine ;
NewLine : LF CR? | CR LF? ;


1.3 Literals

There are three types of literals:

* numeric literals
* string literals
* structured literals


1.3.1 Numeric literals

There are three types of numeric literals

* character code literals
* whole number literals
* real number literals


1.3.1.1 Character Code Literals

Character code literals are base-16 numbers, indicated by suffix "C".

EBNF:

charCode : Digit Base16Digit+ "C" ;

Examples: 0C, 0AC, 7FC


1.3.1.2 Whole Number Literals

There are three types of whole number literals

* base-10, without suffix
* base-2, with suffix "B"
* base-16, with suffix "H"

DecimalValue : Digit+ ;
BinaryValue : BinaryDigit+ "B" ;
Base16Value : Digit Base16Digit+ "H" ;

Examples: 42, 01101010B, 0BEEFH


1.3.1.3 Real Number Literals

Real number literals are base-10 numbers, always with an integral part,
a decimal point and a fractional part, optionally followed by an exponent.

RealValue : Digit+ "." Digit+ ( "E" ( "+" | "-" )? Digit+ )? ;

Examples: 0.0, 123.45, 3.1415926, 7.523012E+12


1.3.2 String Literals

String literals are sequences of characters left- and right-delimited by
single quotes or double quotes.

String : "'" ( Character | '"' )* "'" |
         '"' ( Character | "'" )* '"' ;

Character : Digit | Letter |
	        " " | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" |
            "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" |
            "@" | "[" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~" |
            EscapeSequence ;
Digit : "0" .. "9" ;
Letter : "A" .. "Z" | "a" .. "z" ;
EscapeSequence : "\" ( "0" | "n" | "r" | "t" | "\" | "'" | '"' ) ;

Examples:

"it's nine o'clock"
'he said "Modula-2" and smiled'
"this is the end of the line\n"


1.3.3 Structured Literals

Structured literals are compound values whith comma separated numeric literals,
string literals or structured literals, always enclosed in braces.

constStructuredValue :
	"{" ( constValueComponent ( "," constValueComponent )* )? "}" ;
constValueComponent :
	constExpression ( ( BY | ".." ) constExpression )? ;

Examples:

{ 0 BY 100 }, { 1 .. 10 }
{ "abc", 123, 456.78, { 1, 2, 3 } }
{ 1970, Month.Jan, 1, 0, 0, 0.0, TZ.UTC }


1.4 Identifiers

Identifiers are names for syntactic entities in a program. There are two
types of identifiers:

* user-definable identifiers
* language defined identifiers, aka reserved words


1.4.1 User-definable Identifiers

Identifiers are names that start with a letter, lowline or dollar sign,
followed by any number and combination of letters, lowlines, dollar signs
and digits. User definable identifiers must not coincide with reserved words.
The use of the dollar sign in identifiers should be limited to referencing
entities defined by an operating system API for public use (eg. OpenVMS).

Ident : ( "_" | "$" | Letter ) ( "_" | "$" | Letter | Digit )* ;


1.4.2 Reserved Words

Reserved words are identifiers that have special meaning in the language.

List of Reserved Words

ALIAS            DIV              IMPLEMENTATION   OR               TYPE         
AND              DO               IMPORT           POINTER          UNTIL
ARRAY            ELSE             IN               PROCEDURE        VAR
ASSOCIATIVE      ELSIF            LOOP             RECORD           VARIADIC
BEGIN            END              MOD              REPEAT           WHILE
BY               EXIT             MODULE           RETURN
CASE             FOR              NOT              SET
CONST            FROM             OF               THEN
DEFINITION       IF               OPAQUE           TO


1.5 Symbols Reserved for Language Extensions and External Utilities

1.5.1 Symbols Reserved for Use by Language Extensions

Although not part of the language specification, certain symbols are reserved
specifically for use by language extensions. Three such language extensions
are supported:

* Parallel Modula-2
* Objective Modula-2
* single-pass compilers


1.5.1.1 Symbols Reserved for Parallel Modula-2

The following identifiers are reserved for exclusive use by the Parallel
Modula-2 language extension:

ALL PARALLEL SYNC

The following pragma names are reserved for exclusive use by the Parallel
Modula-2 language extension:

LOCAL SPREAD CYCLE SBLOCK CBLOCK


1.5.1.2 Symbols Reserved for Objective Modula-2

The following identifiers are reserved for exclusive use by the Objective
Modula-2 language extension:

BYCOPY BYREF CLASS CONTINUE CRITICAL INOUT METHOD ON OPTIONAL OUT PRIVATE
PROCECTED PROTOCOL PUBLIC SUPER TRY

The following pragma names are reserved for exclusive use by the Objective
Modula-2 language extension:

FRAMEWORK IBACTION IBOUTLET QUALIFIED


1.5.1.3 Symbols Reserved for Single-Pass Compilers

The following pragma name is reserved for use by single-pass compilers:

FORWARD


1.5.2 Symbols Reserved for Use by External Utilities

To assist external source code processing prior to compilation, the following
symbols are reserved for exclusive use by external source code processors:

?   reserved for use by editors or di-/tri-graph converters
@@  reserved for use by template engine or make utilities
%%  reserved for use by template engine or make utilities

These symbols may only legally occur within quoted strings and comments. Their
use within source code as special control symbols is safe prior to compilation.


2 Compilation Units

A compilation unit is a sequence of source code that can be independently
compiled. There are three types of compilation units:

* a program module
* the interface part of a library module
* the implementation part of a library module

EBNF:

compilationUnit :
    programModule | definitionOfModule | implementationOfModule ;


2.1 Program Modules

A Modula-2 program consists of exactly one program module and zero or more
library modules. A program module does not export any identifiers. The body
of a program module roughly corresponds to the main() function in a C program.

EBNF:

programModule :
    MODULE moduleId ( '[' priority ']' )? ';'
    importList* block moduleId '.'

moduleId : Ident ;


2.2 Definition Part of Library Modules

The definition part of a library module represents the public interface of the
library module. Any identifier defined in the definition part is automatically
available for import by other modules.

EBNF:

definitionOfModule :
    DEFINITION MODULE moduleId ';'
    importList* definition*
    END moduleId '.'


2.3 Implementation Part of Library Modules

The implementation part of a library module represents the implementation of
the library module. Any identifier defined in the corresponding definition
part is automatically available in the implementation part. Any identifier
defined in the implementation part is not available outside of the
implementation part.

EBNF:

implementationOfModule :
    IMPLEMENTATION programModule ;


2.4 Module Initialisation

The body of the implementation part of a library module is the library's
initialisation procedure. It is automatically executed by the Modula-2
runtime environment when a Modula-2 program is run.

The order in which modules are initialised is language defined and depends
on the module dependency graph. During compilation a module dependency graph
is built and the initialisation order is determined by depth-first traversal
order of the dependency graph whereby initialisation takes place for each
node from bottom to top on the way back up.


2.5 Module Termination

Module termination is not a language feature but it is a facility provided
by a library module in the standard library. The termination library provides
an API for client modules that require termination to install their own
termination handlers onto the library's termination handler stack.

The termination library installs its own wind down procedure in the runtime
environment during module initialisation. The wind down procedure then calls
the installed termination handlers in reverse order when the program is about
to be terminated.


3 Import of Identifiers

Identifiers defined in the interface of a library module may be imported by
other modules using an import directive. There are two types of import:

* qualified import
* unqualified import

EBNF:

importList :
    ( FROM moduleId IMPORT ( identList | '*' ) |
    IMPORT Ident '+'? ( ',' Ident '+'? )* ) ';'


3.1 Qualified Import

When an identifier is imported by qualified import, it must be qualified with
the exporting module's module name when it is referenced in the importing
module. This avoids name conflicts when importing identically named
identifiers from different modules.

Example:

IMPORT FileIO; (* qualified import of module FileIO *)
VAR status : FileIO.Status; (* qualified identifier of Status *)


3.1.1 Import Aggregators

A module imported by qualified import may be automatically re-exported to any
importing client module. Modules to be re-exported in this way are marked with
a plus sign after their identifiers.

A module that imports other modules for the sole purpose of re-export is
called an import aggregator. This facility is useful to allow clients to
import an entire library with a single import statement.

Example:

DEFINITION MODULE FooBarBaz;
IMPORT Foo+, Bar+, Baz+; (* import Foo, Bar and Baz into client module *)
END FooBarBaz.

IMPORT FooBarBaz; (* imports all modules imported by FooBarBaz and marked + *)


3.1.2 Import of Abstract Data Type Library Modules

If the interface of a module defines a type that has the same name as the
module, the type is referenced unqualified. This facility is useful in the
construction of abstract data types as library modules.

Example:

DEFINITION MODULE Colour;
TYPE Colour = ( red, green, blue );
(* public interface *)
END Colour.

IMPORT Colour;
VAR colour : Colour;


3.2 Unqualified Import

When an identifier is imported by unqualified import, it is made available in
the importing module as is. This will lead to a name conflict and cause a
compile time error when importing identically named identifiers from different
modules.

Example:

FROM FileIO IMPORT Status; (* unqualified import of Status *)
VAR status : Status; (* unqualified identifier of Status *)


3.2.1 Wildcard Import

An unqualified import directive may import all available identifiers of a
library module by using an asterisk as a wildcard.

Example:

FROM FileIO IMPORT *; (* import all identifiers *)


4 Blocks

*** to do ***


5 Definitions and Declarations

A definition is a directive that defines an identifier in the public interface
of a library module. A declaration is a directive that declares an identifier
in a program module or in the implementation part of a library module.
There are four types of definitions and declarations:

* constant definitions and declarations
* variable definitions and declarations
* type definitions and declarations
* procedure definitions and declarations


5.1 Constant Definitions and Declarations

A constant is an immutable value determined at compile time. A constant may be
defined or declared as an alias of another constant, but it may not be defined
or declared as an alias of a module, a variable, a type or a procedure.

EBNF:

constDefinition :
    CONST ( ( "[" Ident "]" )? Ident "=" constExpression ";" )* ;

constDeclaration :
    CONST ( Ident "=" constExpression ";" )* ;

Examples:

CONST zero = 0;
CONST maxInt = TMAX(INTEGER);


5.2 Variable Definitions and Declarations

A variable is a variant whose value is determined at runtime and may change at
runtime. A variable always has a type which is determined at compile time.

EBNF:

varDefinition :
    VAR ( Ident ( "[" address "]" | "," identList )?
          : ( namedType | anonymousType ) ";" )* ;
varDeclaration : varDefinition ;

Examples:

VAR x, y : REAL;
VAR portA [mappedIOAddr] : OCTET;


5.2.1 Global Variables

A variable defined or declared in the top level of a module has a global life
span. It exists throughout the entire runtime of the program. However, a
global variable does not have global scope. It is only visible within the
module it is defined or declared in and within modules that import it.

A variable declared in the top level of a library module is always exported
immutable. It can be modified within the library module's implementation part
but it cannot be modified within modules that import it.


5.2.2 Local Variables

A variable declared within a procedure has local life span and local scope. It
only exists at the time the procedure is executing and it is only visible
within the procedure it is declared in and within procedures local to the
procedure it is declared in.


5.3 Type Definitions and Declarations

A type is an abstract property that determines the storage size and layout of
variables and the operations that are permitted for variables of the type.

EBNF:

typeDefinition :
    TYPE ( Ident = ( type | opaqueType ) ";" )* ;
typeDeclaration :
    TYPE ( Ident = type ";" )* ;
    
Examples:

TYPE Volume = INTEGER;
TYPE HashTable = OPAQUE;


5.3.1 Strict Name Equivalence

Modula-2 R10 uses strict name equivalence. By default types of different names
are always incompatible even if they are derived from the same base type.

Example:

TYPE Celsius = REAL; Fahrenheit = REAL;
VAR celsius : Celsius; fahrenheit : Fahrenheit;

celsius := fahrenheit; (* compile time error: incompatible types *)

In order to assign values across type boundaries, type conversion is required.

Example:

celsius := (fahrenheit - 32.0) * 100.0/180.0 :: Celsius; (* type conversion *)


5.3.2 Alias Types

If a type is desired to be compatible with another type it must be defined or
declared as an alias type.

Example:

TYPE INT = ALIAS OF INTEGER;
VAR i : INT; j : INTEGER;

i := j; (* i and j are compatible *)


5.3.3 Opaque Types

A type may be defined as an opaque type. The identifier of an opaque type is
available in the library where it is defined and in modules that import it.
However, the implementation details of an opaque type are only available
within the implementation part of the library where it is defined. This
facility is useful for the construction of abstract data types.

There are two types of opaque types:

* opaque pointer types
* opaque record types


5.3.3.1 Opaque Pointers

An opaque pointer type is a pointer to a type whose declaration is hidden in
the corresponding implementation part. Objects of the abstract data type can
only be allocated dynamically at runtime.

EBNF:

opaquePointer : TYPE Ident "=" OPAQUE ";" ;

Example:

DEFINITION MODULE Tree;
TYPE Tree = OPAQUE; (* opaque pointer *)
(* public interface *)
END Tree.

IMPLEMENTATION MODULE Tree;
TYPE Tree = POINTER TO TreeDescriptor;
TYPE TreeDescriptor = RECORD left, right : Tree; value : ValueType END;
(* implementation *)
END Tree.

IMPORT Tree;
VAR tree : Tree;
NEW(tree); (* dynamic allocation of a variable of abstract data type Tree *)


5.3.3.2 Opaque Records

An opaque record type is an opaque type that represents a record type instead
of a pointer to a record type. Objects of the abstract data type can be
allocated either statically as global or local variables or dynamically.

In order for the compiler to be able to allocate a variable of an opaque
record type statically, it must be able to determine its allocation size.
However, the allocation size of a record can only be determined from the
record type's declaration. For this reason, the declaration of an opaque
record type is lexically located in the definition part where it is defined
but it is semantically treated as if it was hidden in the corresponding
implementation part. Only the identifier of an opaque record is visible to
modules that import it. Its internal structure is not available to them.

EBNF:

opaqueRecord : TYPE Ident "=" OPAQUE recordType ";" ;

Example:

DEFINITION MODULE BigInteger;
TYPE BigInteger = OPAQUE RECORD highDigits, lowDigits : INTEGER END;
(* public interface *)
END BigInteger.

IMPORT BigInteger;
VAR bigInt : BigInteger; i : INTEGER;
i := bigInt.highDigits; (* compile time error: hidden component *)


5.3.4 Anonymous Types

An anonymous type is a type that does not have a type identifier associated
with it. However, in languages with name equivalence, the names of the types
of variables must be examined to determine whether or not they are assignment
or expression compatible. If the types do not have names, then compatibility
cannot be determined. For this reason, anonymous types are of very limited use
in languages with name equivalence.

Modula-2 follows name equivalence for all types other than procedure types and
formal array and pointer parameters. A procedure is compatible with a procedure
type if their respective signatures match. An array is compatible with a formal
array parameter if their respective component types match. A pointer is
compatible with a formal pointer parameter if the respective types they
point to match. These types are thus permitted as anonymous types:

EBNF:

anonymousType : arrayType | pointerType | procedureType ;


5.3.5 Enumeration Types

An enumeration type is an ordinal type whose legal values are defined by
a list of identifiers.

EBNF:

enumerationType :
    TYPE Ident "=" "(" ( ( "+" namedType ) | ident )
                         ( "," ( ( "+" namedType ) | ident ) )* ")" ";" ;

Example:

TYPE Colours = ( red, green, blue );

The list of identifiers that define the legal value of an enumeration type
may contain references to other enumeration types. When another enumeration
type is referenced within an enumerated list all the identifiers listed in
the referenced type become legal values of the new type.

Example:

TYPE MoreColours = ( +Colour, orange, magenta, cyan );
(* equivalent to: ( red, green, blue, orange, magenta, cyan ) *)

When referencing an enumerated value, its identifier must always be qualified
with the name of its type. This requirement fixes a flaw in classic Modula-2
where importing enumeration types could cause name conflicts.

Example:

VAR colour : Colours;
colour := Colours.green; (* qualified identifier of value green *)


5.3.6 Array Types

5.3.6.1 Indexed Array Types

5.3.6.2 Associative Array Types

5.3.7 Record Types

5.3.8 Set Types

5.3.9 Pointer Types

5.3.10 Procedure Types


5.4 Procedure Definitions and Declarations


6 Statements

*** to do ***


7 Expressions

*** to do ***


8 Structured Values

*** to do ***


9 Pragmas

Pragmas are directives used to control or influence the translation process
but they do not change the meaning of the program text.

There are two types of pragmas:

* implementation defined pragmas
* language defined pragmas


9.1 Implementation Defined Pragmas

Implementation defined pragmas are compiler specific and non-portable. They
are easily recognisable because their pragma names are either all-lowercase
or mixed-case but never all-uppercase words.

EBNF:

implementationDefinedPragma :
    "<*" pragmaName ( "+" | "-" | "=" ( Ident | Number ) )? "*>" ;

pragmaName : Ident ;


9.2 Language Defined Pragmas

Language defined pragmas are portable across implementations. They are easily
recognisable because their pragma names are all-uppercase words. There are
three groups of language defined pragmas:

* pragmas to control conditional compilation
* pragmas to emit console messages during compilation
* pragmas to control, influence or optimise code-generation


9.2.1 Conditional Compilation Pragmas

Conditional compilation pragmas are used to compile portions of the source
text only if a certain condition is met. The condition must be a compile
time expression.

EBNF:

conditionalCompilationPragma :
    "<*" ( IF | ELSIF ) constExpression | ELSE | ENDIF "*>" ;

Example:

TYPE Model = ( small, large, custom );

<* IF TSIZE(INTEGER) = 2 *>
CONST model = Model.small;
<* ELSIF TSIZE(INTEGER) = 4 *>
CONST model = Model.large;
<* ELSIF TSIZE(INTEGER) MOD 2 = 0 *>
CONST model = Model.custom;
<* ELSE *>
<* FATAL "unsupported type model." *>
<* ENDIF *>


9.2.2 Compile Time Console Message Pragmas

Compile time console message pragmas are used to emit console messages during
compilation. There are four types of message pragmas:

* pragmas emitting informational messages
* pragmas emitting compilation warnings
* pragmas emitting compilation errors
* pragmas emitting fatal compilation errors

Informational messages and warnings do not cause the compilation to fail.
Error messages cause the compilation to fail but continue. Fatal messages
cause the compilation to fail and abort immediately.

EBNF:

compileTimeMessagePragma :
    "<*" ( INFO | WARN | ERROR | FATAL ) quotedStringLiteral "*>" ;

Example:

<* FATAL "unsupported target architecture." *>


9.2.3 Code Generation Pragmas

Code generation pragmas are used to control or influence code generation and
optimisation. There are six code generation pragmas:

* pragma to force specified memory alignment
* pragma to force specified calling convention
* pragma to cause the build system to invoke an external utility
* pragma to suggest inlining a procedure
* pragma to suggest not inlining a procedure
* pragma to mark a variable as volatile

EBNF:

codeGenerationPragma :
    "<*" ( ALIGN "=" constExpression |
           FOREIGN ( "=" quotedStringLiteral )? |
           MAKE "=" quotedStringLiteral |
           INLINE | NOINLINE | VOLATILE ) "*>" ;

Examples:

TYPE Point = RECORD <* ALIGN = 8*TSIZE(CARDINAL) *> x, y : OCTET END;
<* FOREIGN = "C" *> PROCEDURE atoi ( CONST s : ARRAY OF CHAR ) : INTEGER;
<* MAKE = "genhashes foo bar baz > Hashes.def" *>
<* INLINE *> PROCEDURE P;
<* NOINLINE *> PROCEDURE Q;
VAR <* VOLATILE *> signal : Signal;


10 Pervasive Identifiers

Pervasive Identifiers are predefined identifiers that are available in every
scope of a program without having to import them. Unlike reserved words,
pervasive identifiers may be redefined by libraries or program modules.

There are five groups of pervasive identifiers:

* predefined constants
* predefined types
* predefined procedures
* predefined functions
* built-in lexical macros


10.1 Predefined Constants

There are three predefined constants:

NIL    invalid pointer value, shorthand for 0 :: POINTER TO CONST OCTET
TRUE   shorthand for BOOLEAN.TRUE
FALSE  shorthand for BOOLEAN.FALSE


10.2 Predefined Types

There are twelve predefined types:

BOOLEAN     boolean type, TYPE BOOLEAN = ( TRUE, FALSE );
BITSET      bitset type of same size as CARDINAL
LONGBITSET  bitset type of same size as LONGCARD
CHAR        7-bit character type, first 128 code points of UTF-8
UNICHAR     4-octet character type, all code points of UTF-32
OCTET       unsigned 8-bit integer type
CARDINAL    unsigned integer type, 2*n octets for n >= 1
LONGCARD    unsigned integer type, 2*n octets for n >= 1
INTEGER     signed integer type, 2*n octets for n >= 1
LONGINT     signed integer type, 2*n octets for n >= 1
REAL        real number type
LONGREAL    double precision real number type

Although these types are predefined, their IO operations are not. The IO
operations corresponding to READ, WRITE and WRITEF for pervasive types are
provided in the standard library and need to be imported to become available.


10.3 Predefined Procedures

All predefined procedures are Wirthian macros. They act and look like library
defined procedures but they may not be assigned to procedure variables, may
not be passed to a procedure as parameters and calls to them are replaced by
the compiler with a call to a corresponding library procedure.

There are five predefined procedures:

NEW DISPOSE READ WRITE WRITEF


10.3.1 Procedure NEW

Procedure NEW is used to dynamically allocate storage for a variable of a
pointer type. Its pseudo-definition is:

PROCEDURE NEW ( VAR p : <anyPointerType>; (*OPTIONAL*) n : <unsignedType> );

A call to procedure NEW is replaced by the compiler with a call to library
procedure ALLOCATE which must be imported before NEW can be used. The standard
library provides an ALLOCATE procedure in module Storage.

Library procedure ALLOCATE always requires a second parameter to specify the
allocation size of the type that the pointer variable points to. The compiler
automatically determines the allocation size for the pointer variable passed
to NEW and passes the appropriate size value as a second parameter to library
procedure ALLOCATE when it replaces the procedure call.

Example:

TYPE FooPtr = POINTER TO Foo;
VAR fooptr : FooPtr;

NEW(fooptr); (* replaced by ALLOCATE(fooptr, TSIZE(Foo)); *)

When NEW is used to allocate storage for a variable of indeterminate type
a second parameter is required to pass the determinant value for the type.

Example:

TYPE VLA = RECORD items : CARDINAL; array : ARRAY items OF INTEGER END;
TYPE VLAPtr = POINTER TO VLA;
VAR v : VLAPtr;

NEW(v, 100); (* replaced by ALLOCATE(v, TSIZE(VLA) + 100*TSIZE(INTEGER)); *)


10.3.2 Procedure DISPOSE

Procedure DISPOSE is used to deallocate storage that was earlier allocated by
a call to procedure NEW. Its pseudo-defintion is:

PROCEDURE DISPOSE ( VAR p : <anyPointerType> );

A call to procedure DISPOSE is replaced by the compiler with a call to a
library procedure DEALLOCATE which must be imported before DISPOSE can be
used. The standard library provides a DEALLOCATE procedure in module Storage.
Procedure DISPOSE always requires a single parameter only.

Examples:

DISPOSE(fooptr); (* replaced by DEALLOCATE(fooptr, TSIZE(Foo)); *)

DISPOSE(v); (* replaced by
               DEALLOCATE(v, TSIZE(VLA) + v^.items*TSIZE(INTEGER)); *)


10.3.3 Procedure READ

Procedure READ is used to read a value from a file or stream and assign it to
a variable. Its pseudo-definition is:

PROCEDURE READ ( f : File; VAR v : <anyType> );

A call to procedure READ is replaced by the compiler with a call to a library
procedure Read which must be defined in a library module that has the same
name as the type of the variable for which a value is being read.

The standard library provides a Read procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call READ on library defined types, the library module
that defines the type must have the same name as the type and it must provide
its own Read procedure.

Examples:

IMPORT PervasiveIO;
VAR n : CARDINAL;
READ(stdIn, n); (* replaced by CARDINAL.Read(stdIn, n); *)

IMPORT BCD;
VAR balance : BCD;
READ(stdIn, balance); (* replaced by BCD.Read(stdIn, balance); *)


10.3.4 Procedure WRITE

Procedure WRITE is used to write a value to a file or stream. Its pseudo-
definition is:

PROCEDURE WRITE ( f : File; v : <anyType> );

A call to procedure WRITE is replaced by the compiler with a call to a library
procedure Write which must be defined in a library module that has the same
name as the type of the value being written.

The standard library provides a Write procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call WRITE on library defined types, the library module
that defines the type must have the same name as the type and it must provide
its own Write procedure.

Examples:

IMPORT PervasiveIO;
VAR n : CARDINAL;
WRITE(stdOut, n); (* replaced by CARDINAL.Write(stdOut, n); *)

IMPORT BCD;
VAR balance : BCD;
WRITE(stdOut, balance); (* replaced by BCD.Write(stdOut, balance); *)


10.3.5 Procedure WRITEF

Procedure WRITEF is used to write one or more values to a file or stream using
a given format depending on a format string. Its pseudo-definition is:

PROCEDURE WRITEF ( f : File; fmt : ARRAY OF CHAR; v : VARIADIC OF <anyType> );

A call to procedure WRITEF is replaced by the compiler with a call to a
library procedure WriteF which must be defined in a library module that has
the same name as the type of the value being written.

The standard library provides a WriteF procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call WRITEF on library defined types, the library
module that defines the type must have the same name as the type and it must
provide its own WriteF procedure.

Procedure WRITEF is variadic. It accepts one or more values to be written.
However, all values must be of the same type. The format string strictly
determines the appearance of values only. This is in contrast to the printf
function of C where the format string also determines the types of values.
In Modula-2 R10 all values must be of the same value to ensure type safety.

Examples:

IMPORT PervasiveIO;
VAR n1, n2, n3 : CARDINAL;
WRITEF(stdOut, "", n1, n2, n3); (* replaced by
                                   CARDINAL.WriteF(stdOut, "", n1, n2, n3); *)

IMPORT BCD;
VAR balance : BCD;
WRITEF(stdOut, "", balance); (* replaced by BCD.WriteF(stdOut, "", balance); *)


10.4 Predefined Functions

Predefined functions act and look like library defined functions but they may
not be assigned to procedure variables, may not be passed to a procedure as
parameters and calls to them are typically replaced by the compiler with
an expression rather than a call to a corresponding function.

There are 16 predefined functions:

ABS NEG ODD PRED SUCC ORD CHR COUNT SIZE HIGH LENGTH NEXTV TMIN TMAX TSIZE VAL


10.4.1 Function ABS

Function ABS returns the absolute value of its operand. Its operand may be of
any Z-Type, R-Type, C-Type or V-Type. Its return type is always the same as
the operand type. Its pseudo-definiton is:

PROCEDURE ABS ( x : <numericType> ) : <operandType> ;


10.4.2 Function NEG

Function NEG returns the sign reversed value of its operand. Its operand may
be of any Z-Type, R-Type, C-Type or V-Type. Its return type is always the same
as the operand type. Its pseudo-definiton is:

PROCEDURE NEG ( x : <numericType> ) : <operandType> ;


10.4.3 Function ODD

Function ODD returns TRUE if its operand operand is an odd number or FALSE if
it is not. Its operand may be of any Z-Type. Its return type is the boolean
type. Its pseudo-definiton is:

PROCEDURE ODD ( x : <Z-Type> ) : BOOLEAN ;


10.4.4 Function PRED

Function PRED returns the n-th predecessor of its first operand where n is the
second operand. Its first operand may be of any ordinal type and its second
operand may be of any unsigned type. Its return type is always the same as
the the first operand type. Its pseudo-definition is:

PROCEDURE PRED ( x : <ordinalType>; n : <unsignedType> ) : <typeOf(x)> ;


10.4.5 Function SUCC

Function SUCC returns the n-th successor of its first operand where n is the
second operand. Its first operand may be of any ordinal type and its second
operand may be of any unsigned Z-Type. Its return type is always the same as
the the first operand type. Its pseudo-definition is:

PROCEDURE SUCC ( x : <ordinalType>; n : <unsignedType> ) : <typeOf(x)> ;


10.4.6 Function ORD

Function ORD returns the ordinal value of its operand. Its operand may be of
any ordinal type. Its return type is the Z-Type. Its pseudo-definition is:

PROCEDURE ORD ( x : <ordinalType> ) : <Z-Type> ;


10.4.7 Function CHR

Function CHR returns the character whose code point is its operand. Its
operand may be of any unsigned Z-Type. If the value of its operand is less
than 128 then its return type is CHAR, otherwise its return type is UNICHAR.
Its pseudo-definition is:

PROCEDURE CHR ( x : <unsignedType> ) : <charOrUnicharType> ; 


10.4.8 Function COUNT

Function count returns the number of items stored in its operand. Its operand
may be of any set type or collection type. Its return type is LONGCARD.
Its pseudo-definition is:

PROCEDURE COUNT ( c : <setOrCollectionType> ) : LONGCARD ;


10.4.9 Function SIZE

Function SIZE returns the allocation size of its operand. The value returned
represents the number of octets allocated for its operand. Its operand may be
a variable of any type. Its return type is LONGCARD. Its pseudo-defintion is:

PROCEDURE SIZE ( variable : <anyType> ) : LONGCARD ;


10.4.10 Function HIGH

Function HIGH returns the highest subscript of its operand. Its operand may be
a variable of an indexed array type or the identifier of an open array para-
meter or variadic parameter list. Its return type is LONGCARD. Its pseudo-
definition is:

PROCEDURE HIGH ( ident : <arrayOrVariadicList> ) : LONGCARD ;


10.4.11 Function LENGTH

Function LENGTH returns the number of characters in its operand. Its operand
may be of any character array type. Its return type is LONGCARD. Its pseudo-
definition is:

PROCEDURE LENGTH ( s : <characterArray> ) : LONGCARD ;


10.4.12 Function NEXTV

Function NEXTV returns a pointer to the next item in a value-terminated
variadic parameter list or NIL if the end of parameter list has been reached.
Its operand is an identifier of a value-terminated variadic parameter list.
Its return type is a pointer to the base type of the variadic parameter list.
Its pseudo-definition is:

PROCEDURE NEXTV ( ident : <variadicList> ) : <pointerToVariadicBaseType> ;


10.4.13 Function TMIN

Function TMIN returns the smallest legal value of its operand. Its operand is
an identifier denoting any Z-Type or R-Type. Its return type is the operand.
Its pseudo-definition is:

PROCEDURE TMIN ( T : <typeIdentifier> ) : <T> ;


10.4.14 Function TMAX

Function TMIN returns the largest legal value of its operand. Its operand is
an identifier denoting any Z-Type or R-Type. Its return type is the operand.
Its pseudo-definition is:

PROCEDURE TMAX ( T : <typeIdentifier> ) : <T> ;


10.4.15 Function TSIZE

Function TSIZE returns the required allocation size its operand.

Function TSIZE returns the required allocation size of a type. The value
returned represents the number of octets required to allocate a variable of
the type denoted by its operand. Its operand is an identifier denoting a type.
Its return type is LONGCARD. Its pseudo-defintion is:

PROCEDURE TSIZE ( T : <typeIdentifier> ) : LONGCARD ;


10.4.16 Function VAL

Function VAL is a macro that is provided only as a measure of legacy support.
Any invocation is replaced by an equivalent type conversion expression. The
invocation 'VAL(T, x)' is replaced by type conversion expression 'x :: T'.

PROCEDURE VAL ( T : <typeIdentifier>; x : <anyType> ) : <T> ; => x :: T

CAUTION: This macro may be deprecated in a future revision and its use should
be avoided. The type conversion operator :: should always be used instead.


10.5 Built-in Lexical Macros

User-definable lexical macros are not provided in Modula-2 (on purpose), but
there are two built-in lexical macros: MIN and MAX.

Macro MIN is replaced with the smallest constant from its variadic argument
list and Macro MAX is replaced with the largest constant from its variadic
argument list. All arguments must be numeric constants or numeric constant
expressions. Examples:

x := MIN( 1, 2, 3 ) => x := 1
x := MAX( 1, 2, 3 ) => x := 3


11 Generics

Syntax for generics programming is not provided in Modula-2 R10 (on purpose).
Instead, generics programming is supported via the Modula-2 Template Engine,
or M2TE, a free-text templating utility that is external to the compiler.

The M2TE utility is invoked by passing the name of a template file and one or
more translations for placeholders in the template file as parameters. It then
recursively replaces all the placeholders with their respective translations,
thereby generating the source text for a library module that is then written
to a set of Modula-2 source files available for import by any Modula-2 library
or program.

The M2TE utility recognises any string prefixed and suffixed by @@ as a place-
holder and any line that starts with %% as a comment not to be copied into the
output. To produce these symbols verbatim they may be escaped with backquote.

The M2TE utility may be invoked manually or automatically by the compiler on a
generate-on-demand basis using the MAKE pragma within a Modula-2 source file.

EBNF:

m2teInvocation :
    "m2te" templateFilename ( placeholderName ":" translation )*

By convention, the first placeholder name is always "module", standing in for
the name of the module to be generated.

Example:

$ m2te Stack module:IntegerStack componentType:INTEGER

The example above invokes the M2TE utility to read template files Stack.def
and Stack.mod, replace any occurences of the placeholders "module" with
"IntegerStack" and "componentType" with "INTEGER", and write the resulting
output into files named IntegerStack.def and IntegerStack.mod respectively.

The MAKE pragma may be used to generate a module on demand from within the
source text of a client module or program.

Example:

<* MAKE = "Stack module:IntegerStack componentType:INTEGER" *>
IMPORT IntegerStack; (* import the generated module *)

The standard library provides a portfolio of generic templates for commonly
used abstract data types. A list of templates and their brief descriptions
can be found in the Standard Library section of this document.


12 Standard Library

The public repository with the complete definition parts of the Modula-2 R10
standard library is available at:

http://bitbucket.org/trijezdci/m2r10stdlib/src

A list of modules with a brief description for each module is given below.


12.1 Pseudo Modules

Pseudo modules provide interfaces to the system or the compiler itself and
are therefore built-in. However, the identifiers they provide need to be
expclicity imported to be availble.

There are four mandatory pseudo modules and one optional pseudo module:

ATOMIC.def            provides atomic intrinsics
SYSTEM.def            access to system dependent resources
RUNTIME.def           interface to the Modula-2 runtime system
COMPILER.def          interface to the Modula-2 compile-time system
ASSEMBLER.def         access to target dependent inline assember (optional)


12.2 Memory Management Modules

Storage.def           dynamic memory allocator


12.3 Modules for Exception Handling and Termination

Exceptions.def        exception handling
Termination.def       termination handling


12.4 File System Modules

Filesystem.def        file system operations using absolute paths
DefaultDir.def        file system operations relative to a working directory
Pathnames.def         operating system independent pathname operations


12.5 File IO Modules

FileIO.def            file oriented input and output
TextIO.def            text file based input and output
RegexIO.def           regular expression based input and output
Scanner.def           primitives for scanning text files
Terminal.def          terminal based input and output


12.6 IO Modules for SYSTEM Types

BYTE.def              IO module for type BYTE
WORD.def              IO module for type WORD
ADDRESS.def           IO module for type ADDRESS


12.7 IO Modules for Pervasive Types:

PervasiveIO.def       aggregator module to import all pervasive IO modules
BOOLEAN.def           IO module for type BOOLEAN
BITSET.def            IO module for type BITSET
LONGBITSET.def        IO module for type LONGBITSET
CHAR.def              IO module for type CHAR
ARRAYOFCHAR.def       IO module for ARRAY OF CHAR types
UNICHAR.def           IO module for type UNICHAR
ARRAYOFUNICHAR.def    IO module for ARRAY OF CHAR types
OCTET.def             IO module for type OCTET
CARDINAL.def          IO module for type CARDINAL
LONGCARD.def          IO module for type LONGCARD
INTEGER.def           IO module for type INTEGER
LONGINT.def           IO module for type LONGINT
REAL.def              IO module for type REAL
LONGREAL.def          IO module for type LONGREAL


12.8 Library Modules Implementing Basic Types

BS16.def              16-bit bitset type
BS32.def              32-bit bitset type
BS64.def              64-bit bitset type
BS128.def             128-bit bitset type
CARD16.def            16-bit unsigned integer type
CARD32.def            32-bit unsigned integer type
CARD64.def            64-bit unsigned integer type
CARD128.def           128-bit unsigned integer type
INT16.def             16-bit signed integer type
INT32.def             32-bit signed integer type
INT64.def             64-bit signed integer type
INT128.def            128-bit signed integer type
BCD.def               single precision binary coded decimals
LONGBCD.def           double precision binary coded decimals
COMPLEX.def           single precision complex number type
LONGCOMPLEX.def       double precision complex number type
CHARSET.def           character set type
STRING.def            dynamic ASCII strings
UNISTRING.def         dynamic unicode strings
Unsigned24.def        unsigned integer subrange type with values from 0 to 23
Unsigned31.def        unsigned integer subrange type with values from 1 to 31
Unsigned60.def        unsigned integer subrange type with values from 0 to 59
UnsignedReal60.def    real subrange type with values from 0.0 to 59.999


12.9 Modules Defining Alias Types

Bitsets.def           alias types for bitsets with guaranteed widths
Cardinals.def         alias types for unsigned integers with guaranteed widths
Integers.def          alias types for signed integers with guaranteed widths
SHORTBITSET.def       alias type for bitset with smallest width
LONGLONGBITSET.def    alias type for bitset with largest width
SHORTCARD.def         alias type for unsigned integers with smallest width
LONGLONGCARD.def      alias type for unsigned integers with largest width
SHORTINT.def          alias type for signed integers with smallest width
LONGLONGINT.def       alias type for signed integers with largest width


12.10 Modules Providing Math for Basic Types

RealMath.def          mathematic constants and functions for type REAL
LongRealMath.def      mathematic constants and functions for type LONGREAL
BCDMath.def           mathematic constants and functions for type BCD
LongBCDMath.def       mathematic constants and functions for type LONGBCD
ComplexMath.def       mathematic constants and functions for type COMPLEX
LongComplexMath.def   mathematic constants and functions for type LONGCOMPLEX


12.11 Modules Providing Primitives for Text Handling

ASCII.def             mnemonics and macro-functions for ASCII characters
Regex.def             Modula-2 regular expression library
RegexConv.def         conversion library for regular expression syntax


12.12 Modules for Date and Time Handling

TZ.def                time zone offsets and abbreviations
Time.def              compound time with day, hour, minute, sec/msec components
DateTime.def          compound calendar date and time
TimeUnits.def         date and time base units
SysClock.def          interface to the system clock


12.12 Modules with Legacy Interfaces

LegacyPIM.def         selected legacy PIM functions and procedures
LegacyISO.def         selected legacy ISO functions and procedures


12.13 Template Library

Stack.def             generic stack template
Queue.def             generic queue template
DEQ.def               generic double ended queue template
PriorityQueue.def     generic priority queue template
AATree.def            generic AA tree template
SplayTree.def         generic Splay tree template
PatriciaTrie.def      generic Patricia trie template
DynamicArray.def      generic dynamic array template
KeyValueStore.def     generic key value storage template
SubrangeInteger.def   generic integer subrange type template
NonZeroIndexArray.def generic non-zero index array type template


[status: May, 12, 2010] (C) 2010 B.Kowarsch & R.Sutcliffe. All rights reserved.