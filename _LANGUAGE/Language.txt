Modula-2 R10 Concise Language Description

This document is a concise description of a dialect of the Modula-2 programming
language, tentatively called R10, jointly developed in 2009 and 2010 by
B.Kowarsch and R.Sutcliffe as a modern revision of classic Modula-2.

At the time of writing, the authoritative language report is still work in
progress and has not yet been published. The present document is intended
strictly as a non-authoritative informational source for contributors who
wish to participate in work on the reference compiler, the standard library
and associated compliance test tools. Details may change without prior notice.


The notation used to describe syntax in this document is based on the EBNF
notation used by the lexer and parser generator ANTLR:

* names that start with a capital letter represent terminal symbols
* names that start with a lowercase letter represent non-terminal symbols
* single and double quotes are used to delimit literals
* parentheses are used to group syntactic entities
* the vertical bar is used to separate alternatives
* a preceding tilde is used to denote logical not
* a trailing question mark is used to denote zero or one occurence
* a trailing plus sign is used to denote one or more occurences
* a trailing asterisk is used to denote zero or more occurences
* a colon is used between a production rule's name and its body
* a semicolon is used to terminate a production rule


1 Lexical Entities

1.1 Special Symbols

Special symbols are non-alphanumeric characters or sequences of two
non-alphanumeric characters that have special meaning in the language.

List of Special Symbols

!     denotes ADT binding to [ ]
#     not-equal operator, obsoletes <>
&     synonym for logical AND operator
*     multiplication and set intersection operator
+     addition and set union operator
++    postfix increment operator
,     punctuation, used as a separator in item lists
-     subtraction and set difference operator
--    postfix decrement operator
.     punctuation, used as a separator, decimal point and module terminator
..    range operator
/     division and symmetric set difference operator
:     punctuation, used as a separator between identifiers and formal types
::    type conversion operator
:=    assignment operator
;     punctuation, used as a separator in statement sequences
<     less-than and true-subset relational operator
<=    less-than-or-equal and subset relational operator
=     equal operator
>     greater-than and true-superset relational operator
>=    greather-than-or-equal and superset relational operator
^     pointer dereferencing operator
|     punctuation, used as a separator in case label lists
~     synonym for logical NOT operator
'     single quote, used as a string delimiter
"     double quote, used as a string delimiter
\     escape symbol within a quoted string

[ ]   brackets, used as index operator and to delimit special syntax
( )   parentheses, used to group expressions and to delimit argument lists
{ }   braces, used to delimit structured literals

<*    opening delimiter for pragmas
*>    closing delimiter for pragmas
//    single line comment prefix
(*    opening delimiter for nestable comments
*)    closing delimiter for nestable comments
/*    opening delimiter for non-nestable comments
*/    closing delimiter for non-nestable comments


1.2 Non-Semantic Symbols

Non-semantic symbols are symbols that do not impact the meaning of a program.
They may occur anywhere in a program before or after semantic symbols but not
within them. There are three types of non-semantic symbols:

* pragmas
* comments
* lexical separators


1.2.1 Pragmas

Pragmas are directives used to control the translation process but do not
change the meaning of the program text. Pragmas consist of a pragma name
optionally followed by other symbols, delimited by "<*" and "*>". Pragma
names never conflict with identifiers or reserved words because they
can only occur within pragma delimiters.

There are two types of pragmas:

* implementation defined pragmas
* language defined pragmas

EBNF:

pragma : "<*" pragmaName otherSymbols? "*>" ;

pragmaName : Ident ;


1.2.1.1 Implementation Defined Pragmas

Any implementation may define its own set of pragmas, specific to the compiler.
Implementation defined pragma names must not be all-uppercase words.


1.2.1.2 Language Defined Pragmas

Language defined pragmas use all-uppercase words as pragma names. The pragma
names of language defined pragmas are reserved.

List of Language Defined Pragma Names

IF               ENDIF            ERROR            FOREIGN          NOINLINE
ELSE             INFO             FATAL            MAKE             VOLATILE
ELSIF            WARN             ALIGN            INLINE


1.2.2 Comments

Comments are symbols ignored by the compiler but intended for a human reader.
There are three types of comments:

* single line comments
* nestable multi-line comments
* non-nestable multi-line comments

EBNF:

Comment : SingleLineComment | NestableComment | NonNestableComment ;
SingleLineComment : "//" ~( EndOfLine )* EndOfLine ;
NestableComment : "(*" ~( "*)" )* NestableComment* "*)" ;
NonNestableComment : "/*" ~( "*/" )* "*/" ;

Examples:

// comment until end-of-line
/* This is a non-nesting comment */
(* This is a comment (* and a comment within *) *)

NB: Non-nestable C-style /* */ comments are strictly intended to allow the use
of source code processing tools that require such comments. For ordinary multi-
line comments, classic Modula-2 style (* *) comments should be used instead.


1.2.3 Lexical Separators

Tab and newline are ignored anywhere in a program. The space character is
ignored anywhere other than within string literals. These symbols always
terminate a numeric literal, an identifier, a reserved word or a pragma name.

EBNF:

LexicalSeparator : " " | TAB | NewLine ;
NewLine : LF CR? | CR LF? ;


1.3 Literals

There are three types of literals:

* numeric literals
* string literals
* structured literals


1.3.1 Numeric literals

There are three types of numeric literals

* character code literals
* whole number literals
* real number literals


1.3.1.1 Character Code Literals

Character code literals are base-16 numbers, indicated by suffix "C".

EBNF:

charCode : Digit Base16Digit+ "C" ;

Examples: 0C, 0AC, 7FC


1.3.1.2 Whole Number Literals

There are three types of whole number literals

* base-10, without suffix
* base-2, with suffix "B"
* base-16, with suffix "H"

EBNF:

DecimalValue : Digit+ ;
BinaryValue : BinaryDigit+ "B" ;
Base16Value : Digit Base16Digit+ "H" ;

Examples: 42, 01101010B, 0BEEFH


1.3.1.3 Real Number Literals

Real number literals are base-10 numbers, always with an integral part,
a decimal point and a fractional part, optionally followed by an exponent.

EBNF:

RealValue : Digit+ "." Digit+ ( "E" ( "+" | "-" )? Digit+ )? ;

Examples: 0.0, 123.45, 3.1415926, 7.523012E+12


1.3.2 String Literals

String literals are sequences of characters left- and right-delimited by
single quotes or double quotes.

EBNF:

String : "'" ( Character | '"' )* "'" |
         '"' ( Character | "'" )* '"' ;

Character : Digit | Letter |
	        " " | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" |
            "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" |
            "@" | "[" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~" |
            EscapeSequence ;

Digit : "0" .. "9" ;
Letter : "A" .. "Z" | "a" .. "z" ;
EscapeSequence : "\" ( "0" | "n" | "r" | "t" | "\" | "'" | '"' ) ;

Examples:

"it's nine o'clock"
'he said "Modula-2" and smiled'
"this is the end of the line\n"


1.3.3 Structured Literals

Structured literals are compound values consisting of multiple terminal
symbols, enclosed in braces.

EBNF:

structuredLiteral : "{" otherSymbols? "}" ;

Examples:

{ 1, 2, 3 }
{ "a", "b", "c" }
{ 42, 3.1415926, "abc" }


1.4 Identifiers

Identifiers are names for syntactic entities in a program. There are two
types of identifiers:

* user-definable identifiers
* language defined identifiers, aka reserved words


1.4.1 User-definable Identifiers

Identifiers are names that start with a letter, lowline or dollar sign,
followed by any number and combination of letters, lowlines, dollar signs
and digits. User definable identifiers must not coincide with reserved words.
The use of the dollar sign in identifiers should be limited to referencing
entities defined by an operating system API for public use (eg. OpenVMS).

EBNF:

Ident : ( "_" | "$" | Letter ) ( "_" | "$" | Letter | Digit )* ;


1.4.2 Reserved Words

Reserved words are identifiers that have special meaning in the language.

List of Reserved Words

ALIAS            DIV              IMPLEMENTATION   OR               TYPE         
AND              DO               IMPORT           POINTER          UNTIL
ARRAY            ELSE             IN               PROCEDURE        VAR
ASSOCIATIVE      ELSIF            LOOP             RECORD           VARIADIC
BEGIN            END              MOD              REPEAT           WHILE
BY               EXIT             MODULE           RETURN
CASE             FOR              NOT              SET
CONST            FROM             OF               THEN
DEFINITION       IF               OPAQUE           TO


1.5 Symbols Reserved for Language Extensions and External Utilities

1.5.1 Symbols Reserved for Use by Language Extensions

Although not part of the language specification, certain symbols are reserved
specifically for use by language extensions. Three such language extensions
are supported:

* Parallel Modula-2
* Objective Modula-2
* single-pass compilers


1.5.1.1 Symbols Reserved for Parallel Modula-2

The following identifiers and pragma names are reserved for exclusive use by
the Parallel Modula-2 language extension:

Reserved words: ALL PARALLEL SYNC
Pragma names  : LOCAL SPREAD CYCLE SBLOCK CBLOCK


1.5.1.2 Symbols Reserved for Objective Modula-2

The following identifiers and pragma names are reserved for exclusive use by
the Objective Modula-2 language extension:

Reserved words: BYCOPY BYREF CLASS CONTINUE CRITICAL INOUT METHOD ON
                OPTIONAL OUT PRIVATE PROCECTED PROTOCOL PUBLIC SUPER TRY
Pragma names  : FRAMEWORK IBACTION IBOUTLET QUALIFIED


1.5.1.3 Symbols Reserved for Single-Pass Compilers

The following pragma name is reserved for use by single-pass compilers:

Pragma name  : FORWARD


1.5.2 Symbols Reserved for Use by External Utilities

To assist external source code processing prior to compilation, the following
symbols are reserved for exclusive use by external source code processors:

?   reserved for use by editors or di-/tri-graph converters
@@  reserved for use by the Modula-2 Template Engine or make utilities
%%  reserved for use by the Modula-2 Template Engine or make utilities


2 Compilation Units

A compilation unit is a sequence of source code that can be independently
compiled. There are four types of compilation units:

* a program module
* a bindings definition
* the interface part of a library module
* the implementation part of a library module

EBNF:

compilationUnit :
    programModule | definitionOfBindings |
    definitionOfModule | implementationOfModule ;


2.1 Program Modules

A Modula-2 program consists of exactly one program module and zero or more
library modules. A program module does not export any identifiers. The body
of a program module roughly corresponds to the main() function in a C program.

EBNF:

programModule :
    MODULE moduleId ( '[' priority ']' )? ';'
    importList* block moduleId '.' ;

moduleId : Ident ;


2.2 Bindings Definition

A bindings definition represents a common set of semantics that data types may
be required to conform to. This is called a semantic type and it determines
how a conformant data type may be declared, what type of literal it may use,
and which bindings to operators and built-in procedures it may define.

EBNF:

definitionOfBindings :
    BINDINGS FOR semanticType ";"
    bindingsHeader bindings*
    END semanticType "." ;

semanticType : Ident ;


2.3 Definition Part of Library Modules

The definition part of a library module represents the public interface of the
library module. Any identifier defined in the definition part is automatically
available for import by other modules.

EBNF:

definitionOfModule :
    DEFINITION MODULE moduleId ( '[' semanticType ']' )? ';'
    importList* definition*
    END moduleId '.' ;


2.4 Implementation Part of Library Modules

The implementation part of a library module represents the implementation of
the library module. Any identifier defined in the corresponding definition
part is automatically available in the implementation part. Any identifier
defined in the implementation part is not available outside of the
implementation part.

EBNF:

implementationOfModule :
    IMPLEMENTATION programModule ;


2.5 Module Initialisation

The body of the implementation part of a library module is the library's
initialisation procedure. It is automatically executed by the Modula-2
runtime environment when a Modula-2 program is run.

The order in which modules are initialised is language defined and depends
on the module dependency graph. During compilation a module dependency graph
is built and the initialisation order is determined by depth-first traversal
order of the dependency graph whereby initialisation takes place for each
node from bottom to top on the way back up.


2.6 Module Termination

Module termination is not a language feature but it is a facility provided
by a library module in the standard library. The termination library provides
an API for client modules that require termination to install their own
termination handlers onto the library's termination handler stack.

The termination library installs its own wind down procedure in the runtime
environment during module initialisation. The wind down procedure then calls
the installed termination handlers in reverse order when the program is about
to be terminated.


3 Import of Identifiers

Identifiers defined in the interface of a library module may be imported by
other modules using an import directive. There are two types of import:

* qualified import
* unqualified import

EBNF:

importList :
    ( FROM moduleId IMPORT ( identList | '*' ) |
    IMPORT Ident '+'? ( ',' Ident '+'? )* ) ';'


3.1 Qualified Import

When an identifier is imported by qualified import, it must be qualified with
the exporting module's module name when it is referenced in the importing
module. This avoids name conflicts when importing identically named
identifiers from different modules.

Example:

IMPORT FileIO; (* qualified import of module FileIO *)
VAR status : FileIO.Status; (* qualified identifier of Status *)


3.1.1 Import Aggregators

A module imported by qualified import may be automatically re-exported to any
importing client module. Modules to be re-exported in this way are marked with
a plus sign after their identifiers.

A module that imports other modules for the sole purpose of re-export is
called an import aggregator. This facility is useful to allow clients to
import an entire library with a single import statement.

Example:

DEFINITION MODULE FooBarBaz;
IMPORT Foo+, Bar+, Baz+; (* import Foo, Bar and Baz into client module *)
END FooBarBaz.

IMPORT FooBarBaz; (* imports all modules imported by FooBarBaz and marked + *)


3.1.2 Import of Abstract Data Type Library Modules

If the interface of a module defines a type that has the same name as the
module, the type is referenced unqualified. This facility is useful in the
construction of abstract data types as library modules.

Example:

DEFINITION MODULE Colour;
TYPE Colour = ( red, green, blue );
(* public interface *)
END Colour.

IMPORT Colour;
VAR colour : Colour;


3.2 Unqualified Import

When an identifier is imported by unqualified import, it is made available in
the importing module as is. This will lead to a name conflict and cause a
compile time error when importing identically named identifiers from different
modules.

Example:

FROM FileIO IMPORT Status; (* unqualified import of Status *)
VAR status : Status; (* unqualified identifier of Status *)


3.2.1 Wildcard Import

An unqualified import directive may import all available identifiers of a
library module by using an asterisk as a wildcard.

Example:

FROM FileIO IMPORT *; (* import all identifiers *)


4 Data Types

Modula-2 is a strongly typed language. Constants and variables are always
associated with a data type. A data type is an abstract property of a constant
or variable that determines the storage size and structure, the compatibility
with other constants or variables and the operations that are permitted.

There are twelve language predefined (pervasive) data types:

BOOLEAN, BITSET, LONGBITSET, CHAR, UNICHAR, OCTET, CARDINAL, LONGCARD,
INTEGER, LONGINT, REAL and LONGREAL.

Other types may be defined using built-in type constructor syntax:

Enumeration types, set types, array types, record types, pointer types,
procedure types and abstract data types using the opaque type constructor.

Character strings are represented by character arrays.


4.1 Semantics of Types

Every data type has an associated set of language defined semantics. These
semantics define the interpretation of values, the compatibility of literals
and a set of operations. Many data types share a common set of semantics with
other data types. A common set of shared semantics is called a semantic type.
Every data type is thus defined in terms of its semantic type.


4.1.1 The Semantics of Ordinal Types

Ordinal types are data types with non-numeric ordered values, including a
start value that is interpreted as the type's zero-th value. The ordinal
value of any n-th value is n for all n. The following operations are
defined for ordinal types:

* assignment of literals and expressions (:=)
* type conversion (::)
* smallest value (TMIN)
* largest value (TMAX)
* ordinal value (ORD)
* predecessor value (PRED)
* successor value (SUCC)
* number of values (COUNT)
* iteration (FOR .. IN ..)
* equal (=)
* not-equal (#)
* less (<)
* less-or-equal (<=)
* greater (>)
* greater-or-equal (>=)

Pervasive data types BOOLEAN, CHAR and UNICHAR, and all enumeration types are
ordinal types. Literals for type BOOLEAN are TRUE and FALSE, literals for
types CHAR and UNICHAR are character code literals and string literals of
length one.


4.1.2 The Semantics of the Boolean Type

The boolean type is an ordinal type with two values, interpreted as boolean
truth values, represented by the literal constants TRUE and FALSE. Further
to the operations defined for ordinal types, three additional operations
are defined for the boolean type:

* logical-not (NOT, ~)
* logical-and (AND, &)
* logical-or (OR)

Pervasive data type BOOLEAN is the one and only boolean type. No facility
exists to define other data types as boolean types.


4.1.3 The Semantics of Set Types

Set types are data types that represent mathematical sets with a finite number
of elements. The following operations are defined for set types:

* assignment of structured literals and expressions (:=)
* type conversion (::)
* number of elements (COUNT)
* membership test (IN)
* include element (set[element] := TRUE)
* exclude element (set[element] := FALSE)
* iteration (FOR .. IN)
* set union (+)
* set difference (-)
* set intersection (*)
* symmetric set difference (/)
* equal (=)
* not-equal (#)
* true subset (<)
* true superset (>)
* subset (<=)
* superset (>=)

Pervasive data types BITSET and LONGBITSET, and all types defined using the
"SET OF" type constructor are set types.


4.1.4 The Semantics of Whole Number Types

Whole number types are data types that represent subranges of the mathematical
set of integers (Z), always with a finite number of values. The following
operations are defined for whole number types:

* assignment of whole number literals and expressions (:=)
* type conversions (::)
* smallest value (TMIN)
* largest value (TMAX)
* absolute value (ABS)
* sign reversal (NEG)
* odd/even test (ODD)
* addition (+)
* postfix increment (++)
* difference (-)
* postfix decrement (--)
* multiplication (*)
* integer division (DIV)
* modulo (MOD)
* iteration (FOR .. IN ..)
* equal (=)
* not-equal (#)
* less-than (<)
* less-or-equal (<=)
* greater-than (>)
* greater-or-equal (>=)

Pervasive data types OCTET, CARDINAL, LONGCARD, INTEGER and LONGINT are whole
number types.


4.1.5 The Semantics of Real Number Types

Real number types are data types that represent subranges of the mathematical
set of real numbers (R), always with a finite number of values. The following
operations are defined for real number types:

* assignment of real number literals and expressions (:=)
* type conversions (::)
* smallest value (TMIN)
* largest value (TMAX)
* absolute value (ABS)
* sign reversal (NEG)
* addition (+)
* postfix increment (++)
* difference (-)
* postfix decrement (--)
* multiplication (*)
* division (/)
* equal (=)
* not-equal (#)
* less-than (<)
* less-or-equal (<=)
* greater-than (>)
* greater-or-equal (>=)

Pervasive data types REAL and LONGREAL are real number types.


4.1.6 The Semantics of Array Types

Array types are compound data types whose components are all of the same type.
The following operations are defined for array types:

* assignment of structured literals and expressions (:=)
* store component (array[index] := value)
* retrieve component (value := array[index])
* obtain highest index (HIGH)
* component iteration (FOR .. IN ..)
* equal (=)
* not-equal (#)

All data types defined using the ARRAY OF type constructor are array types.


4.1.7 The Semantics of Character String Types

Character string types are arrays whose components are character types. The
semantic character string type represents the superset of all character string
types. The following operations are defined for character string types:

* assignment of string literals, structured literals and expressions (:=)
* store component (array[index] := value)
* retrieve component (value := array[index])
* obtain highest index (HIGH)
* obtain string length (LENGTH)
* component iteration (FOR .. IN ..)
* concatentation (+)
* equal (=)
* not-equal (#)

All character string data types defined using the ARRAY OF CHAR and ARRAY OF
UNICHAR type constructor are of the semantic character string type.


4.1.8 The Semantics of Collection Types

Collection types are data types that represent containers for an arbitrary
number of key-value pairs. The following operations are defined for
collection types:

* allocation (NEW)
* deallocation (DISPOSE)
* assignment of objects of the same type (:=)
* store value by key (collection[key] := value)
* retrieve value for key (value := collection[key])
* remove value for key (collection[key] := NIL)
* number of key/value pairs (COUNT)
* key is present test (IN)
* iteration by key (FOR .. IN ..)
* equal (=)
* not-equal (#)

All data types defined using the ASSOCIATIVE ARRAY OF type constructor are
collection types.


4.1.9 The Semantics of Record Types

Record types are compound data types whose components are of arbitrary types.
The semantic record type represents the superset of all record data types.
The following operations are defined for record types:

* assignment of structured literals and expressions (:=)
* store component (record.component := value)
* retrieve component (value := record.component)
* equal (=)
* not-equal (#)

All data types defined using the RECORD type constructor are record types.


4.1.10 The Semantics of Pointer Types

Pointer types are data types that represent references to a storage location. 
The semantic pointer type represents the superset of all pointer data types.
The following operations are defined for pointer types:

* assignment of NIL and expressions (:=)
* allocation (NEW)
* deallocation (DISPOSE)
* dereference (^)
* equal (=)
* not-equal (#)

All data types defined using the POINTER TO type constructor are pointer types.


4.1.11 The Semantics of Procedure Types

Procedure types are special pointer types that reference the storage location
of a procedure and store the formal parameters of a procedure prototype. The
following operations are defined for procedure types:

* assignment of NIL and expressions (:=)
* procedure call
* dereference (^)
* equal (=)
* not-equal (#)

All procedure types defined using the PROCEDURE type constructor are procedure
types and all procedures and functions are values of a procedure type.


4.1.12 The Semantics of Opaque Types

Opaque types are data types whose structure and semantics are only available
in the implementation part of the library module that defines the opaque type.
Outside of the implementation part the following operations are defined:

for opaque pointers:

* allocation (NEW)
* deallocation (DISPOSE)
* assignment (:=) of NIL and objects of the same type only
* equal (=)
* not-equal (#)

for opaque records:

* assignment (:=) of objects of the same type only
* equal (=)
* not-equal (#)

All data types defined using a sole OPAQUE type constructor are opaque pointer
types. All data types defined using a the OPAQUE RECORD type constructor are
opaque record types.


4.2 Library Defined Semantic Types

The standard library provides a set of semantic type definitions in order to
allow the construction of library defined abstract data types that are practi-
cally inistinguishable from pervasive types and transparent data types defined
using type constructor syntax.

To require an ADT to conform to a library defined semantic type, the library
that defines the ADT must specify the semantic type in the module header of
its defintion part.


4.2.1 Library Defined Whole Number Type Semantics

The standard library provides the ZTYPE as a library defined semantic type for
library defined whole number types. For semantic compatibility, its definition
matches the semantics of the built-in semantic type for whole number types.


4.2.2 Library Defined Real Number Type Semantics

The standard library provides the RTYPE as a library defined semantic type for
library defined real number types. For semantic compatibility, its definition
matches the semantics of the built-in semantic type for real number types.


4.2.3 Library Defined Complex Number Type Semantics

The standard library provides the CTYPE as a library defined semantic type for
library defined complex number types. Its definition matches the mathematic
definition of complex numbers. CTYPE has no built-in equivalent.


4.2.4 Library Defined Numeric Vector Type Semantics

The standard library provides the VTYPE as a library defined semantic type for
library defined numeric vector types. Its definition matches the mathematic
definition of numeric vectors. VTYPE has no built-in equivalent.


4.2.5 Library Defined Date-Time Type Semantics

The standard library provides the DateType as a library defined semantic type
for library defined date-time types. DateType has no built-in equivalent.


4.2.6 Library Defined Set Type Semantics

The standard library provides the SetType as a library defined semantic type
for library defined static set types. For semantic compatibility, its defini-
tion matches the semantics of the built-in semantic type for set types.


4.2.7 Library Defined Array Type Semantics

The standard library provides the ArrayType as a library defined semantic type
for library defined dynamic array types. For semantic compatibility, its de-
finition matches the semantics of the built-in semantic type for array types.


4.2.8 Library Defined Collection Type Semantics

The standard library provides the CollectionType as a library defined semantic
type for library defined dynamic collection types. For semantic compatibility,
its definition matches the semantics of the built-in semantic type for col-
lection types.


4.2.9 Library Defined Character String Type Semantics

The standard library provides the StringType as a library defined semantic
type for library defined dynamic character string types. For semantic compati-
bility, its definition matches the semantics of the built-in semantic type for
character string types.


4.2.10 CAUTION - Do Not Modify Semantic Type Definitions

For semantic compatibility, the library provided semantic type definitions
exactly match the semantics of their corresponding built-in counterparts.
Modification of the semantic type definitions will cause library defined
types to behave differently from their built-in counterparts. For this
reason, library defined definitions of semantic types should not be changed.


4.2.11 User Defined Semantic Types

User libraries may provide their own semantic type definitions for their own
custom designed abstract data types.


4.2 Abstract Data Types

Opaque pointer types and opaque record types are predominantly used to define
abstract data types (ADTs). An ADT is a data type whose internal structure
and semantics are hidden from the user of the type and are superimposed by
a new set of semantics defined by the library module that defines the ADT.

A library module that defines an abstract data type with the same name as its
own module identifier is called an ADT library module.

An ADT library module may specify a semantic type in its module header. This
represents a promise to conform to the common set of semantics defined by the
semantic type. An ADT defined to conform to a semantic type may bind its own
library defined procedures to those operators and pervasive procedures that
are permitted by the semantic type. Static conformance is compiler enforced.
No other bindings than those defined by the semantic type are permitted.

Defining an ADT with a semantic type specified and providing appropriate
bindings in the public interface of the ADT will cause the compiler to check
static conformance of the public interface with the specified semantic type's
definition. If conformant, this will have the following effects:

* Literals defined to be compatible with the ADT may be assigned to variables
  of the ADT or passed in as arguments for formal parameters of the ADT.
* ADT values may be used in infix expressions using the ADT's bound operators.
* Bound pervasive procedures may be called with ADT values passed as arguments.
* The compiler will replace any infix expressions with calls to the corres-
  ponding procedures defined in the ADT library module.
* The compiler will replace any calls to bound pervasive procedures with calls
  to the corresponding procedures defined in the ADT library module.


4.3 Library Defined ADTs Using Semantic Types and Bindings

The standard library provides a rich set of library defined ADTs that use
semantic types and bindins and are practically inistinguishable from pervasive
types and transparent data types defined using type constructor syntax.


4.3.1 Library Defined Bitset ADTs

The standard library provides bitset ADTs whose semantics match those of the
pervasive bitset types BITSET and LONGBITSET. The library defined bitset ADTs
are BS16, BS32, BS64, BS128 and their respective number of bits is indicated
in the identifier. However, client modules should not use these types using
these identifiers directly.

The alias type identifiers BITSET16, BITSET32, BITSET64 and BITSET128 should
be used instead. The aliases of whichever bitset types match the number of
bits of the pervasive types BITSET and LONGBITSET are automatically defined
as aliases of the pervasive types.

Two additional alias types are defined as SHORTBITSET and LONGLONGBITSET.


4.3.2 Library Defined Unsigned Integer ADTs

The standard library provides unsigned integer ADTs whose semantics match
those of the pervasive types CARDINAL and LONGCARD. The library defined
unsigned integer ADTs are CARD16, CARD32, CARD64, CARD128 and their respective
bitwidth is indicated in the identifier. However, client modules should not
use these types using these identifiers directly.

The alias type identifiers CARDINAL16, CARDINAL32, CARDINAL64 and CARDINAL128
should be used instead. The aliases of whichever types match the size of the
pervasive types CARDINAL and LONGCARD are automatically defined as aliases of
the pervasive types.

Two additional alias types are defined as SHORTCARD and LONGLONGCARD.


4.3.3 Library Defined Signed Integer ADTs

The standard library provides signed integer ADTs whose semantics match
those of the pervasive types INTEGER and LONGINT. The library defined signed
integer ADTs are INT16, INT32, INT64, INT128 and their respective bitwidth is
indicated in the identifier. However, client modules should not use these
types using these identifiers directly.

The alias type identifiers INTEGER16, INTEGER32, INTEGER64 and INTEGER128
should be used instead. The aliases of whichever types match the size of the
pervasive types INTEGER and LONGINT are automatically defined as aliases of
the pervasive types.

Two additional alias types are defined as SHORTINT and LONGLONGINT.


4.3.4 Library Defined BCD Real Number ADTs

The standard library provides binary coded Decimals (BCD) real number ADTs
whose semantics match those of the pervasive types REAL and LONGREAL. The
library defined BCD ADTs are BCD and LONGBCD.


4.3.5 Library Defined Complex Number ADTs

The standard library provides complex number ADTs whose semantics conform to
semantic type CTYPE. The library defined complex number ADTs are COMPLEX and
LONGCOMPLEX.


4.3.6 Library Defined Character Set ADTs

The standard library provides a character set ADT whos semantics conform to
semantic type SetType. The library defined character set ADT is CHARSET.


4.3.7 Library Defined Character String ADTs

The standard library provides dynamic string ADTs whose semantics conform to
semantic type StringType. The library defined dynamic string ADTs are STRING
and UNISTRING.


4.3.8 Library Defined DateTime ADTs

The standard library provides two date-time ADTs that conform to semantic
type DateType. The library defined ADTs are DateTime and Time.



5 Definitions and Declarations

A definition is a directive that defines an identifier in the public interface
of a library module. A declaration is a directive that declares an identifier
in a program module or in the implementation part of a library module.
There are four types of definitions and declarations:

* constant definitions and declarations
* variable definitions and declarations
* type definitions and declarations
* procedure definitions and declarations


5.1 Constant Definitions and Declarations

A constant is an immutable value determined at compile time. A constant may be
defined or declared as an alias of another constant, but it may not be defined
or declared as an alias of a module, a variable, a type or a procedure.

EBNF:

constDefinition :
    CONST ( ( "[" Ident "]" )? Ident "=" constExpression ";" )* ;

constDeclaration :
    CONST ( Ident "=" constExpression ";" )* ;

Examples:

CONST zero = 0;
CONST maxInt = TMAX(INTEGER);


5.2 Variable Definitions and Declarations

A variable is a variant whose value is determined at runtime and may change at
runtime. A variable always has a type which is determined at compile time.

EBNF:

varDefinition :
    VAR ( Ident ( "[" address "]" | "," identList )?
          : ( namedType | anonymousType ) ";" )* ;
varDeclaration : varDefinition ;

Examples:

VAR x, y : REAL;
VAR portA [mappedIOAddr] : OCTET;


5.2.1 Global Variables

A variable defined or declared in the top level of a module has a global life
span. It exists throughout the entire runtime of the program. However, a
global variable does not have global scope. It is only visible within the
module it is defined or declared in and within modules that import it.

A variable that is defined in the top level of a library module is always
exported immutable. It may be modified within the library module's
implementation part but it cannot be modified within modules that import it.


5.2.2 Local Variables

A variable declared within a procedure has local life span and local scope. It
only exists at the time the procedure is executing and it is only visible
within the procedure it is declared in and within procedures local to the
procedure it is declared in.


5.3 Type Definitions and Declarations

EBNF:

typeDefinition :
    TYPE ( Ident = ( type | opaqueType ) ";" )* ;

typeDeclaration :
    TYPE ( Ident = type ";" )* ;

type :
	( ALIAS OF )? namedType |
    anonymousType | enumerationType | recordType | setType ;

namedType : qualident ;
    
Examples:

TYPE Volume = INTEGER;
TYPE HashTable = OPAQUE;


5.5.1 Strict Name Equivalence

Modula-2 R10 uses strict name equivalence. By default types of different names
are always incompatible even if they are derived from the same base type.

Example:

TYPE Celsius = REAL; Fahrenheit = REAL;
VAR celsius : Celsius; fahrenheit : Fahrenheit;

celsius := fahrenheit; (* compile time error: incompatible types *)

In order to assign values across type boundaries, type conversion is required.

Example:

celsius := (fahrenheit - 32.0) * 100.0/180.0 :: Celsius; (* type conversion *)


5.5.2 Alias Types

If a type is desired to be compatible with another type it must be defined or
declared as an alias type.

Example:

TYPE INT = ALIAS OF INTEGER;
VAR i : INT; j : INTEGER;

i := j; (* i and j are compatible *)


5.5.3 Opaque Types

A type may be defined as an opaque type. The identifier of an opaque type is
available in the library where it is defined and in modules that import it.
However, the implementation details of an opaque type are only available
within the implementation part of the library where it is defined. This
facility is useful for the construction of abstract data types.

There are two types of opaque types:

* opaque pointer types
* opaque record types


5.5.3.1 Opaque Pointers

An opaque pointer type is a pointer to a type whose declaration is hidden in
the corresponding implementation part. Objects of the abstract data type can
only be allocated dynamically at runtime.

EBNF:

opaquePointerDefinition : TYPE Ident "=" OPAQUE ";" ;

Example:

DEFINITION MODULE Tree;
TYPE Tree = OPAQUE; (* opaque pointer *)
(* public interface *)
END Tree.

IMPLEMENTATION MODULE Tree;
TYPE Tree = POINTER TO TreeDescriptor;
TYPE TreeDescriptor = RECORD left, right : Tree; value : ValueType END;
(* implementation *)
END Tree.

IMPORT Tree;
VAR tree : Tree;
NEW(tree); (* dynamic allocation of a variable of abstract data type Tree *)


5.5.3.2 Opaque Records

An opaque record type is an opaque type that represents a record type instead
of a pointer to a record type. Objects of the abstract data type can be
allocated either statically as global or local variables or dynamically.

In order for the compiler to be able to allocate a variable of an opaque
record type statically, it must be able to determine its allocation size.
However, the allocation size of a record can only be determined from the
record type's declaration. For this reason, the declaration of an opaque
record type is lexically located in the definition part where it is defined
but it is semantically treated as if it was hidden in the corresponding
implementation part. Only the identifier of an opaque record is visible to
modules that import it. Its internal structure is not available to them.

EBNF:

opaqueRecordDefinition : TYPE Ident "=" OPAQUE recordType ";" ;

Example:

DEFINITION MODULE BigInteger;
TYPE BigInteger = OPAQUE RECORD highDigits, lowDigits : INTEGER END;
(* public interface *)
END BigInteger.

IMPORT BigInteger;
VAR bigInt : BigInteger; i : INTEGER;
i := bigInt.highDigits; (* compile time error: hidden component *)


5.5.4 Anonymous Types

An anonymous type is a type that does not have a type identifier associated
with it. However, in languages with name equivalence, the names of the types
of variables must be examined to determine whether or not they are assignment
or expression compatible. If the types do not have names, then compatibility
cannot be determined. For this reason, anonymous types are of very limited use
in languages with name equivalence.

Modula-2 follows name equivalence for all types other than procedure types and
formal array and pointer parameters. A procedure is compatible with a procedure
type if their respective signatures match. An array is compatible with a formal
array parameter if their respective component types match. A pointer is
compatible with a formal pointer parameter if the respective types they
point to match. These types are thus permitted as anonymous types.

EBNF:

anonymousType : arrayType | pointerType | procedureType ;


5.5.5 Enumeration Types

An enumeration type is an ordinal type whose legal values are defined by a list
of identifiers. The identifiers are assigned ordinal values from left to right.
The ordinal value assigned to the first value is always zero.

EBNF:

enumerationType :
    "(" ( ( "+" namedType ) | ident )
        ( "," ( ( "+" namedType ) | ident ) )* ")" ;

Example:

TYPE Colours = ( red, green, blue );

The list of identifiers that define the legal values of an enumeration type
may contain references to other enumeration types. When another enumeration
type is referenced within an enumerated list all the identifiers listed in
the referenced type become legal values of the new type.

Example:

TYPE MoreColours = ( +Colour, orange, magenta, cyan );
(* equivalent to: ( red, green, blue, orange, magenta, cyan ) *)

When referencing an enumerated value, its identifier must always be qualified
with the name of its type. This requirement fixes a flaw in classic Modula-2
where importing enumeration types could cause name conflicts.

Example:

VAR colour : Colours;
colour := Colours.green; (* qualified identifier of value green *)


5.3.6 Array Types

5.3.6.1 Indexed Array Types

EBNF:

indexedArray :
    ARRAY arrayIndex ( "," arrayIndex )*
    OF ( namedType | pointerType | procedureType ) ;

arrayIndex : ordinalConstExpression ;


5.3.6.2 Associative Array Types

EBNF:

associativeArray :
    ASSOCIATIVE ARRAY OF ( namedType | pointerType | procedureType ) ;


5.5.7 Record Types

EBNF:

recordType :
    RECORD ( '(' ( semanticType | baseType ) ')' )? fieldListSequence? END ;

fieldListSequence :
    fieldList ( ";" fieldList )* ;

fieldList :
    identList ":" ( namedType | arrayType | pointerType | procedureType ) ;

baseType : Ident ;


5.5.8 Set Types

EBNF:

setType :
    SET OF ( namedEnumType | "(" identList ")" ) ;

namedEnumType : namedType ;


5.3.9 Pointer Types

EBNF:

pointerType : POINTER TO CONST? namedType ;


5.5.10 Procedure Types

EBNF:

procedureType :
    PROCEDURE ( "(" formalTypeList ")" )? ( ":" returnedType )? ;

formalTypeList :
    attributedFormalType ( "," attributedFormalType )* ;

attributedFormalType :
    ( CONST | VAR )? formalType ;

formalType :
    ( ARRAY OF )? namedType ;

returnedType : namedType ;


5.6 Procedure Definitions and Declarations


6 Statements

*** to do ***


7 Expressions

*** to do ***


8 Structured Values

Structured values are compound values that consist of comma separated component
values, enclosed in braces. Component values may be any literal or identifier
denoting a value or structured value.

EBNF:

structuredValue :
	"{" ( valueComponent ( "," valueComponent )* )? "}" ;
valueComponent :
	expression ( ( BY | ".." ) constExpression )? ;

Static semantics: An expression in a structured value that is followed by the
range operator .. must be a constant expression.

Examples:

{ x BY 100 }, { 1 .. 10 }
{ "abc", 123, 456.78, { 1, 2, 3 } }
{ 1970, Month.Jan, 1, 0, 0, 0.0, TZ.UTC }


9 Pragmas

Pragmas are directives used to control or influence the translation process
but they do not change the meaning of the program text.

There are two types of pragmas:

* implementation defined pragmas
* language defined pragmas


9.1 Implementation Defined Pragmas

Implementation defined pragmas are compiler specific and non-portable. They
are easily recognisable because their pragma names are either all-lowercase
or mixed-case but never all-uppercase words.

EBNF:

implementationDefinedPragma :
    "<*" pragmaName ( "+" | "-" | "=" ( Ident | Number ) )? "*>" ;

pragmaName : Ident ;


9.2 Language Defined Pragmas

Language defined pragmas are portable across implementations. They are easily
recognisable because their pragma names are all-uppercase words. There are
three groups of language defined pragmas:

* pragmas to control conditional compilation
* pragmas to emit console messages during compilation
* pragmas to control, influence or optimise code-generation


9.2.1 Conditional Compilation Pragmas

Conditional compilation pragmas are used to compile portions of the source
text only if a certain condition is met. The condition must be a compile
time expression.

EBNF:

conditionalCompilationPragma :
    "<*" ( IF | ELSIF ) constExpression | ELSE | ENDIF "*>" ;

Example:

TYPE Model = ( small, large, custom );

<* IF TSIZE(INTEGER) = 2 *>
CONST model = Model.small;
<* ELSIF TSIZE(INTEGER) = 4 *>
CONST model = Model.large;
<* ELSIF TSIZE(INTEGER) MOD 2 = 0 *>
CONST model = Model.custom;
<* ELSE *>
<* FATAL "unsupported type model." *>
<* ENDIF *>


9.2.2 Compile Time Console Message Pragmas

Compile time console message pragmas are used to emit console messages during
compilation. There are four types of message pragmas:

* pragmas emitting informational messages
* pragmas emitting compilation warnings
* pragmas emitting compilation errors
* pragmas emitting fatal compilation errors

Informational messages and warnings do not cause the compilation to fail.
Error messages cause the compilation to fail but continue. Fatal messages
cause the compilation to fail and abort immediately.

EBNF:

compileTimeMessagePragma :
    "<*" ( INFO | WARN | ERROR | FATAL ) quotedStringLiteral "*>" ;

Example:

<* FATAL "unsupported target architecture." *>


9.2.3 Code Generation Pragmas

Code generation pragmas are used to control or influence code generation and
optimisation. There are six code generation pragmas:

* pragma to force specified memory alignment
* pragma to force specified calling convention
* pragma to cause the build system to invoke an external utility
* pragma to suggest inlining a procedure
* pragma to suggest not inlining a procedure
* pragma to mark a variable as volatile

EBNF:

codeGenerationPragma :
    "<*" ( ALIGN "=" constExpression |
           FOREIGN ( "=" quotedStringLiteral )? |
           MAKE "=" quotedStringLiteral |
           INLINE | NOINLINE | VOLATILE ) "*>" ;

Examples:

TYPE Point = RECORD <* ALIGN = 8*TSIZE(CARDINAL) *> x, y : OCTET END;
<* FOREIGN = "C" *> DEFINITION MODULE stdio;
<* MAKE = "genhashes foo bar baz > Hashes.def" *>
<* INLINE *> PROCEDURE P;
<* NOINLINE *> PROCEDURE Q;
VAR <* VOLATILE *> signal : Signal;

NB: At present, the only parameter defined for pragma FOREIGN is "C".


10 Pervasive Identifiers

Pervasive Identifiers are predefined identifiers that are available in every
scope of a program without having to import them. Unlike reserved words,
pervasive identifiers may be redefined by libraries or program modules.

There are five groups of pervasive identifiers:

* predefined constants
* predefined types
* predefined procedures
* predefined functions
* built-in lexical macros


10.1 Predefined Constants

There are three predefined constants:

NIL    invalid pointer value, shorthand for 0 :: POINTER TO CONST OCTET
TRUE   shorthand for BOOLEAN.TRUE
FALSE  shorthand for BOOLEAN.FALSE


10.2 Predefined Types

There are twelve predefined types:

BOOLEAN     boolean type, TYPE BOOLEAN = ( TRUE, FALSE );
BITSET      bitset type of same size as CARDINAL
LONGBITSET  bitset type of same size as LONGCARD
CHAR        7-bit character type, first 128 code points of UTF-8
UNICHAR     4-octet character type, all code points of UTF-32
OCTET       unsigned 8-bit integer type
CARDINAL    unsigned integer type, 2*n octets for n >= 1
LONGCARD    unsigned integer type, 2*n octets for n >= 1
INTEGER     signed integer type of same size as CARDINAL
LONGINT     signed integer type of same size as LONGCARD
REAL        real number type
LONGREAL    double precision real number type

Although these types are predefined, their IO operations are not. The IO
operations corresponding to READ, WRITE and WRITEF for pervasive types are
provided in the standard library and need to be imported to become available.


10.3 Predefined Procedures

All predefined procedures are Wirthian macros. They act and look like library
defined procedures but they may not be assigned to procedure variables, may
not be passed to a procedure as parameters and calls to them are replaced by
the compiler with a call to a corresponding library procedure.

There are five predefined procedures:

NEW DISPOSE READ WRITE WRITEF


10.3.1 Procedure NEW

Procedure NEW is used to dynamically allocate storage for a variable of a
pointer type. Its pseudo-definition is:

PROCEDURE NEW ( VAR p : <anyPointerType>; (*OPTIONAL*) n : <unsignedType> );

A call to procedure NEW is replaced by the compiler with a call to library
procedure ALLOCATE which must be imported before NEW can be used. The standard
library provides an ALLOCATE procedure in module Storage.

Library procedure ALLOCATE always requires a second parameter to specify the
allocation size of the type that the pointer variable points to. The compiler
automatically determines the allocation size for the pointer variable passed
to NEW and passes the appropriate size value as a second parameter to library
procedure ALLOCATE when it replaces the procedure call.

Example:

TYPE FooPtr = POINTER TO Foo;
VAR fooptr : FooPtr;

NEW(fooptr); (* replaced by ALLOCATE(fooptr, TSIZE(Foo)); *)

When NEW is used to allocate storage for a variable of indeterminate type
a second parameter is required to pass the determinant value for the type.

Example:

TYPE VLA = RECORD items : CARDINAL; array : ARRAY items OF INTEGER END;
TYPE VLAPtr = POINTER TO VLA;
VAR v : VLAPtr;

NEW(v, 100); (* replaced by ALLOCATE(v, TSIZE(VLA) + 100*TSIZE(INTEGER)); *)


10.3.2 Procedure DISPOSE

Procedure DISPOSE is used to deallocate storage that was earlier allocated by
a call to procedure NEW. Its pseudo-defintion is:

PROCEDURE DISPOSE ( VAR p : <anyPointerType> );

A call to procedure DISPOSE is replaced by the compiler with a call to a
library procedure DEALLOCATE which must be imported before DISPOSE can be
used. The standard library provides a DEALLOCATE procedure in module Storage.
Procedure DISPOSE always requires a single parameter only.

Examples:

DISPOSE(fooptr); (* replaced by DEALLOCATE(fooptr, TSIZE(Foo)); *)

DISPOSE(v); (* replaced by
               DEALLOCATE(v, TSIZE(VLA) + v^.items*TSIZE(INTEGER)); *)


10.3.3 Procedure READ

Procedure READ is used to read a value from a file or stream and assign it to
a variable. Its pseudo-definition is:

PROCEDURE READ ( f : File; VAR v : <anyType> );

A call to procedure READ is replaced by the compiler with a call to a library
procedure Read which must be defined in a library module that has the same
name as the type of the variable for which a value is being read.

The standard library provides a Read procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call READ on library defined types, the library module
that defines the type must have the same name as the type and it must provide
its own Read procedure.

Examples:

IMPORT PervasiveIO;
VAR n : CARDINAL;
READ(stdIn, n); (* replaced by CARDINAL.Read(stdIn, n); *)

IMPORT BCD;
VAR balance : BCD;
READ(stdIn, balance); (* replaced by BCD.Read(stdIn, balance); *)


10.3.4 Procedure WRITE

Procedure WRITE is used to write a value to a file or stream. Its pseudo-
definition is:

PROCEDURE WRITE ( f : File; v : <anyType> );

A call to procedure WRITE is replaced by the compiler with a call to a library
procedure Write which must be defined in a library module that has the same
name as the type of the value being written.

The standard library provides a Write procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call WRITE on library defined types, the library module
that defines the type must have the same name as the type and it must provide
its own Write procedure.

Examples:

IMPORT PervasiveIO;
VAR n : CARDINAL;
WRITE(stdOut, n); (* replaced by CARDINAL.Write(stdOut, n); *)

IMPORT BCD;
VAR balance : BCD;
WRITE(stdOut, balance); (* replaced by BCD.Write(stdOut, balance); *)


10.3.5 Procedure WRITEF

Procedure WRITEF is used to write one or more values to a file or stream using
a given format depending on a format string. Its pseudo-definition is:

PROCEDURE WRITEF ( f : File; fmt : ARRAY OF CHAR; v : VARIADIC OF <anyType> );

A call to procedure WRITEF is replaced by the compiler with a call to a
library procedure WriteF which must be defined in a library module that has
the same name as the type of the value being written.

The standard library provides a WriteF procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call WRITEF on library defined types, the library
module that defines the type must have the same name as the type and it must
provide its own WriteF procedure.

Procedure WRITEF is variadic. It accepts one or more values to be written.
However, all values must be of the same type. The format string strictly
determines the appearance of values only. This is in contrast to the printf
function of C where the format string also determines the types of values.
In Modula-2 R10 all values must be of the same value to ensure type safety.

Examples:

IMPORT PervasiveIO;
VAR n1, n2, n3 : CARDINAL;
WRITEF(stdOut, "", n1, n2, n3); (* replaced by
                                   CARDINAL.WriteF(stdOut, "", n1, n2, n3); *)

IMPORT BCD;
VAR balance : BCD;
WRITEF(stdOut, "", balance); (* replaced by BCD.WriteF(stdOut, "", balance); *)


10.4 Predefined Functions

Predefined functions act and look like library defined functions but they may
not be assigned to procedure variables, may not be passed to a procedure as
parameters and calls to them are typically replaced by the compiler with
an expression rather than a call to a corresponding function.

There are 16 predefined functions:

ABS NEG ODD PRED SUCC ORD CHR COUNT SIZE HIGH LENGTH NEXTV TMIN TMAX TSIZE VAL


10.4.1 Function ABS

Function ABS returns the absolute value of its operand. Its operand may be of
any Z-Type, R-Type, C-Type or V-Type. Its return type is always the same as
the operand type. Its pseudo-definiton is:

PROCEDURE ABS ( x : <numericType> ) : <operandType> ;


10.4.2 Function NEG

Function NEG returns the sign reversed value of its operand. Its operand may
be of any Z-Type, R-Type, C-Type or V-Type. Its return type is always the same
as the operand type. Its pseudo-definiton is:

PROCEDURE NEG ( x : <numericType> ) : <operandType> ;


10.4.3 Function ODD

Function ODD returns TRUE if its operand operand is an odd number or FALSE if
it is not. Its operand may be of any Z-Type. Its return type is the boolean
type. Its pseudo-definiton is:

PROCEDURE ODD ( x : <Z-Type> ) : BOOLEAN ;


10.4.4 Function PRED

Function PRED returns the n-th predecessor of its first operand where n is the
second operand. Its first operand may be of any ordinal type and its second
operand may be of any unsigned type. Its return type is always the same as
type of its first operand. Its pseudo-definition is:

PROCEDURE PRED ( x : <ordinalType>; n : <unsignedType> ) : <typeOf(x)> ;


10.4.5 Function SUCC

Function SUCC returns the n-th successor of its first operand where n is the
second operand. Its first operand may be of any ordinal type and its second
operand may be of any unsigned Z-Type. Its return type is always the same as
the type of its first operand. Its pseudo-definition is:

PROCEDURE SUCC ( x : <ordinalType>; n : <unsignedType> ) : <typeOf(x)> ;


10.4.6 Function ORD

Function ORD returns the ordinal value of its operand. Its operand may be of
any ordinal type. Its return type is the Z-Type. Its pseudo-definition is:

PROCEDURE ORD ( x : <ordinalType> ) : <Z-Type> ;


10.4.7 Function CHR

Function CHR returns the character whose code point is its operand. Its
operand may be of any unsigned Z-Type. If the value of its operand is less
than 128 then its return type is CHAR, otherwise its return type is UNICHAR.
Its pseudo-definition is:

PROCEDURE CHR ( x : <unsignedType> ) : <charOrUnicharType> ; 


10.4.8 Function COUNT

Function count returns the number of items stored in its operand. Its operand
may be of any set type or collection type. Its return type is LONGCARD.
Its pseudo-definition is:

PROCEDURE COUNT ( c : <setOrCollectionType> ) : LONGCARD ;


10.4.9 Function SIZE

Function SIZE returns the allocation size of its operand. The value returned
represents the number of octets allocated for its operand. Its operand may be
a variable of any type. Its return type is LONGCARD. Its pseudo-defintion is:

PROCEDURE SIZE ( variable : <anyType> ) : LONGCARD ;


10.4.10 Function HIGH

Function HIGH returns the highest subscript of its operand. Its operand may be
a variable of an indexed array type or the identifier of an open array para-
meter or variadic parameter list. Its return type is LONGCARD. Its pseudo-
definition is:

PROCEDURE HIGH ( ident : <arrayOrVariadicList> ) : LONGCARD ;


10.4.11 Function LENGTH

Function LENGTH returns the number of characters in its operand. Its operand
may be of any character array type. Its return type is LONGCARD. Its pseudo-
definition is:

PROCEDURE LENGTH ( s : <characterArray> ) : LONGCARD ;


10.4.12 Function NEXTV

Function NEXTV returns a pointer to the next item in a value-terminated
variadic parameter list or NIL if the end of parameter list has been reached.
Its operand is an identifier of a value-terminated variadic parameter list.
Its return type is a pointer to the base type of the variadic parameter list.
Its pseudo-definition is:

PROCEDURE NEXTV ( ident : <variadicList> ) : <pointerToVariadicBaseType> ;


10.4.13 Function TMIN

Function TMIN returns the smallest legal value of its operand. Its operand is
an identifier denoting any Z-Type or R-Type. Its return type is the operand.
Its pseudo-definition is:

PROCEDURE TMIN ( T : <typeIdentifier> ) : <T> ;


10.4.14 Function TMAX

Function TMIN returns the largest legal value of its operand. Its operand is
an identifier denoting any Z-Type or R-Type. Its return type is the operand.
Its pseudo-definition is:

PROCEDURE TMAX ( T : <typeIdentifier> ) : <T> ;


10.4.15 Function TSIZE

Function TSIZE returns the required allocation size of a type. The value
returned represents the number of octets required to allocate a variable of
the type denoted by its operand. Its operand is an identifier denoting a type.
Its return type is LONGCARD. Its pseudo-defintion is:

PROCEDURE TSIZE ( T : <typeIdentifier> ) : LONGCARD ;


10.4.16 Function VAL

Function VAL is a macro that is provided only as a measure of legacy support.
Any invocation is replaced by an equivalent type conversion expression. The
invocation 'VAL(T, x)' is replaced by type conversion expression 'x :: T'.

PROCEDURE VAL ( T : <typeIdentifier>; x : <anyType> ) : <T> ; => x :: T

CAUTION: This macro may be deprecated in a future revision and its use should
be avoided. The type conversion operator :: should always be used instead.


10.5 Built-in Lexical Macros

User-definable lexical macros are not provided in Modula-2 (on purpose), but
there are two built-in lexical macros: MIN and MAX.

Macro MIN is replaced with the smallest constant from its variadic argument
list and Macro MAX is replaced with the largest constant from its variadic
argument list. All arguments must be numeric constants or numeric constant
expressions. Examples:

x := MIN( 1, 2, 3 ) => x := 1
x := MAX( 1, 2, 3 ) => x := 3


11 Generics

Syntax for generic programming is not provided in Modula-2 R10 (on purpose).
Instead, generic programming is supported via the Modula-2 Template Engine,
or M2TE, a text templating utility that is external to the compiler.

The M2TE utility is invoked by passing the name of a template file and one or
more translations for placeholders in the template file as parameters. It then
recursively replaces all the placeholders with their respective translations,
thereby generating the source text for a library module that is then written
to a set of Modula-2 source files available for import by any Modula-2 library
or program.

The M2TE utility recognises any string prefixed and suffixed by @@ as a place-
holder and any line that starts with %% as a comment not to be copied into the
output. To produce these symbols verbatim they may be escaped with backquote.

The M2TE utility may be invoked manually or automatically by the compiler on a
generate-on-demand basis using the MAKE pragma within a Modula-2 source file.

EBNF:

m2teInvocation :
    "m2te" templateFilename ( placeholderName ":" translation )*

By convention, the first placeholder name is always "module", standing in for
the name of the module to be generated.

Example:

$ m2te Stack module:IntegerStack componentType:INTEGER

The example above invokes the M2TE utility to read template files Stack.def
and Stack.mod, replace any occurences of the passed placeholders "module" and
"componentType" with "IntegerStack" and "INTEGER" respectively, and write the
resulting output into Modula-2 source files named IntegerStack.def and
IntegerStack.mod respectively.

The MAKE pragma may be used to generate a module on demand from within the
source text of a client module or program.

Example:

<* MAKE = "m2te Stack module:IntegerStack componentType:INTEGER" *>
IMPORT IntegerStack; (* import the generated module *)

The standard library provides a portfolio of generic templates for commonly
used abstract data types. A list of templates and their brief descriptions
can be found in the Standard Library section of this document.


12 Standard Library

The public repository with the complete definition parts of the Modula-2 R10
standard library is available at:

http://bitbucket.org/trijezdci/m2r10stdlib/src

A list of modules with a brief description for each module is given below.


12.1 Pseudo Modules

Pseudo modules provide interfaces to the system or the compiler itself and
are therefore built-in. However, the identifiers they provide need to be
expclicity imported to be availble.

There are four mandatory pseudo modules, one optional pseudo module and one
documentation module:

ATOMIC.def            provides atomic intrinsics
SYSTEM.def            access to system dependent resources
RUNTIME.def           interface to the Modula-2 runtime system
COMPILER.def          interface to the Modula-2 compile-time system
ASSEMBLER.def         access to target dependent inline assember (optional)
BINDINGS.def          documents procedure headers required for bindings 


12.2 Definitions of Bindings

Bindings definitions define semantic types which specify common semantics that
data types may be required to conform to:

ZTYPE.def             defines semantic properties for all whole number types
RTYPE.def             defines semantic properties for all real number types
CTYPE.def             defines semantic properties for all complex number types
VTYPE.def             defines semantic properties for all numeric vector types
ArrayType.def         defines semantic properties for static array types
SetType.def           defines semantic properties for static set types
DateType.def          defines semantic properties for date-time types
StringType.def        defines semantic properties for dynamic string types
CollectionType.def    defines semantic properties for dynamic collection types


12.3 Memory Management Modules

Storage.def           dynamic memory allocator


12.4 Modules for Exception Handling and Termination

Exceptions.def        exception handling
Termination.def       termination handling


12.5 File System Modules

Filesystem.def        file system operations using absolute paths
DefaultDir.def        file system operations relative to a working directory
Pathnames.def         operating system independent pathname operations


12.6 File IO Modules

FileIO.def            file oriented input and output
TextIO.def            line oriented input and output
RegexIO.def           regular expression based input and output
Scanner.def           primitives for scanning text files
Terminal.def          terminal based input and output


12.7 IO Modules for SYSTEM Types

BYTE.def              IO module for type BYTE
WORD.def              IO module for type WORD
ADDRESS.def           IO module for type ADDRESS


12.8 IO Modules for Pervasive Types:

PervasiveIO.def       aggregator module to import all pervasive IO modules
BOOLEAN.def           IO module for type BOOLEAN
BITSET.def            IO module for type BITSET
LONGBITSET.def        IO module for type LONGBITSET
CHAR.def              IO module for type CHAR
ARRAYOFCHAR.def       IO module for ARRAY OF CHAR types
UNICHAR.def           IO module for type UNICHAR
ARRAYOFUNICHAR.def    IO module for ARRAY OF UNICHAR types
OCTET.def             IO module for type OCTET
CARDINAL.def          IO module for type CARDINAL
LONGCARD.def          IO module for type LONGCARD
INTEGER.def           IO module for type INTEGER
LONGINT.def           IO module for type LONGINT
REAL.def              IO module for type REAL
LONGREAL.def          IO module for type LONGREAL


12.9 Library Modules Implementing Basic Types

BS16.def              16-bit bitset type
BS32.def              32-bit bitset type
BS64.def              64-bit bitset type
BS128.def             128-bit bitset type
CARD16.def            16-bit unsigned integer type
CARD32.def            32-bit unsigned integer type
CARD64.def            64-bit unsigned integer type
CARD128.def           128-bit unsigned integer type
INT16.def             16-bit signed integer type
INT32.def             32-bit signed integer type
INT64.def             64-bit signed integer type
INT128.def            128-bit signed integer type
BCD.def               single precision binary coded decimals
LONGBCD.def           double precision binary coded decimals
COMPLEX.def           single precision complex number type
LONGCOMPLEX.def       double precision complex number type
CHARSET.def           character set type
STRING.def            dynamic ASCII strings
UNISTRING.def         dynamic unicode strings
Unsigned24.def        unsigned integer subrange type with values from 0 to 23
Unsigned31.def        unsigned integer subrange type with values from 1 to 31
Unsigned60.def        unsigned integer subrange type with values from 0 to 59
UnsignedReal60.def    real subrange type with values from 0.0 to 59.999


12.10 Modules Defining Alias Types

Bitsets.def           alias types for bitsets with guaranteed widths
Cardinals.def         alias types for unsigned integers with guaranteed widths
Integers.def          alias types for signed integers with guaranteed widths
SHORTBITSET.def       alias type for bitset with smallest width
LONGLONGBITSET.def    alias type for bitset with largest width
SHORTCARD.def         alias type for unsigned integers with smallest width
LONGLONGCARD.def      alias type for unsigned integers with largest width
SHORTINT.def          alias type for signed integers with smallest width
LONGLONGINT.def       alias type for signed integers with largest width


12.11 Modules Providing Math for Basic Types

RealMath.def          mathematic constants and functions for type REAL
LongRealMath.def      mathematic constants and functions for type LONGREAL
BCDMath.def           mathematic constants and functions for type BCD
LongBCDMath.def       mathematic constants and functions for type LONGBCD
ComplexMath.def       mathematic constants and functions for type COMPLEX
LongComplexMath.def   mathematic constants and functions for type LONGCOMPLEX


12.12 Modules Providing Primitives for Text Handling

ASCII.def             mnemonics and macro-functions for ASCII characters
Regex.def             Modula-2 regular expression library
RegexConv.def         conversion library for regular expression syntax


12.13 Modules for Date and Time Handling

TZ.def                time zone offsets and abbreviations
Time.def              compound time with day, hour, minute, sec/msec components
DateTime.def          compound calendar date and time
TimeUnits.def         date and time base units
SysClock.def          interface to the system clock


12.14 Modules with Legacy Interfaces

LegacyPIM.def         selected legacy PIM functions and procedures
LegacyISO.def         selected legacy ISO functions and procedures


12.15 Template Library

Stack.def             generic stack template
Queue.def             generic queue template
DEQ.def               generic double ended queue template
PriorityQueue.def     generic priority queue template
AATree.def            generic AA tree template
SplayTree.def         generic Splay tree template
PatriciaTrie.def      generic Patricia trie template
DynamicArray.def      generic dynamic array template
KeyValueStore.def     generic key value storage template
SubrangeInteger.def   generic integer subrange type template
NonZeroIndexArray.def generic non-zero index array type template


[status: May, 15, 2010] (C) 2010 B.Kowarsch & R.Sutcliffe. All rights reserved.