Modula-2 R10 Concise Language Description

This document is a concise description of a dialect of the Modula-2 programming
language, tentatively called R10, jointly developed in 2009 and 2010 by
B.Kowarsch and R.Sutcliffe as a modern revision of classic Modula-2.

At the time of writing, the authoritative language report is still work in
progress and has not yet been published. The present document is intended
strictly as a non-authoritative informational source for contributors who
wish to participate in work on the reference compiler, the standard library
and associated compliance test tools. Details may change without prior notice.


The notation used to describe syntax in this document is based on the EBNF
notation used by the lexer and parser generator ANTLR:

* names that start with a capital letter represent terminal symbols
* names that start with a lowercase letter represent non-terminal symbols
* single and double quotes are used to delimit literals
* parentheses are used to group syntactic entities
* the vertical bar is used to separate alternatives
* a preceding tilde is used to denote logical not
* a trailing question mark is used to denote zero or one occurence
* a trailing plus sign is used to denote one or more occurences
* a trailing asterisk is used to denote zero or more occurences
* a colon is used between a production rule's name and its body
* a semicolon is used to terminate a production rule


1 Lexical Entities

1.1 Special Symbols

Special symbols are non-alphanumeric characters or sequences of two
non-alphanumeric characters that have special meaning in the language.

List of Special Symbols

!     denotes ADT binding to [ ]
#     not-equal operator, obsoletes <>
&     synonym for logical AND operator
*     multiplication and set intersection operator
+     addition and set union operator
++    postfix increment operator
,     punctuation, used as a separator in item lists
-     subtraction and set difference operator
--    postfix decrement operator
.     punctuation, used as a separator, decimal point and module terminator
..    range operator
/     division and symmetric set difference operator
:     punctuation, used as a separator between identifiers and formal types
::    type conversion operator
:=    assignment operator
;     punctuation, used as a separator in statement sequences
<     less-than and true-subset relational operator
<=    less-than-or-equal and subset relational operator
=     equal operator
>     greater-than and true-superset relational operator
>=    greather-than-or-equal and superset relational operator
^     pointer dereferencing operator
|     punctuation, used as a separator in case label lists
~     synonym for logical NOT operator
'     single quote, used as a string delimiter
"     double quote, used as a string delimiter
\     escape symbol within a quoted string

[ ]   brackets, used as index operator and to delimit special syntax
( )   parentheses, used to group expressions and to delimit argument lists
{ }   braces, used to delimit structured literals

<*    opening delimiter for pragmas
*>    closing delimiter for pragmas
//    single line comment prefix
(*    opening delimiter for nestable comments
*)    closing delimiter for nestable comments
/*    opening delimiter for non-nestable comments
*/    closing delimiter for non-nestable comments


1.2 Non-Semantic Symbols

Non-semantic symbols are symbols that do not impact the meaning of a program.
They may occur anywhere in a program before or after semantic symbols but not
within them. There are three types of non-semantic symbols:

* pragmas
* comments
* lexical separators


1.2.1 Pragmas

Pragmas are directives used to control the translation process but do not
change the meaning of the program text. Pragmas consist of a pragma name
optionally followed by other symbols, delimited by "<*" and "*>".

There are two types of pragmas:

* implementation defined pragmas
* language defined pragmas

EBNF:

pragma : "<*" pragmaName otherSymbols? "*>" ;

pragmaName : Ident ;


1.2.1.1 Implementation Defined Pragmas

Any implementation may define its own set of pragmas, specific to the compiler.
Implementation defined pragma names must not be all-uppercase words.


1.2.1.2 Language Defined Pragmas

Language defined pragmas use all-uppercase words as pragma names. The pragma
names of language defined pragmas are reserved.

List of Language Defined Pragma Names

IF               INFO             FATAL            MAKE             VOLATILE
ELSIF            WARN             ALIGN            INLINE
ENDIF            ERROR            FOREIGN          NOINLINE


1.2.2 Comments

Comments are symbols ignored by the compiler but intended for a human reader.
There are three types of comments:

* single line comments
* nestable multi-line comments
* non-nestable multi-line comments

EBNF:

Comment : SingleLineComment | NestableComment | NonNestableComment ;
SingleLineComment : "//" ~( EndOfLine )* EndOfLine ;
NestableComment : "(*" ~( "*)" )* NestableComment* "*)" ;
NonNestableComment : "/*" ~( "*/" )* "*/" ;

Examples:

// comment until end-of-line
/* This is a non-nesting comment */
(* This is a comment (* and a comment within *) *)

Non-nestable C-style comments are intended strictly to allow support of
source code processing tools that require such comments. For ordinary
multi-line comments, classic Modula-2 style comments are recommended.


1.2.3 Lexical Separators

Tab and newline are ignored anywhere in a program. The space character is
ignored anywhere other than within string literals. These symbols always
terminate a numeric literal, an identifier, a reserved word or a pragma name.

EBNF:

LexicalSeparator : " " | TAB | NewLine ;
NewLine : LF CR? | CR LF? ;


1.3 Literals

There are three types of literals:

* numeric literals
* string literals
* structured literals


1.3.1 Numeric literals

There are three types of numeric literals

* character code literals
* whole number literals
* real number literals


1.3.1.1 Character Code Literals

Character code literals are base-16 numbers, indicated by suffix "C".

EBNF:

charCode : Digit Base16Digit+ "C" ;

Examples: 0C, 0AC, 7FC


1.3.1.2 Whole Number Literals

There are three types of whole number literals

* base-10, without suffix
* base-2, with suffix "B"
* base-16, with suffix "H"

DecimalValue : Digit+ ;
BinaryValue : BinaryDigit+ "B" ;
Base16Value : Digit Base16Digit+ "H" ;

Examples: 42, 01101010B, 0BEEFH


1.3.1.3 Real Number Literals

Real number literals are base-10 numbers, always with an integral part,
a decimal point and a fractional part, optionally followed by an exponent.

RealValue : Digit+ "." Digit+ ( "E" ( "+" | "-" )? Digit+ )? ;

Examples: 0.0, 123.45, 3.1415926, 7.523012E+12


1.3.2 String Literals

String literals are sequences of characters left- and right-delimited by
single quotes or double quotes.

String : "'" ( Character | '"' )* "'" |
         '"' ( Character | "'" )* '"' ;

Character : Digit | Letter |
	        " " | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" |
            "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" |
            "@" | "[" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~" |
            EscapeSequence ;
Digit : "0" .. "9" ;
Letter : "A" .. "Z" | "a" .. "z" ;
EscapeSequence : "\" ( "0" | "n" | "r" | "t" | "\" | "'" | '"' ) ;

Examples:

"it's nine o'clock"
'he said "Modula-2" and smiled'
"this is the end of the line\n"


1.3.3 Structured Literals

Structured literals are compound values whith comma separated numeric literals,
string literals or structured literals, always enclosed in braces.

constStructuredValue :
	"{" ( constValueComponent ( "," constValueComponent )* )? "}" ;
constValueComponent :
	constExpression ( ( BY | ".." ) constExpression )? ;

Examples:

{ 0 BY 100 }, { 1 .. 10 }
{ "abc", 123, 456.78, { 1, 2, 3 } }
{ 1970, Month.Jan, 1, 0, 0, 0.0, TZ.UTC }


1.4 Identifiers

Identifiers are names for syntactic entities in a program. There are two
types of identifiers:

* user-definable identifiers
* language defined identifiers, aka reserved words


1.4.1 User-definable Identifiers

Identifiers are names that start with a letter, lowline or dollar sign,
followed by any number and combination of letters, lowlines, dollar signs
and digits. User definable identifiers must not coincide with reserved words.
The use of the dollar sign in identifiers should be limited to referencing
entities defined by an operating system API for public use (eg. OpenVMS).

Ident : ( "_" | "$" | Letter ) ( "_" | "$" | Letter | Digit )* ;


1.4.2 Reserved Words

Reserved words are identifiers that have special meaning in the language.

List of Reserved Words

ALIAS            DIV              IMPLEMENTATION   OR               TYPE         
AND              DO               IMPORT           POINTER          UNTIL
ARRAY            ELSE             IN               PROCEDURE        VAR
ASSOCIATIVE      ELSIF            LOOP             RECORD           VARIADIC
BEGIN            END              MOD              REPEAT           WHILE
BY               EXIT             MODULE           RETURN
CASE             FOR              NOT              SET
CONST            FROM             OF               THEN
DEFINITION       IF               OPAQUE           TO


1.5 Symbols Reserved for Language Extensions and External Utilities

1.5.1 Symbols Reserved for Use by Language Extensions

Although not part of the language specification, certain symbols are reserved
specifically for use by language extensions. Three such language extensions
are supported:

* Parallel Modula-2
* Objective Modula-2
* single-pass compilers


1.5.1.1 Symbols Reserved for Parallel Modula-2

The following identifiers are reserved for exclusive use by the Parallel
Modula-2 language extension:

ALL PARALLEL SYNC

The following pragma names are reserved for exclusive use by the Parallel
Modula-2 language extension:

LOCAL SPREAD CYCLE SBLOCK CBLOCK


1.5.1.2 Symbols Reserved for Objective Modula-2

The following identifiers are reserved for exclusive use by the Objective
Modula-2 language extension:

BYCOPY BYREF CLASS CONTINUE CRITICAL INOUT METHOD ON OPTIONAL OUT PRIVATE
PROCECTED PROTOCOL PUBLIC SUPER TRY

The following pragma names are reserved for exclusive use by the Objective
Modula-2 language extension:

FRAMEWORK IBACTION IBOUTLET QUALIFIED


1.5.1.3 Symbols Reserved for Single-Pass Compilers

The following pragma name is reserved for use by single-pass compilers:

FORWARD


1.5.2 Symbols Reserved for Use by External Utilities

To assist external source code processing prior to compilation, the following
symbols are reserved for exclusive use by external source code processors:

?   reserved for use by editors or di-/tri-graph converters
@@  reserved for use by template engine or make utilities
%%  reserved for use by template engine or make utilities

These symbols may only legally occur within quoted strings and comments. Their
use within source code as special control symbols is safe prior to compilation.


2 Compilation Units

A compilation unit is a sequence of source code that can be independently
compiled. There are three types of compilation units:

* a program module
* the interface part of a library module
* the implementation part of a library module

EBNF:

compilationUnit :
    programModule | definitionOfModule | implementationOfModule ;


2.1 Program Modules

A Modula-2 program consists of exactly one program module and zero or more
library modules. A program module does not export any identifiers. The body
of a program module roughly corresponds to the main() function in a C program.

EBNF:

programModule :
    MODULE moduleId ( '[' priority ']' )? ';'
    importList* block moduleId '.'

moduleId : Ident ;


2.2 Definition Part of Library Modules

The definition part of a library module represents the public interface of the
library module. Any identifier defined in the definition part is automatically
available for import by other modules.

EBNF:

definitionOfModule :
    DEFINITION MODULE moduleId ';'
    importList* definition*
    END moduleId '.'


2.3 Implementation Part of Library Modules

The implementation part of a library module represents the implementation of
the library module. Any identifier defined in the corresponding definition
part is automatically available in the implementation part. Any identifier
defined in the implementation part is not available outside of the
implementation part.

EBNF:

implementationOfModule :
    IMPLEMENTATION programModule ;


2.4 Module Initialisation

The body of the implementation part of a library module is the library's
initialisation procedure. It is automatically executed by the Modula-2
runtime environment when a Modula-2 program is run.

The order in which modules are initialised is language defined and depends
on the module dependency graph. During compilation a module dependency graph
is built and the initialisation order is determined by depth-first traversal
order of the dependency graph whereby initialisation takes place for each
node from bottom to top on the way back up.


2.5 Module Termination

Module termination is not a language feature but it is a facility provided
by a library module in the standard library. The termination library provides
an API for client modules that require termination to install their own
termination handlers onto the library's termination handler stack.

The termination library installs its own wind down procedure in the runtime
environment during module initialisation. The wind down procedure then calls
the installed termination handlers in reverse order when the program is about
to be terminated.


3 Import of Identifiers

Identifiers defined in the interface of a library module may be imported by
other modules using an import directive. There are two types of import:

* qualified import
* unqualified import

EBNF:

importList :
    ( FROM moduleId IMPORT ( identList | '*' ) |
    IMPORT Ident '+'? ( ',' Ident '+'? )* ) ';'


3.1 Qualified Import

When an identifier is imported by qualified import, it must be qualified with
the exporting module's module name when it is referenced in the importing
module. This avoids name conflicts when importing identically named
identifiers from different modules.

Example:

IMPORT FileIO; (* qualified import of module FileIO *)
VAR status : FileIO.Status; (* qualified identifier of Status *)


3.1.1 Import Aggregators

A module imported by qualified import may be automatically re-exported to any
importing client module. Modules to be re-exported in this way are marked with
a plus sign after their identifiers.

A module that imports other modules for the sole purpose of re-export is
called an import aggregator. This facility is useful to allow clients to
import an entire library with a single import statement.

Example:

DEFINITION MODULE FooBarBaz;
IMPORT Foo+, Bar+, Baz+; (* import Foo, Bar and Baz into client module *)
END FooBarBaz.

IMPORT FooBarBaz; (* imports all modules imported by FooBarBaz and marked + *)


3.1.2 Import of Abstract Data Type Library Modules

If the interface of a module defines a type that has the same name as the
module, the type is referenced unqualified. This facility is useful in the
construction of abstract data types as library modules.

Example:

DEFINITION MODULE Colour;
TYPE Colour = ( red, green, blue );
(* public interface *)
END Colour.

IMPORT Colour;
VAR colour : Colour;


3.2 Unqualified Import

When an identifier is imported by unqualified import, it is made available in
the importing module as is. This will lead to a name conflict and cause a
compile time error when importing identically named identifiers from different
modules.

Example:

FROM FileIO IMPORT Status; (* unqualified import of Status *)
VAR status : Status; (* unqualified identifier of Status *)


3.2.1 Wildcard Import

An unqualified import directive may import all available identifiers of a
library module by using an asterisk as a wildcard.

Example:

FROM FileIO IMPORT *; (* import all identifiers *)


4 Blocks

*** to do ***


5 Definitions and Declarations

A definition is a directive that defines an identifier in the public interface
of a library module. A declaration is a directive that declares an identifier
in a program module or in the implementation part of a library module.
There are four types of definitions and declarations:

* constant definitions and declarations
* variable definitions and declarations
* type definitions and declarations
* procedure definitions and declarations


5.1 Constant Definitions and Declarations

A constant is an immutable value determined at compile time. A constant may be
defined or declared as an alias of another constant, but it may not be defined
or declared as an alias of a variable, a type or a procedure.

EBNF:

constDefinition :
    CONST ( ( "[" Ident "]" )? Ident "=" constExpression ";" )* ;

constDeclaration :
    CONST ( Ident "=" constExpression ";" )* ;

Examples:

CONST zero = 0;
CONST maxInt = TMAX(INTEGER);


5.2 Variable Definitions and Declarations

A variable is a variant whose value is determined at runtime and may change at
runtime. A variable always has a type which is determined at compile time.

EBNF:

varDefinition :
    VAR ( Ident ( "[" address "]" | "," identList )?
          : ( namedType | anonymousType ) ";" )* ;
varDeclaration : varDefinition ;

Examples:

VAR x, y : REAL;
VAR portA [mappedIOAddr] : OCTET;


5.2.1 Global Variables

A variable defined or declared in the top level of a module has a global life
span. It exists throughout the entire runtime of the program. However, a
global variable does not have global scope. It is only visible within the
module it is defined or declared in and within modules that import it.

A variable declared in the top level of a library module is always exported
immutable. It can be modified within the library module's implementation part
but it cannot be modified within modules that import it.


5.2.2 Local Variables

A variable declared within a procedure has local life span and local scope. It
only exists at the time the procedure is executing and it is only visible
within the procedure it is declared in and within procedures local to the
procedure it is declared in.


5.3 Type Definitions and Declarations

A type is an abstract property that determines the storage size and layout of
variables and the operations that are permitted for variables of the type.

EBNF:

typeDefinition :
    TYPE ( Ident = ( type | opaqueType ) ";" )* ;
typeDeclaration :
    TYPE ( Ident = type ";" )* ;
    
Examples:

TYPE Volume = INTEGER;
TYPE HashTable = OPAQUE;


5.3.1 Strict Name Equivalence

Modula-2 R10 uses strict name equivalence. By default types of different names
are always incompatible even if they are derived from the same base type.

Example:

TYPE Celsius = REAL; Fahrenheit = REAL;
VAR celsius : Celsius; fahrenheit : Fahrenheit;

celsius := fahrenheit; (* compile time error: incompatible types *)

In order to assign values across type boundaries, type conversion is required.

Example:

celsius := (fahrenheit - 32.0) * 100.0/180.0 :: Celsius; (* type conversion *)


5.3.2 Alias Types

If a type is desired to be compatible with another type it must be defined or
declared as an alias type.

Example:

TYPE INT = ALIAS OF INTEGER;
VAR i : INT; j : INTEGER;

i := j; (* i and j are compatible *)


5.3.3 Opaque Types

A type may be defined as an opaque type. The identifier of an opaque type is
available in the library where it is defined and in modules that import it.
However, the implementation details of an opaque type are only available
within the implementation part of the library where it is defined. This
facility is useful for the construction of abstract data types.

There are two types of opaque types:

* opaque pointer types
* opaque record types


5.3.3.1 Opaque Pointers

An opaque pointer type is a pointer to a type whose declaration is hidden in
the corresponding implementation part. Objects of the abstract data type can
only be allocated dynamically at runtime.

EBNF:

opaquePointer : TYPE Ident "=" OPAQUE ";" ;

Example:

DEFINITION MODULE Tree;
TYPE Tree = OPAQUE; (* opaque pointer *)
(* public interface *)
END Tree.

IMPLEMENTATION MODULE Tree;
TYPE Tree = POINTER TO TreeDescriptor;
TYPE TreeDescriptor = RECORD left, right : Tree; value : ValueType END;
(* implementation *)
END Tree.

IMPORT Tree;
VAR tree : Tree;
NEW(tree); (* dynamic allocation of a variable of abstract data type Tree *)


5.3.3.2 Opaque Records

An opaque record type is an opaque type that represents a record type instead
of a pointer to a record type. Objects of the abstract data type can be
allocated either statically as global or local variables or dynamically.

In order for the compiler to be able to allocate a variable of an opaque
record type statically, it must be able to determine its allocation size.
However, the allocation size of a record can only be determined from the
record type's declaration. For this reason, the declaration of an opaque
record type is lexically located in the definition part where it is defined
but it is semantically treated as if it was hidden in the corresponding
implementation part. Only the identifier of an opaque record is visible to
modules that import it. Its internal structure is not available to them.

EBNF:

opaqueRecord : TYPE Ident "=" OPAQUE recordType ";" ;

Example:

DEFINITION MODULE BigInteger;
TYPE BigInteger = OPAQUE RECORD highDigits, lowDigits : INTEGER END;
(* public interface *)
END BigInteger.

IMPORT BigInteger;
VAR bigInt : BigInteger; i : INTEGER;
i := bigInt.highDigits; (* compile time error: hidden component *)


5.3.4 Anonymous Types

5.3.5 Enumeration Types

5.3.6 Array Types

5.3.6.1 Indexed Array Types

5.3.6.2 Associative Array Types

5.3.7 Record Types

5.3.8 Set Types

5.3.9 Pointer Types

5.3.10 Procedure Types


5.4 Procedure Definitions and Declarations


6 Statements

*** to do ***


7 Expressions

*** to do ***


8 Structured Values

*** to do ***


9 Pragmas

Pragmas are directives used to control or influence the translation process
but they do not change the meaning of the program text.

There are two types of pragmas:

* implementation defined pragmas
* language defined pragmas


9.1 Implementation Defined Pragmas

Implementation defined pragmas are compiler specific and non-portable. They
are easily recognisable because their pragma names are either all-lowercase
or mixed-case but never all-uppercase words.

EBNF:

implementationDefinedPragma :
    "<*" pragmaName ( "+" | "-" | "=" ( Ident | Number ) )? "*>" ;

pragmaName : Ident ;


9.2 Language Defined Pragmas

Language defined pragmas are portable across implementations. They are easily
recognisable because their pragma names are all-uppercase words. There are
three groups of language defined pragmas:

* pragmas to control conditional compilation
* pragmas to emit console messages during compilation
* pragmas to control, influence or optimise code-generation


9.2.1 Conditional Compilation Pragmas

Conditional compilation pragmas are used to compile portions of the source
text only if a certain condition is met. The condition must be a compile
time expression.

EBNF:

conditionalCompilationPragma :
    "<*" ( IF | ELSIF ) constExpression | ELSE | ENDIF "*>" ;

Example:

TYPE Model = ( small, large, custom );

<* IF TSIZE(INTEGER) = 2 *>
CONST model = Model.small;
<* ELSIF TSIZE(INTEGER) = 4 *>
CONST model = Model.large;
<* ELSIF TSIZE(INTEGER) MOD 2 = 0 *>
CONST model = Model.custom;
<* ELSE *>
<* FATAL "unsupported type model." *>
<* ENDIF *>


9.2.2 Compile Time Console Message Pragmas

Compile time console message pragmas are used to emit console messages during
compilation. There are four types of message pragmas:

* pragmas emitting informational messages
* pragmas emitting compilation warnings
* pragmas emitting compilation errors
* pragmas emitting fatal compilation errors

Informational messages and warnings do not cause the compilation to fail.
Error messages cause the compilation to fail but continue. Fatal messages
cause the compilation to fail and abort immediately.

EBNF:

compileTimeMessagePragma :
    "<*" ( INFO | WARN | ERROR | FATAL ) quotedStringLiteral "*>" ;

Example:

<* FATAL "unsupported target architecture." *>


9.2.3 Code Generation Pragmas

Code generation pragmas are used to control or influence code generation and
optimisation. There are six code generation pragmas:

* pragma to force specified memory alignment
* pragma to force specified calling convention
* pragma to cause the build system to invoke an external utility
* pragma to suggest inlining a procedure
* pragma to suggest not inlining a procedure
* pragma to mark a variable as volatile

EBNF:

codeGenerationPragma :
    "<*" ( ALIGN "=" constExpression |
           FOREIGN ( "=" quotedStringLiteral )? |
           MAKE "=" quotedStringLiteral |
           INLINE | NOINLINE | VOLATILE ) "*>" ;

Examples:

TYPE Point = RECORD <* ALIGN = 8*TSIZE(CARDINAL) *> x, y : OCTET END;
<* FOREIGN = "C" *> PROCEDURE atoi ( CONST s : ARRAY OF CHAR ) : INTEGER;
<* MAKE = "genhashes foo bar baz > Hashes.def" *>
<* INLINE *> PROCEDURE P;
<* NOINLINE *> PROCEDURE Q;
VAR <* VOLATILE *> signal : Signal;


10 Pervasive Identifiers

Pervasive Identifiers are predefined identifiers that are available in every
scope of a program without having to import them. Unlike reserved words,
pervasive identifiers may be redefined by libraries or program modules.

There are four groups of pervasive identifiers:

* predefined constants
* predefined types
* predefined procedures
* predefined functions
* builtin compile-time macros


10.1 Predefined Constants

There are three predefined constants:

NIL    invalid pointer value, shorthand for 0 :: POINTER TO CONST OCTET
TRUE   shorthand for BOOLEAN.TRUE
FALSE  shorthand for BOOLEAN.FALSE


10.2 Predefined Types

There are twelve predefined types:

BOOLEAN     boolean type, TYPE BOOLEAN = ( TRUE, FALSE );
BITSET      bitset type of same size as CARDINAL
LONGBITSET  bitset type of same size as LONGCARD
CHAR        7-bit character type, first 128 code points of UTF-8
UNICHAR     4-octet character type, all code points of UTF-32
OCTET       unsigned 8-bit integer type
CARDINAL    unsigned integer type, 2*n octets for n >= 1
LONGCARD    unsigned integer type, 2*n octets for n >= 1
INTEGER     signed integer type, 2*n octets for n >= 1
LONGINT     signed integer type, 2*n octets for n >= 1
REAL        real number type
LONGREAL    double precision real number type

Although these types are predefined, their IO operations are not. The IO
operations corresponding to READ, WRITE and WRITEF for pervasive types are
provided in the standard library and need to be imported to become available.


10.3 Predefined Procedures

All predefined procedures are Wirthian macros. They act and look like library
defined procedures but they may not be assigned to procedure variables, may
not be passed to a procedure as parameters and calls to them are replaced by
the compiler with a call to a corresponding library procedure.

There are five predefined procedures:

* NEW
* DISPOSE
* READ
* WRITE
* WRITEF


10.3.1 Procedure NEW

Procedure NEW is used to dynamically allocate storage for a variable of a
pointer type. A call to procedure NEW is replaced by the compiler with a call
to library procedure ALLOCATE which must be imported before NEW can be used.
The standard library provides an ALLOCATE procedure in module Storage.

Library procedure ALLOCATE always requires a second parameter to specify the
allocation size of the type that the pointer variable points to. The compiler
automatically determines the allocation size for the pointer variable passed
to NEW and passes the appropriate size value as a second parameter to library
procedure ALLOCATE when it replaces the procedure call.

Example:

TYPE FooPtr = POINTER TO Foo;
VAR fooptr : FooPtr;

NEW(fooptr); (* replaced by ALLOCATE(fooptr, TSIZE(Foo)); *)

When NEW is used to allocate storage for a variable of indeterminate type
a second parameter is required to pass the determinant value for the type.

Example:

TYPE VLA = RECORD items : CARDINAL; array : ARRAY items OF INTEGER END;
TYPE VLAPtr = POINTER TO VLA;
VAR v : VLAPtr;

NEW(v, 100); (* replaced by ALLOCATE(v, TSIZE(VLA) + 100*TSIZE(INTEGER)); *)


10.3.2 Procedure DISPOSE

Procedure DISPOSE is used to deallocate storage that was earlier allocated by
a call to procedure NEW. A call to procedure DISPOSE is replaced by the
compiler with a call to a library procedure DEALLOCATE which must be imported
before DISPOSE can be used. The standard library provides a DEALLOCATE
procedure in module Storage. Procedure DISPOSE always requires a single
parameter only.

Examples:

DISPOSE(fooptr); (* replaced by DEALLOCATE(fooptr, TSIZE(Foo)); *)

DISPOSE(v); (* replaced by
               DEALLOCATE(v, TSIZE(VLA) + v^.items*TSIZE(INTEGER)); *)


10.3.3 Procedure READ

Procedure READ is used to read a value from a file or stream and assign it to
a variable. A call to procedure READ is replaced by the compiler with a call
to a library procedure Read which must be defined in a library module that
has the same name as the type of the variable for which a value is being read.

The standard library provides a Read procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call READ on library defined types, the library module
that defines the type must have the same name as the type and it must provide
its own Read procedure.

Examples:

IMPORT PervasiveIO;
VAR n : CARDINAL;
READ(stdIn, n); (* replaced by CARDINAL.Read(stdIn, n); *)

IMPORT BCD;
VAR balance : BCD;
READ(stdIn, balance); (* replaced by BCD.Read(stdIn, balance); *)


10.3.4 Procedure WRITE

Procedure WRITE is used to write a value to a file or stream. A call to
procedure WRITE is replaced by the compiler with a call to a library procedure
Write which must be defined in a library module that has the same name as the
type of the value being written.

The standard library provides a Write procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call WRITE on library defined types, the library module
that defines the type must have the same name as the type and it must provide
its own Write procedure.

Examples:

IMPORT PervasiveIO;
VAR n : CARDINAL;
WRITE(stdOut, n); (* replaced by CARDINAL.Write(stdOut, n); *)

IMPORT BCD;
VAR balance : BCD;
WRITE(stdOut, balance); (* replaced by BCD.Write(stdOut, balance); *)


10.3.5 Procedure WRITEF

Procedure WRITEF is used to write a value to a file or stream using a
given format depending on a formatting string. A call to procedure WRITEF is
replaced by the compiler with a call to a library procedure WriteF which must
be defined in a library module that has the same name as the type of the value
being written.

The standard library provides a WriteF procedure for each pervasive type in a
corresponding module. The IO modules for all pervasive types may be imported
at once by importing aggregator module PervasiveIO.

In order to be able to call WRITEF on library defined types, the library module
that defines the type must have the same name as the type and it must provide
its own WriteF procedure.

Examples:

IMPORT PervasiveIO;
VAR n : CARDINAL;
WRITEF(stdOut, "", n); (* replaced by CARDINAL.WriteF(stdOut, "", n); *)

IMPORT BCD;
VAR balance : BCD;
WRITEF(stdOut, "", balance); (* replaced by BCD.WriteF(stdOut, "", balance); *)


10.4 Predefined Functions

ABS(x)      returns the absolute value of x
NEG(x)      returns the sign reversed value of x
ODD(x)      returns TRUE if x is an odd number
PRED(x, n)  returns the n-th predecessor of x
SUCC(x, n)  returns the n-th successor of x
ORD(x)      returns the ordinal value of x
CHR(x)      returns the character for code point x
COUNT(c)    returns the item count of set/collection
SIZE(v)     returns the allocated size of variable v
HIGH(a)     returns the highest subscript of array or indexed variadic list
LENGTH(s)   returns the length of character string s
NEXTV(v)    returns pointer to next item in value-terminated variadic list
TMIN(T)     returns smallest legal value of type T
TMAX(T)     returns largest legal value of type T
TSIZE(T)    returns number of octets required to allocate variable of type T
VAL(T, x)   equivalent of type conversion expression x :: T


10.5 Built-in Compile Time Expression Replacement Macros

MIN(c1, c2, c3, ...) replaced by smallest constant in argument list
MAX(c1, c2, c3, ...) replaced by largest constant in argument list


11 The Modula-2 Template Engine Utility

*** to do ***


12 Standard Library

*** to do ***


[status: May, 10, 2010] (C) 2010 B.Kowarsch & R.Sutcliffe. All rights reserved.