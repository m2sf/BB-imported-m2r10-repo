(* (C) 2009, 2010 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

DEFINITION MODULE @@module@@;
%% (*
%% SubrangeInteger - Generic Integer Subrange Type Template
%%
%% This template can be expanded using the Modula-2 Template Engine Utility
%%
%% either manually by invoking the m2te utility from a shell:
%%
%%   m2te SubrangeInteger module:Days baseType:OCTET minValue:1 maxValue:31
%%
%% or automatically during compilation using the MAKE pragma in the source:
%%
%%   <* MAKE = "m2te SubrangeInteger
%%              module:Days baseType:OCTET minValue:1 maxValue:31" *>
%%
%% the expanded template can then be imported like any other library module:
%%
%%   IMPORT Days;
%% *)

(* Subrange Integer Type @@module@@ *)


FROM FileIO IMPORT File; (* required for IO *)
IMPORT @@baseType@@;


(* @@module@@ type *)

TYPE
    @@module@@ = OPAQUE RECORD ("Z-Type")
        value : @@baseType@@; 
    END; (* @@module@@ *)


(* Z-Type bindings to operators, pervasives and primitives: *)


(* Range *) 

<* IF @@minValue@@ < TMIN(@@baseType@@) OR @@minValue@@ > TMAX(@@baseType@@) *>
<* FATAL "minValue is not within range of baseType." *>
<* ENDIF *>

<* IF @@maxValue@@ < TMIN(@@baseType@@) OR @@maxValue@@ > TMAX(@@baseType@@) *>
<* FATAL "maxValue is not within range of baseType." *>
<* ENDIF *>

CONST [TMIN] minValue = @@minValue@@;
(* Smallest value of type @@module@@.
   This value is bound to TMIN for type @@module@@. *) 

CONST [TMAX] maxValue = @@maxValue@@;
(* Largest value of type @@module@@.
   This value is bound to TMAX for type @@module@@. *)


(* Literal assignment *)

PROCEDURE [:=] assign ( VAR assignTo : @@module@@; literal : ARRAY OF CHAR );
(* Converts string literal to a @@module@@ value and assigns it to assignTo.
   This procedure is bound to the := operator for literal assignment. *)


(* Type conversions *)

PROCEDURE [::] toCARD  ( n : @@module@@ ) : CARDINAL;
(* Converts Unsigned31 value n to a CARDINAL value and returns it.
   This function is bound to the :: operator for @@module@@ to CARDINAL
   conversion. *)

PROCEDURE [::] toINT ( n : @@module@@ ) : INTEGER; 
(* Converts @@module@@ value n to an INTEGER value and returns it.
   This function is bound to the :: operator for @@module@@ to INTEGER
   conversion. *)

PROCEDURE [::] fromCARD  ( n : CARDINAL ) : @@module@@;
(* Converts CARDINAL value n to a @@module@@ value and returns it.
   This function is bound to the :: operator for CARDINAL to @@module@@
   conversion. *)

PROCEDURE [::] fromINT  ( n : INTEGER ) : @@module@@;
(* Converts INTEGER value n to a @@module@@ value and returns it.
   This function is bound to the :: operator for INTEGER to @@module@@
   conversion. *)


(* Monadic arithmetic operations *)

PROCEDURE [ABS] abs ( n : @@module@@ ) : @@module@@;
(* Returns the absolute value of @@module@@ value n.
   This function is bound to pervasive function ABS for type @@module@@. *)

<* IF @@minValue@@ < 0 *>
PROCEDURE [NEG] neg ( n : @@module@@ ) : @@module@@;
(* Returns the sign reversed value of @@module@@ value n.
   This function is bound to the unary minus operator for type @@module@@. *)
<* ENDIF *>

PROCEDURE [ODD] odd ( n : @@module@@ ) : BOOLEAN;
(* Returns TRUE if @@module@@ value n is odd, otherwise FALSE.
   This function is bound to pervasive function ODD for type @@module@@. *)


(* Dyadic arithmetic operations *) 

PROCEDURE [+] add ( n1, n2 : @@module@@ ) : @@module@@;
(* Adds @@module@@ values n1 and n2 and returns the result.
   This function is bound to the + operator for type @@module@@. *)

PROCEDURE [-] sub ( n1, n2 : @@module@@ ) : @@module@@;
(* Subtracts @@module@@ value n2 from n1 and returns the result.
   This function is bound to the - operator for type @@module@@. *)

PROCEDURE [*] multiply ( n1, n2 : @@module@@ ) : @@module@@;
(* Multiplies @@module@@ values n1 and n2 and returns the result.
   This function it bound to the * operator for type @@module@@. *)

PROCEDURE [/] divide ( n1, n2 : @@module@@ ) : @@module@@;
(* Divives @@module@@ value n1 by n2 and returns the result.
   This function is bound to the / operator for type @@module@@. *)


(* Relational operations *) 

PROCEDURE [=] isEqual ( n1, n2 : @@module@@ ) : BOOLEAN;
(* Returns TRUE if @@module@@ values n1 and n2 are equal, otherwise FALSE.
   This function is bound to operators = and # for type @@module@@. *)

PROCEDURE [<] isLess ( n1, n2 : @@module@@ ) : BOOLEAN;
(* Returns TRUE if @@module@@ value n1 is less than n2, otherwise FASLE.
   This function is bound to operators < and >= for type @@module@@. *)

PROCEDURE [>] isGreater ( n1, n2 : @@module@@ ) : BOOLEAN;
(* Returns TRUE if @@module@@ value n1 is greater than n2, otherwise FALSE.
   This function is bound to operators > and <= for type @@module@@. *)


(* Scalar conversion primitives *)

CONST digitCapacity = @@baseType@@.digitCapacity;

PROCEDURE [TO] toSXF ( n : @@module@@; VAR s : ARRAY OF CHAR );
(* Converts @@module@@ value n to a string in scalar exchange format.
   This procedure is used to synthesise conversions to other scalar types
   when no direct conversion path exists. *)

PROCEDURE [FROM] fromSXF ( VAR n : @@module@@; CONST s : ARRAY OF CHAR );
(* Converts a string in scalar exchange format to a @@module@@ value.
   This procedure is used to synthesise conversions from other scalar types
   when no direct conversion path exists. *)


(* IO operations *)

PROCEDURE Read( infile : File; VAR n : @@module@@ );
(* Reads the textual representation of a @@module@@ value from stream infile
   - any leading whitespace is skipped
   - any remaining characters that are part of the numeral being read are
     removed from infile
   - the numeric value of the numeral string read is assigned to the variable
     passed in for n
   - the file status is set to any of:
     success, outOfRange, wrongFormat, endOfLine, or endOfInput.
   This procedure is substituted for invocations of READ with a @@module@@
   argument. *)

PROCEDURE Write( outfile : File; n : @@module@@ );
(* Writes the textual representation of value n to stream outfile.
   This procedure is substituted for invocations of WRITE with a @@module@@
   argument. *)

PROCEDURE WriteF ( outfile      : File;
                   CONST fmtStr : ARRAY OF CHAR;
                   items        : VARIADIC OF @@module@@ );
(* Writes a formatted textual representation of one or more @@module@@ values
   to output stream outfile. The output format is determined by fmtStr. This
   procedure is substituted for invocations of WRITEF with one or more
   @@module@@ arguments. *)

END @@module@@.