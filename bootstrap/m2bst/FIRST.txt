FIRST Sets for Modula-2 R10 Grammar

compilationUnit =
  { IMPLEMENTATION,
    DEFINITION,
    BLUEPRINT,
    MODULE };
  
programModule =
  { MODULE };
  
definitionModule =
  { DEFINITION };
  
blueprint =
  { BLUEPRINT };
  
identList =
  { Identifier };

moduleTypeSpec =
  { OPAQUE,
    RECORD };
  
propertySpec =
  { TPROPERTIES };
  
literalSpec =
  { TLITERAL };
  
protoLiteral =
  { Identifier,
    lBrace };
  
requirement =
  { NOT,
    Identifier,
    CONST,
    PROCEDURE,
    TYPE };
  
constRequirement =
  { CONST };
  
propertyToBindTo =
  { TDYN,
    TREFC,
    TBASE,
    TPRECISION,
    TMINEXP,
    TMAXEXP,
    TNIL,
    TLIMIT };
  
simpleConstRequirement =
  { Identifier };

procedureRequirement =
  { PROCEDURE };
  
entityToBindTo =
  { NEW,
    RETAIN,
    RELEASE,
    COPY,
    FOR,
    IN,
    DIV,
    MOD,
    COROUTINE,
    ABS,
    LENGTH,
    EXISTS,
    SUBSET,
    READ,
    READNEW,
    WRITE,
    WRITEF,
    TMIN,
    TMAX,
    SXF,
    VAL,
    COUNT,
    RETRIEVE,
    STORE,
    INSERT,
    REMOVE,
    plus,
    minus,
    asterisk,
    realDiv,
    backslash,
    equal,
    less,
    greater,
    asterDot,
    typeConv };
  
libGenDirective =
  { GENLIB };
  
importDirective =
  { IMPORT,
    FROM };
  
identifiersToImport =
  { Identifier };
  
block =
  { CONST,
    TYPE,
    VAR,
    PROCEDURE,
    BEGIN,
    END };
  
statementSequence =
  { NEW,
    RETAIN,
    RELEASE,
    Identifier,
    COPY,
    IF,
    CASE,
    LOOP,
    WHILE,
    REPEAT,
    FOR,
    RETURN,
    YIELD,
    EXIT };
  
definition =
  { CONST,
    TYPE,
    VAR,
    PROCEDURE };
  
constDefinition =
  { Identifier,
    lBracket,
    asterisk };
  
variableDeclaration =
  { Identifier };
  
declaration =
  { CONST,
    TYPE,
    VAR,
    PROCEDURE };
  
type =
  { Identifier,
    ALIAS,
    lBracket,
    CONST,
    lParen,
    SET,
    ARRAY,
    RECORD,
    POINTER,
    COROUTINE,
    PROCEDURE };

range =
  { lBracket };
  
enumType =
  { lParen };
  
setType =
  { SET };
  
arrayType =
  { ARRAY };
  
recordType =
  { RECORD };
  
fieldList =
  { asterisk,
    Identifier };
  
indeterminateField =
  { INDETERMINATE };
  
pointerType =
  { POINTER };
  
coroutineType =
  { COROUTINE };
  
procedureType =
  { PROCEDURE };
  
formalType =
  { ARRAY,
    Identifier,
    CAST,
    CONST,
    VAR,
    NEW,
    ARGLIST };
  
simpleFormalType =
  { ARRAY,
    Identifier,
    CAST };
  
attributedFormalType =
  { CONST,
    VAR,
    NEW };
  
simpleVariadicFormalType =
  { ARGLIST };
  
variadicFormalType =
  { ARGLIST };
  
nonVariadicFormalType =
  { CONST,
    VAR,
    NEW,
    ARRAY,
    Identifier,
    CAST };
  
procedureHeader =
  { PROCEDURE };
  
procedureSignature =
  { Identifier };
  
formalParams =
  { Identifier,
    CONST,
    VAR,
    NEW };
  
attributedFormalParams =
  { CONST,
    VAR,
    NEW };
  
variadicFormalParams =
  { ARGLIST };
  
nonVariadicFormalParams =
  { CONST,
    VAR,
    NEW,
    Identifier };
  
qualident =
  { Identifier };
  
statement =
  { NEW,
    RETAIN,
    RELEASE,
    Identifier,
    COPY,
    IF,
    CASE,
    LOOP,
    WHILE,
    REPEAT,
    FOR,
    RETURN,
    YIELD,
    EXIT };
  
memMgtOperation =
  { NEW,
    RETAIN,
    RELEASE };
  
updateOrProcCall =
  { Identifier,
    COPY };
  
ifStatement =
  { IF };
  
caseStatement =
  { CASE };
  
case =
  { plus,
    minus,
    NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
caseLabels =
  { plus,
    minus,
    NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
loopStatement =
  { LOOP };
  
whileStatement =
  { WHILE };
  
repeatStatement =
  { REPEAT };
  
forStatement =
  { FOR };
  
designator =
  { Identifier };
  
designatorTail =
  { lBracket,
    deref };
  
exprListOrSlice =
  { plus,
    minus,
    NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
expression =
  { plus,
    minus,
    NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
simpleExpression =
  { plus,
    minus,
    NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
term =
  { NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
factorOrNegation =
  { NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
factorOrTypeConv =
  { numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
factor =
  { numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
actualParameters =
  { lParen };
  
expressionList =
  { plus,
    minus,
    NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
structuredValue =
  { lBrace };
  
valueComponent =
  { plus,
    minus,
    NOT,
    numericLiteral,
    quotedLiteral,
    lBrace,
    lParen,
    Identifier };
  
END OF FILE