(* (C) 2009, 2010 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

DEFINITION MODULE FileIO;

(* Driver for File Based IO *)


FROM Integers IMPORT CARDINAL64;


(* File handle, file status and file mode *)

TYPE
    File = OPAQUE; (* implementation defined file handle *)
        
    Status = ( success,               (* operation completed successfully   *)
               invalidHandle,         (* the passed in handle is invalid    *)
               fileNotFound,          (* no file found with this filename   *)
               nameTooLong,           (* the passed in filename is too long *)
               invalidName,           (* the passed in filename is invalid  *)
               invalidMode,           (* the passed in mode is invalid      *)
               alreadyOpen,           (* the passed in file is already open *)
               accessDenied,          (* the filesystem denied file access  *)
               accessBeyondEOF,       (* attempt to read past end of file   *)
               fileSizeLimitExceeded, (* attempt to write past size limit   *)
               openFileLimitExceeded, (* attempt to open too many files     *)
               deviceFull,            (* the device capacity is exceeded    *)
               deviceError );         (* the device reported a failure      *)

    Mode = SET OF ( read,             (* reading is permitted if set        *)
                    write,            (* writing is permitted if set        *)
                    append,           (* writing always appends if set      *)
                    sync );           (* writing always flushes if set      *)


(* Alias types for implementation dependent file position and file size *)

    FilePos, FileSize IS CARDINAL64; (* assuming 64-bit file systems *)


(* Predefined file modes *)

CONST
    write = { Mode.write };
    readOnly = { Mode.read };
    readWrite = { Mode.read, Mode.write };
    append = { Mode.write, Mode.append };
    
    defaultBufferSize = <implementation defined value>;


(* Predefined open file handles *)

VAR
    stdIn, stdOut, stdErr, nullFile : File;


(* Opening files *)

PROCEDURE Open ( VAR file : File;
                 filename : ARRAY OF CHAR; mode : Mode; VAR status : Status );
(* Opens the file <filename> in file mode <mode>. If sucessful passes a file
   handle back in <file>, otherwise passes NIL back in <file>. The status of
   the operation is passed back in <status>. *)

PROCEDURE OpenWithBuffer ( VAR file   : File;
                           filename   : ARRAY OF CHAR;
                           mode       : Mode;
                           VAR buffer : ARRAY OF OCTET;
                           VAR status : Status );
(* Opens the file <filename> in file mode <mode> using <buffer> as a custom
   file buffer. If successful passes a file handle back in <file>, otherwise
   passes NIL back in <file>. The status is passed back in <status>. *)

PROCEDURE ReOpen ( VAR file : File; mode : Mode );
(* Closes the file associated with <file> and reopens it in mode <mode>.*)


(* File mode, status and name *)

PROCEDURE ModeOf ( file : File ) : Mode;
(* Returns the file mode of file handle <file>.
   Returns an empty set if <file> is invalid. *)

PROCEDURE StatusOf ( file : File ) : Status;
(* Returns the status of the most recent operation for file handle <file>. *)

PROCEDURE GetName ( file : File; VAR filename : ARRAY OF CHAR );
(* Passes the name of the file associated with <file> back in <filename>.
   Passes an empty string if <file> is invalid or if the name exceeds the
   capacity of <filename>. *)


(* File position operations *)

PROCEDURE EOF ( file : File ) : BOOLEAN;
(* Returns TRUE if the end of the file associated with file handle <file> has
   been reached, otherwise FALSE. *)

PROCEDURE CurrentPos ( file : File ) : FilePos;
(* Returns the current read/write position for file handle <file>. *)

PROCEDURE SetPos ( file : File; index : FilePos );
(* Sets the read/write position for file handle <file> to <index>. *)

PROCEDURE Advance ( file : File; offset : FilePos );
(* Advances the read/write position for file handle <file> by <offset>. *)

PROCEDURE Rewind ( file : File );
(* Sets the read/write position for file handle <file> to the beginning of
   the file and resets its end-of-file status. *)


(* Read and write operations *)

PROCEDURE Read ( file : File; VAR data : OCTET );
(* Reads one octet of data at the current position of <file>, passes it back
   in <data> and advances the read/write position of <file> by one. *)

PROCEDURE Write ( file : File; data : OCTET );
(* Writes one octet passed in <data> to the current position of <file> and
   advances the read/write position of <file> by one. *)

PROCEDURE Lookahead ( file : File; VAR data : OCTET );
(* Passes one octet of data at the current position of <file> back in <data>
   without advancing the read/write position of <file>. *)

PROCEDURE ReadBlock ( file : File;
                      VAR data : ARRAY OF OCTET; VAR octetsRead : FileSize );
(* Reads a block of data at the current position of <file>. Passes the block
   of data back in <data> and the number of octets read in <octetsRead>.
   The read/write position of <file> is advanced accordingly. *)

PROCEDURE WriteBlock ( file : File;
                       data : ARRAY OF OCTET; VAR octetsWritten : FileSize );
(* Writes the block of data passed in <data> starting at the current position
   of <file> and passed the number of octets written back in <octetsWritten>. 
   The read/write position of <file> is advanced accordingly. *)

PROCEDURE Flush ( file : File );
(* Writes unwritten data in the buffer of <file> to its associated file. *)


(* Closing files *)

PROCEDURE Close ( VAR file : File; VAR status : Status );
(* Preforms Flush on <file> and closes the associated file. Passes NIL back
   in <file>. The status of the operation is passed back in <status>. *)

END FileIO.