(* (C) 2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* DOCUMENTATION *) DEFINITION MODULE BINDINGS;

(* Pseudo Module to Document Binding Signatures *)


(* Constant Bindings *)

CONST [:=] isMutable : BOOLEAN;
(* whether an ADT is mutable or immutable *)

CONST [DESCENDING] isOrdered : BOOLEAN;
(* whether an ADT implements descending order for loop iteration *)

CONST [TSIGNED] isSigned : BOOLEAN;
(* whether a numeric scalar ADT is signed or unsigned *)

CONST [TBASE] radix : CARDINAL (* 2 or 10 *);
(* the radix in which values of a numeric scalar ADT are encoded *)

CONST [TPRECISION] precision : [1..4000] OF CARDINAL;
(* the number of digits of the longest encodable significand
   of a numeric scalar ADT. *)

CONST [TMINEXP] eMin : [-64..0] OF INTEGER;
(* the number of digits of the smallest encodable exponent
   of a numeric scalar ADT, zero for whole number types *)

CONST [TMAXEXP] eMax : [0..63] OF CARDINAL;
(* the number of digits of the largest encodable exponent
   of a numeric scalar ADT, zero for whole number types *)


(* Procedure Bindings *)

PROCEDURE [:=] (* static ADT literal assignment *)
(* TO DO *)

PROCEDURE [:=] (* static ADT copy assignment *)
(* TO DO *)

PROCEDURE [NEW] new
  ( VAR a : <ADT>; initWith : ARGLIST OF <ValueType> );
(* Validity:
    dynamically allocatable ADTs only
   Semantics:
    allocates a new variable of the ADT,
	initialises it with zero or more values of its value type,
	and returns it in the operand which must be NIL upon entry *)

PROCEDURE [RETAIN] retain ( a : <ADT> );
(* Validity:
    dynamically allocatable ADTs only
   Semantics:
    retains the operand and prevents deallocation *)

PROCEDURE [RELEASE] release ( a : <ADT> );
(* Validity:
    dynamically allocatable ADTs only
   Semantics:
    cancels a pending retain of the operand,
	deallocates the operand if there are no pending retains *)

PROCEDURE [CONCAT] concat
 ( VAR target : <StringADT>; source : ARGLIST OF <StringADT> );
(* Validity:
    string ADTs only
   Semantics:
    concatenates all source strings from left to right,
	and returns the resulting string in target *)

PROCEDURE [..] copySlice
  ( VAR target : <StringADT>; tgtStartIndex, tgtEndIndex : INTEGER;
	source : <StringADT>; srcStartIndex, srcEndIndex : INTEGER );
(* TO DO *)

PROCEDURE [STORE] storeValue
  ( VAR a : <IndexedADT>; index : <IndexType>; value : <ValueType> );
(* Validity:
    mutable indexed collection ADTs, including string ADTs
   Semantics:
    stores value at index in an indexed collection,
	replacing any previous value *)

PROCEDURE [STORE] storeValues
  ( VAR a : <SetADT>; values : ARGLIST OF <ElementType> );
(* Validity:
    mutable set and counted set ADTs
   Semantics:
    stores one or more values in a set or counted set *)

PROCEDURE [STORE] storeKeysAndValues
  ( VAR a : <CollectionADT>;
    entries : ARGLIST OF { key : <KeyType>; value : <ValueType> } );
(* Validity:
    mutable key/value collection ADTs
   Semantics:
    stores one or more key/value pair entries in a collection *)

PROCEDURE [INSERT] insertChars
  ( VAR target : <StringADT>; index : INTEGER;
    chars : ARRAY OF <CharType> );
(* Validity:
    mutable string ADTs only
   Semantics:
    inserts chars into a target string, starting at index *)

PROCEDURE [INSERT] insertString
  ( VAR target : <StringADT>; index : INTEGER; source : <StringADT> );
(* Validity:
    mutable string ADTs only
   Semantics:
    inserts a source string into a target string, starting at index *)

PROCEDURE [INSERT] insertValues
  ( target : <ArrayADT>; index : <IndexType>;
    values : ARGLIST of <ValueType> );
(* Validity:
    mutable dynamically allocatable indexed collection ADTs only
   Semantics:
    inserts values into a target array, starting at index *)

PROCEDURE [INSERT] insertArray
  ( target : <ArrayADT>; index : <IndexType>; source : <ArrayADT> );
(* Validity:
    mutable dynamically allocatable indexed collection ADTs only
   Semantics:
    inserts a source array into a target array,
	starting at index *)

PROCEDURE [REMOVE] removeCharsAtIndex
  ( a : <StringADT>; index : INTEGER; n : POSINT );
(* Validity:
    mutable string ADTs
   Semantics:
    remove n characters from a string, starting at index *)

PROCEDURE [REMOVE] removeValuesAtIndex
  ( a : <ArrayADT>; index : <IndexType>; n : LONGCARD );
(* Validity:
    mutable dynamically allocatable indexed collection ADTs
   Semantics:
    remove n items from an array, starting at index *)

PROCEDURE [REMOVE] removeValues
  ( a : <SetADT>; values : ARGLIST OF <ElementType> );
(* Validity:
    mutable set and counted set ADTs
   Semantics:
    remove one or more values from a set or counted set *)

PROCEDURE [REMOVE] removeKeyValuePairs
  ( a : <SetADT>; keys : ARGLIST OF <KeyType> );
(* Validity:
    mutable key/value collection ADTs
   Semantics:
    remove one or more key/value pairs from a collection *)

PROCEDURE [FOR] forIterator
  ( a : <ADT>; forLoopBody : <ProcType>; ascending : BOOLEAN );
(* Validity:
    ordinal ADTs and collection ADTs
   Semantics:
    iterate over all values of the ADT,
	executing forLoopBody for each value,
	in ascending order if ascending is TRUE, else descending *)

PROCEDURE [READ] (* TO DO *)

PROCEDURE [WRITE] (* TO DO *)

PROCEDURE [WRITEF] (* TO DO *)

PROCEDURE [SXF] (* TO DO *)

PROCEDURE [VAL] (* TO DO *)


(* Function Bindings *)

PROCEDURE [+] add ( left, right : <ADT> ) : <OperandType>;
(* TO DO *)

PROCEDURE [-] subtract ( left, right : <ADT> ) : <OperandType>;
(* TO DO *)

PROCEDURE [*] multiply ( left, right : <ADT> ) : <OperandType>;
(* TO DO *)

PROCEDURE [/] divide ( left, right : <ADT> ) : <OperandType>;
(* TO DO *)

PROCEDURE [DIV] divide ( left, right : <ADT> ) : <OperandType>;
(* TO DO *)

PROCEDURE [MOD] modulus ( left, right : <ADT> ) : <OperandType>;
(* TO DO *)

PROCEDURE [=] isEqual ( left, right : <ADT> ) : BOOLEAN;
(* TO DO *)

PROCEDURE [<] isLess ( left, right : <ADT> ) : BOOLEAN;
(* TO DO *)

PROCEDURE [>] isGreater ( left, right : <ADT> ) : BOOLEAN;
(* TO DO *)

PROCEDURE [IN] isElement ( a : <ADT>; s : <SelectorType> ) : BOOLEAN;
(* TO DO *)

PROCEDURE [ABS] abs ( value : <ADT> ) : <OperandType>;
(* Validity:
    numeric scalar ADTs only
   Semantics:
    returns the absolute value of the operand *)

PROCEDURE [NEG] neg ( value : <ADT> ) : <OperandType>;
(* Validity:
    signed numeric scalar ADTs only
   Semantics:
    returns the sign reversed value of the operand *)

PROCEDURE [DUP] duplicateOf ( a : <ADT> ) : <OperandType>;
(* Validity:
    dynamically allocatable ADTs only
   Semantics:
    returns a newly allocated deep copy of the operand *)

PROCEDURE [COUNT] count ( a : <ADT> ) : LONGCARD;
(* Validity:
    collection ADTs only, excluding string ADTs
   Semantics:
    returns the number of components stored in the operand *)

PROCEDURE [LENGTH] length ( s : <StringADT> ) : POSINT;
(* Validity:
    string ADTs only
   Semantics:
    returns the length of the operand *)

PROCEDURE [RETRIEVE] (* TO DO *)

PROCEDURE [SUBSET] (* TO DO *)

PROCEDURE [TMIN] (* TO DO *)

PROCEDURE [TMAX] (* TO DO *)

	
END BINDINGS.