(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* DOCUMENTATION *) DEFINITION MODULE PREDEFINED;

(* Pseudo Module to Document Predefined Constants, Types and Macros *)


(* Predefined constants *)

CONST NIL = <target dependent value>; (* usually 0 :: ADDRESS *)
(* Invalid pointer value, compatible with all pointer types *)

CONST  NULSTR = "";
(* Empty character array *)

CONST TRUE = BOOLEAN.TRUE;
(* Boolean truth value 'true' *)

CONST FALSE = BOOLEAN.FALSE;
(* Boolean truth value 'false' *)


(* Predefined types *)

TYPE BOOLEAN = ( FALSE, TRUE );
(* Boolean type *)

TYPE CHAR = 0u0 .. 0u7F ;
(* Ordinal type with 7-bit character value set *)

TYPE UNICHAR = <range of all UTF-32 code points>;
(* Ordinal type with 4-octet character value set *)

TYPE OCTET = 0 .. 255;
(* 8-bit unsigned integer type *)

TYPE CARDINAL = 0 .. 2^(16*octets) - 1;
(* 2*n bit unsigned integer type, n > 0 *)

TYPE LONGCARD = 0 .. 2^(16*octets) - 1;
(* 2*n bit unsigned integer type, n > 0,
   TSIZE(LONGCARD) >= TSIZE(CARDINAL) is always true *)

TYPE INTEGER = -2^(8*TSIZE(CARDINAL) - 1) .. 2^(8*TSIZE(CARDINAL) - 1) - 1;
(* Signed integer type of same size as CARDINAL *)

TYPE LONGINT = -2^(8*TSIZE(LONGCARD) - 1) .. 2^(8*TSIZE(LONGCARD) - 1) - 1;
(* Signed integer type of same size as LONGCARD *)

TYPE REAL = <implementation or target dependent real number range>;
(* Real number type, typically implemented as a floating point type *)

TYPE LONGREAL = <implementation or target dependent real number range>;
(* Real number type with precision equal to or higher than REAL *)


(* Predefined proper procedures *)

PROCEDURE STORE
  ( VAR c : <Collection>; s : <SelectorType>; v : <ValueType> );
(* STORE(c, s, v) => typeOf(c).addValueForKey(c, s, v) *)

PROCEDURE INSERT
  ( VAR target : <Array>;
    index : <IndexType>; values : ARGLIST OF ValueType );
(* INSERT(target, index, v1, v2, v3, ...)
   => insert values v1, v2, v3, ... into target array, starting at index. *)

PROCEDURE INSERT
  ( VAR target : <Set>;
    elements : ARGLIST OF ElementType );
(* INSERT(target, elem1, elem2, elem3, ...)
   => insert elements elem1, elem2, elem3, ... into target set. *)

PROCEDURE INSERT
  ( VAR target : <Dictionary>;
    keysAndValues : ARGLIST OF { key : KeyType; value : ValueType } );
(* INSERT(target, key1, val1, key2, val2, key3, val3, ...)
   => insert key/value pairs
      key1, val1, key2, val2, key3, val3, ... into target dictionary. *)

PROCEDURE REMOVE ( VAR target : <Array>; startIndex, endIndex : IndexType );
(* REMOVE(array, start, end)
   => remove values within index range [start .. end] from target array. *)

PROCEDURE REMOVE ( VAR target : <Set>; elements : ARGLIST OF ElementType );
(* REMOVE(set, elem1, elem2, elem3, ...)
   => remove elements elem1, elem2, elem3, ... from target set. *)

PROCEDURE REMOVE ( VAR target : <Dictionary>; keys : ARGLIST OF KeyType );
(* REMOVE(dict, key1, key2, key3, ...)
   => remove key/value pairs with keys
      key1, key2, key3, ... from target dictionary. *)

PROCEDURE SORT ( VAR result : <Array>; source : <Collection>; order : CHAR );
(* SORT(array, collection, "+")
   => populate array with accessors of collection sorted by value, ascending *) 

PROCEDURE READ ( f : File; VAR v : <AnyMutableType> );
(* READ(f, v) => typeOf(v).Read(f, v) *)

PROCEDURE READNEW ( f : File; NEW v : <AnyType> );
(* READNEW(f, v) => typeOf(v).ReadNew(f, v) *)

PROCEDURE WRITE ( f : File; v : <AnyType> );
(* WRITE(f, v) => typeOf(v).Write(f, v) *)

PROCEDURE WRITEF
  ( f : File; fmt : ARRAY OF CHAR; v : ARGLIST OF <AnyType> );
(* WRITEF(f, fmt, v1, v2, ...)
   => typeOf(v).WriteF(f, fmt, v1, v2, ...) *)


(* Predefined function procedures *)

PROCEDURE ABS ( x : <NumericType> ) : <OperandType>;
(* Returns sign removed value of x *)

PROCEDURE NEG ( x : <NumericType> ) : <OperandType>;
(* Returns sign reversed value of x *)

PROCEDURE ODD ( x : <WholeNumberType> ) : BOOLEAN;
(* Returns TRUE if z is odd, otherwise FALSE *)

PROCEDURE PRED ( x : <OrdinalType>; (* OPT *) n : <UnsignedType> ) : <typeOf(x)>;
(* Returns n-th predecessor of x, or immediate predecessor if n is omitted *)

PROCEDURE SUCC ( x : <OrdinalType>; (* OPT *) n : <UnsignedType> ) : <typeOf(x)>;
(* Returns n-th successor of x, or immediate successor if n is omitted *)

PROCEDURE ORD ( x : <OrdinalType> ) : <WholeNumberType>;
(* Returns ordinal value of x *)

PROCEDURE CHR ( x : <UnsignedType> ) : <CharOrUnicharType>; 
(* Returns the character whose code point is x.
   Return type is CHAR if x < 128, otherwise UNICHAR *)

PROCEDURE SUBSET ( a, b : <SetOrCollectionType> ) : BOOLEAN ;
(* Returns TRUE if b is a subset of a *)

PROCEDURE COUNT ( c : <SetOrCollectionType> ) : LONGCARD;
(* Returns number of items stored in c *)

PROCEDURE LENGTH
  ( CONST s : <CharacterArrayOrStringADT> ) : [0..TMAX(INTEGER)] OF INTEGER;
(* Returns the length of character string s. *)

PROCEDURE PTR ( variable : <AnyType>; T : <TypeIdentifier> ) : <T> ;
(* Returns a pointer of type T, pointing to variable *)

PROCEDURE RETRIEVE
  ( c : <CollectionType>; s : <ComponentType> ) : <ReturnType>;
(* RETRIEVE(c, s) => typeOf(c, s) *)

PROCEDURE MIN ( arglist : ARGLIST OF <T> ) : <T>;
(* Returns smallest value from arglist *)

PROCEDURE MAX ( arglist : ARGLIST OF <T> ) : <T>;
(* Returns largest value from arglist *)

PROCEDURE TMIN ( T : <TypeIdentifier> ) : <T>;
(* Returns smallest legal value of type T *)

PROCEDURE TMAX ( T : <TypeIdentifier> ) : <T>;
(* Returns largest legal value of type T *)

PROCEDURE TLIMIT ( T : <SetOrCollectionTypeIdentifier> ) : LONGCARD;
(* Returns capacity limit of a set, array or collection type *)

PROCEDURE TSIZE ( T : <TypeIdentifier> ) : LONGCARD;
(* Returns allocation size required for a variable of type T *)


END PREDEFINED.