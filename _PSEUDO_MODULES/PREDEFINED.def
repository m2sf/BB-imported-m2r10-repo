(* (C) 2009-2014 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

(* DOCUMENTATION *) DEFINITION MODULE PREDEFINED;

(* Pseudo Module to Document Predefined Constants, Types and Macros *)


(* Predefined constants *)

CONST NIL = <target dependent value>; (* usually 0 :: ADDRESS *)
(* Invalid pointer value, compatible with all pointer types *)

CONST NONE = {};
(* Empty structured literal  *)

CONST TRUE = BOOLEAN.TRUE;
(* Boolean truth value 'true' *)

CONST FALSE = BOOLEAN.FALSE;
(* Boolean truth value 'false' *)


(* Predefined types *)

TYPE BOOLEAN = ( FALSE, TRUE );
(* Boolean type *)

TYPE CHAR = 0u0 .. 0u7F ;
(* Ordinal type with 7-bit character value set *)

TYPE UNICHAR = <range of all UTF-32 code points>;
(* Ordinal type with 4-octet character value set *)

TYPE OCTET = 0 .. 255;
(* 8-bit unsigned integer type *)

TYPE CARDINAL = 0 .. 2^(16*octets) - 1;
(* 2*n bit unsigned integer type, n > 0 *)

TYPE LONGCARD = 0 .. 2^(16*octets) - 1;
(* 2*n bit unsigned integer type, n > 0,
   TSIZE(LONGCARD) >= TSIZE(CARDINAL) is always true *)

TYPE INTEGER = -2^(8*TSIZE(CARDINAL) - 1) .. 2^(8*TSIZE(CARDINAL) - 1) - 1;
(* Signed integer type of same size as CARDINAL *)

TYPE LONGINT = -2^(8*TSIZE(LONGCARD) - 1) .. 2^(8*TSIZE(LONGCARD) - 1) - 1;
(* Signed integer type of same size as LONGCARD *)

TYPE REAL = <implementation or target dependent real number range>;
(* Real number type, typically implemented as a floating point type *)

TYPE LONGREAL = <implementation or target dependent real number range>;
(* Real number type with precision equal to or higher than REAL *)


(* Predefined proper procedures *)

PROCEDURE STORE
  ( VAR c : <Collection>; s : <SelectorType>; v : <ValueType> );
(* STORE(c, s, v) => typeOf(c).addValueForKey(c, s, v) *)

PROCEDURE INSERT
  ( VAR target : <Collection>; i : <IndexType>;
   values : ARGLIST OF ValueType );
(* INSERT(target, i, v1, v2, v3, ...)
   => insert v1, v2, v3, ... into target, starting at index i. *)

PROCEDURE REMOVE ( VAR c : <Collection>; s : <SelectorType> );
(* REMOVE(c, s) => typeOf(c).removeValueForKey(c, s) *)

PROCEDURE SORT ( VAR result : <Array>; source : <Collection>; order : CHAR );
(* SORT(array, collection, "+")
   => populate array with accessors of collection sorted by value, ascending *) 

PROCEDURE READ ( f : File; VAR v : <AnyMutableType> );
(* READ(f, v) => typeOf(v).Read(f, v) *)

PROCEDURE READNEW ( f : File; NEW v : <AnyType> );
(* READNEW(f, v) => typeOf(v).ReadNew(f, v) *)

PROCEDURE WRITE ( f : File; v : <AnyType> );
(* WRITE(f, v) => typeOf(v).Write(f, v) *)

PROCEDURE WRITEF
  ( f : File; fmt : ARRAY OF CHAR; v : ARGLIST OF <AnyType> );
(* WRITEF(f, fmt, v1, v2, ...)
   => typeOf(v).WriteF(f, fmt, v1, v2, ...) *)


(* Predefined function procedures *)

PROCEDURE ABS ( x : <NumericType> ) : <OperandType>;
(* Returns sign removed value of x *)

PROCEDURE NEG ( x : <NumericType> ) : <OperandType>;
(* Returns sign reversed value of x *)

PROCEDURE ODD ( x : <WholeNumberType> ) : BOOLEAN;
(* Returns TRUE if z is odd, otherwise FALSE *)

PROCEDURE PRED ( x : <OrdinalType>; (* OPT *) n : <UnsignedType> ) : <typeOf(x)>;
(* Returns n-th predecessor of x, or immediate predecessor if n is omitted *)

PROCEDURE SUCC ( x : <OrdinalType>; (* OPT *) n : <UnsignedType> ) : <typeOf(x)>;
(* Returns n-th successor of x, or immediate successor if n is omitted *)

PROCEDURE ORD ( x : <OrdinalType> ) : <WholeNumberType>;
(* Returns ordinal value of x *)

PROCEDURE CHR ( x : <UnsignedType> ) : <CharOrUnicharType>; 
(* Returns the character whose code point is x.
   Return type is CHAR if x < 128, otherwise UNICHAR *)

PROCEDURE SUBSET ( a, b : <SetOrCollectionType> ) : BOOLEAN ;
(* Returns TRUE if b is a subset of a *)

PROCEDURE COUNT ( c : <SetOrCollectionType> ) : LONGCARD;
(* Returns number of items stored in c *)

PROCEDURE LENGTH
  ( CONST s : <CharacterArrayOrStringADT> ) : [0..TMAX(INTEGER)] OF INTEGER;
(* Returns the length of character string s. *)

PROCEDURE PTR ( variable : <AnyType>; T : <TypeIdentifier> ) : <T> ;
(* Returns a pointer of type T, pointing to variable *)

PROCEDURE RETRIEVE
  ( c : <CollectionType>; s : <ComponentType> ) : <ReturnType>;
(* RETRIEVE(c, s) => typeOf(c, s) *)

PROCEDURE MIN ( arglist : ARGLIST OF <T> ) : <T>;
(* Returns smallest value from arglist *)

PROCEDURE MAX ( arglist : ARGLIST OF <T> ) : <T>;
(* Returns largest value from arglist *)

PROCEDURE TMIN ( T : <TypeIdentifier> ) : <T>;
(* Returns smallest legal value of type T *)

PROCEDURE TMAX ( T : <TypeIdentifier> ) : <T>;
(* Returns largest legal value of type T *)

PROCEDURE TLIMIT ( T : <SetOrCollectionTypeIdentifier> ) : LONGCARD;
(* Returns capacity limit of a set, array or collection type *)

PROCEDURE TSIZE ( T : <TypeIdentifier> ) : LONGCARD;
(* Returns allocation size required for a variable of type T *)


END PREDEFINED.