(* (C) 2015 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

DEFINITION MODULE TPROPERTIES;

(* Macros to query lower level properties of types *)


(* General Properties *)

(* MACRO *) PROCEDURE TDYN ( <Type> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is dynamic, FALSE if it is static. *)

(* MACRO *) PROCEDURE TREFC ( <Type> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is reference counted, otherwise FALSE. *)

(* MACRO *) PROCEDURE TCOMP ( <Type> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is computational, otherwise FALSE. *)

(* MACRO *) PROCEDURE TBDFOR ( <Type> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed as
   its argument supports bidirectional FOR loop iteration, otherwise FALSE. *)


(* Collection Properties *)

(* MACRO *) PROCEDURE TNIL ( <CollectionType> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument supports storage of NIL as a value, otherwise FALSE. *)

(* MACRO *) PROCEDURE TBYIDX ( <CollectionType> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is an indexed collection type, otherwise FALSE. *)

(* MACRO *) PROCEDURE TBYKEY ( <CollectionType> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is a key/value storage type, otherwise FALSE. *)

(* MACRO *) PROCEDURE TBYVAL ( <CollectionType> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is a value-only storage type, otherwise FALSE. *)

(* MACRO *) PROCEDURE TRIGID ( <IndexedCollectionType> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument does not support append, insert and remove operations,
   otherwise FALSE. *)

(* Any invocation of the above macros with an argument that is not an
   identifier of a collection type will cause a compile time error. *)


(* Numeric Properties *)

(* MACRO *) PROCEDURE TNUM ( <Type> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is numeric, otherwise FALSE. *)

(* Inspecting the number representation of scalar types *)

(* MACRO *) PROCEDURE TSIGNED ( <NumericScalarType> ) : BOOLEAN;
(* An invocation of the macro is replaced by TRUE if the type passed
   as its argument is signed, otherwise FALSE. *)

(* MACRO *) PROCEDURE TBASE ( <NumericScalarType> ) : CARDINAL;
(* An invocation of the macro is replaced by the radix of the type
   passed as its argument. *)

(* MACRO *) PROCEDURE TPRECISION ( <NumericScalarType> ) : CARDINAL;
(* An invocation of the macro is replaced by the precision of the type
   passed as its argument.  The precision is the number of digits of the
   longest significand that can be encoded by the type.  The replacement
   value always indicates the digits in the radix of the type. *)

(* MACRO *) PROCEDURE TMINEXP ( <NumericScalarType> ) : INTEGER;
(* An invocation of the macro is replaced by the smallest exponent that
   can be encoded by the type.  The value is zero for ordinal types. *)

(* MACRO *) PROCEDURE TMAXEXP ( <NumericScalarType> ) : CARDINAL;
(* An invocation of the macro is replaced by the largest exponent that
   can be encoded by the type.  The value is zero for ordinal types. *)

(* Any invocation of scalar property macros with an argument that is not an
   identifier of a numeric scalar type will cause a compile time error. *)


END TPROPERTIES.