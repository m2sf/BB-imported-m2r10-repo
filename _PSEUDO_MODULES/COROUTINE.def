(*!m2r10*) (* (C) 2015 by B.Kowarsch & R.Sutcliffe. All rights reserved. *)

DEFINITION MODULE COROUTINE;


CONST DefaultStackSize = 4096;

CONST SuppportsAutomaticStackResize = <implementation defined boolean value>;


(* A coroutine type is declared using the COROUTINE type constructor syntax:

TYPE Coro = COROUTINE ( AssocProcTypeIdent ); *)


(* Procedures to be associated with a coroutine must be explicitly marked:

PROCEDURE [COROUTINE] assocProc ( p1 : T1; p2 : T2; p3 : T3; ... ) : Result; *)


(* Coroutines have one of three states *)

TYPE State = ( waiting, running, done );


(* General Control Facilities *)

PROCEDURE [CODONE] allDone ( list : ARGLIST OF <CoroutineType> ) : BOOLEAN;
(* Returns TRUE if all coroutines in the argument list have terminated,
   returns FALSE if any coroutine in the list has not yet terminated.
   The procedure is bound to predefined function CODONE.
   
   Usage:
   
   REPEAT
     AWAKE(co1); AWAKE(co2); AWAKE(co3)
   UNTIL CODONE(co1, co2, co3); *)


PROCEDURE [NEW] new
  ( NEW co : <CoroutineType>;
    stackSize : CARDINAL; p : AssocProcType; p1 : T1; p2 : T2; p3 : T3 ... );
(* Allocates and initialises a new coroutine, puts co into state waiting.
   When zero is passed for stackSize, DefaultStackSize is used.
   The procedure is bound to the NEW statement.
   
   Usage:
   
   NEW co := { 0, assocProc, p1, p2, p3, ... }; *)


PROCEDURE [AWAKE] awake ( co : <CoroutineType> ) : ResultType;
(* Passes control to coroutine co, puts co into state running.
   Returns result if co yields or returns a result.
   Raises runtime fault if co is in state done unless intercepted by a handler.
   The procedure is bound to predefined procedure AWAKE.
   
   Usage:
   
   AWAKE(co);
   result := AWAKE(co); *)


PROCEDURE [YIELD] yield ( result : ResultType );
(* Yields control and passes result to the caller, puts co into state waiting.
   ResultType must match the return type of co's associated procedure.
   No result must be passed if co's associated procedure is not a function.
   This procedure is bound to the YIELD statement.
   
   Usage:
   
   YIELD;
   YIELD result; *)


(* To terminate a coroutine, the RETURN statement is used instead of YIELD:

   Usage:
   
   RETURN;
   RETURN result; *)


PROCEDURE [RELEASE] release (VAR co : <CoroutineType> );
(* Deallocates coroutine co and passes NIL back in co.
   Raises a runtime fault if CurrentState(co) is not done.
   This procedure is bound to the RELEASE statement.
   
   Usage:
   
   RELEASE co; *)


(* Fine-Grained Control Facilities *)

(* Obtain the state of a coroutine *)

PROCEDURE currentState ( co : <CoroutineType> ) : State;
(* Returns the current state of coroutine co. *)


(* Coroutines may be scheduled for premature termination *)

PROCEDURE scheduleTermination ( co : <CoroutineType> );
(* Puts co into state done immediately if it is waiting, or after its next
   yield if it is running. Invocation is ignored if co is already done. *)


PROCEDURE terminationScheduled ( co : <CoroutineType> ) : BOOLEAN;
(* Returns TRUE if co has been scheduled for termination, otherwise FALSE. *)


(* User handlers may intercept attempts to activate dead coroutines *)

PROCEDURE InstallAwakeDeadCoroHandler
  ( co : <CoroutineType>; handler : <HandlerType> );
(* Installs a user defined fault event handler for coroutine co. By defuault,
   an attempt to call AWAKE on a coroutine that has already terminated will
   raise a runtime fault. If a handler is installed, no runtime fault will be
   raised and the handler's return value is returned by AWAKE. The signature
   of the handler must match the signature of the procedure associated with
   the coroutine. A handler may be removed by passing NIL for handler.
   
   Usage:
   
   Signature of Coroutine Associated Procedure
   
   PROCEDURE [COROUTINE] Foo ( n : CARDINAL ) : INTEGER;
   
   Matching User Handler
   
   PROCEDURE IgnoreAwakeDeadCoro ( n : CARDINAL ) : INTEGER;
   BEGIN
     RETURN -1;
   END IgnoreAwakeDeadCoro;
   
   Installing the Handler
   
   InstallAwakeDeadCoroHandler(co, IgnoreAwakeDeadCoro); *) 


END COROUTINE.